"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure+bip39@1.1.0";
exports.ids = ["vendor-chunks/@scure+bip39@1.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@scure+bip39@1.1.0/node_modules/@scure/bip39/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/@scure+bip39@1.1.0/node_modules/@scure/bip39/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ const _assert_1 = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.1.3/node_modules/@noble/hashes/_assert.js\");\nconst pbkdf2_1 = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.1.3/node_modules/@noble/hashes/pbkdf2.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.1.3/node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.1.3/node_modules/@noble/hashes/sha512.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.1.3/node_modules/@noble/hashes/utils.js\");\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js\");\n// Japanese wordlist\nconst isJapanese = (wordlist)=>wordlist[0] === \"あいこくしん\";\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n    if (typeof str !== \"string\") throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize(\"NFKD\");\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(\" \");\n    if (![\n        12,\n        15,\n        18,\n        21,\n        24\n    ].includes(words.length)) throw new Error(\"Invalid mnemonic\");\n    return {\n        nfkd: norm,\n        words\n    };\n}\nfunction assertEntropy(entropy) {\n    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function generateMnemonic(wordlist, strength = 128) {\n    _assert_1.default.number(strength);\n    if (strength % 32 !== 0 || strength > 256) throw new TypeError(\"Invalid entropy\");\n    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nconst calcChecksum = (entropy)=>{\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([\n        (0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft\n    ]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== \"string\") throw new Error(\"Worlist: expected array of 2048 strings\");\n    wordlist.forEach((i)=>{\n        if (typeof i !== \"string\") throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */ function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? \"　\" : \" \");\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */ function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nconst salt = (passphrase)=>nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeed(mnemonic, passphrase = \"\") {\n    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeedSync(mnemonic, passphrase = \"\") {\n    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNjdXJlK2JpcDM5QDEuMS4wL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHQSxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUN6Syx1RkFBdUYsR0FDdkYsTUFBTVEsWUFBWUMsbUJBQU9BLENBQUMsbUhBQXVCO0FBQ2pELE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGlIQUFzQjtBQUMvQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxpSEFBc0I7QUFDL0MsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsaUhBQXNCO0FBQy9DLE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLCtHQUFxQjtBQUM3QyxNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQyx1R0FBYTtBQUNwQyxvQkFBb0I7QUFDcEIsTUFBTU0sYUFBYSxDQUFDQyxXQUFhQSxRQUFRLENBQUMsRUFBRSxLQUFLO0FBQ2pELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsb0ZBQW9GO0FBQ3BGLFNBQVNDLEtBQUtDLEdBQUc7SUFDYixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlDLFVBQVUsQ0FBQyx1QkFBdUIsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDOUQsT0FBT0EsSUFBSUUsU0FBUyxDQUFDO0FBQ3pCO0FBQ0EsU0FBU0EsVUFBVUYsR0FBRztJQUNsQixNQUFNRyxPQUFPSixLQUFLQztJQUNsQixNQUFNSSxRQUFRRCxLQUFLRSxLQUFLLENBQUM7SUFDekIsSUFBSSxDQUFDO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHLENBQUNDLFFBQVEsQ0FBQ0YsTUFBTUcsTUFBTSxHQUMzQyxNQUFNLElBQUlDLE1BQU07SUFDcEIsT0FB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UUFBUSxFQUFFTSxhQUFhLEVBQUU7SUFDakQsT0FBTyxDQUFDLEdBQUc1QyxTQUFTaUQsTUFBTSxFQUFFL0MsU0FBUzRDLE1BQU0sRUFBRXBDLFVBQVU0QixVQUFVL0IsSUFBSSxFQUFFb0MsS0FBS0MsYUFBYTtRQUFFRyxHQUFHO1FBQU1DLE9BQU87SUFBRztBQUNsSDtBQUNBMUQsMEJBQTBCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2N1cmUrYmlwMzlAMS4xLjAvbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9pbmRleC5qcz80ZmVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gZXhwb3J0cy52YWxpZGF0ZU1uZW1vbmljID0gZXhwb3J0cy5lbnRyb3B5VG9NbmVtb25pYyA9IGV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBleHBvcnRzLmdlbmVyYXRlTW5lbW9uaWMgPSB2b2lkIDA7XG4vKiEgc2N1cmUtYmlwMzkgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgX2Fzc2VydF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKTtcbmNvbnN0IHBia2RmMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCBzaGE1MTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbi8vIEphcGFuZXNlIHdvcmRsaXN0XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG4vLyBOb3JtYWxpemF0aW9uIHJlcGxhY2VzIGVxdWl2YWxlbnQgc2VxdWVuY2VzIG9mIGNoYXJhY3RlcnNcbi8vIHNvIHRoYXQgYW55IHR3byB0ZXh0cyB0aGF0IGFyZSBlcXVpdmFsZW50IHdpbGwgYmUgcmVkdWNlZFxuLy8gdG8gdGhlIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMsIGNhbGxlZCB0aGUgbm9ybWFsIGZvcm0gb2YgdGhlIG9yaWdpbmFsIHRleHQuXG5mdW5jdGlvbiBuZmtkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICBjb25zdCBub3JtID0gbmZrZChzdHIpO1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybS5zcGxpdCgnICcpO1xuICAgIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMod29yZHMubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1uZW1vbmljJyk7XG4gICAgcmV0dXJuIHsgbmZrZDogbm9ybSwgd29yZHMgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudHJvcHkoZW50cm9weSkge1xuICAgIF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzKGVudHJvcHksIDE2LCAyMCwgMjQsIDI4LCAzMik7XG59XG4vKipcbiAqIEdlbmVyYXRlIHggcmFuZG9tIHdvcmRzLiBVc2VzIENyeXB0b2dyYXBoaWNhbGx5LVNlY3VyZSBSYW5kb20gTnVtYmVyIEdlbmVyYXRvci5cbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEBwYXJhbSBzdHJlbmd0aCBtbmVtb25pYyBzdHJlbmd0aCAxMjgtMjU2IGJpdHNcbiAqIEBleGFtcGxlXG4gKiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCAxMjgpXG4gKiAvLyAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93J1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIF9hc3NlcnRfMS5kZWZhdWx0Lm51bWJlcihzdHJlbmd0aCk7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDAgfHwgc3RyZW5ndGggPiAyNTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZW50cm9weScpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYygoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1uZW1vbmljID0gZ2VuZXJhdGVNbmVtb25pYztcbmNvbnN0IGNhbGNDaGVja3N1bSA9IChlbnRyb3B5KSA9PiB7XG4gICAgLy8gQ2hlY2tzdW0gaXMgZW50Lmxlbmd0aC80IGJpdHMgbG9uZ1xuICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICAvLyBaZXJvIHJpZ2h0bW9zdCBcImJpdHNMZWZ0XCIgYml0cyBpbiBieXRlXG4gICAgLy8gRm9yIGV4YW1wbGU6IGJpdHNMZWZ0PTQgdmFsPTEwMTExMTAxIC0+IDEwMTEwMDAwXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsoKDAsIHNoYTI1Nl8xLnNoYTI1NikoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMiAqKiAxMSB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5ncycpO1xuICAgIHdvcmRsaXN0LmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29yZGxpc3Q6IG5vbi1zdHJpbmcgZWxlbWVudDogJHtpfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlXzEudXRpbHMuY2hhaW4oYmFzZV8xLnV0aWxzLmNoZWNrc3VtKDEsIGNhbGNDaGVja3N1bSksIGJhc2VfMS51dGlscy5yYWRpeDIoMTEsIHRydWUpLCBiYXNlXzEudXRpbHMuYWxwaGFiZXQod29yZGxpc3QpKTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgbW5lbW9uaWMgc3RyaW5nIHRvIHJhdyBlbnRyb3B5IGluIGZvcm0gb2YgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHdvcmRsaXN0IGltcG9ydGVkIHdvcmRsaXN0IGZvciBzcGVjaWZpYyBsYW5ndWFnZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9FbnRyb3B5KG1uZW0sIHdvcmRsaXN0KVxuICogLy8gUHJvZHVjZXNcbiAqIG5ldyBVaW50OEFycmF5KFtcbiAqICAgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZixcbiAqICAgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZlxuICogXSlcbiAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gbm9ybWFsaXplKG1uZW1vbmljKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Q29kZXIod29yZGxpc3QpLmRlY29kZSh3b3Jkcyk7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbmV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weTtcbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhc3NlcnRFbnRyb3B5KGVudHJvcHkpO1xuICAgIGNvbnN0IHdvcmRzID0gZ2V0Q29kZXIod29yZGxpc3QpLmVuY29kZShlbnRyb3B5KTtcbiAgICByZXR1cm4gd29yZHMuam9pbihpc0phcGFuZXNlKHdvcmRsaXN0KSA/ICdcXHUzMDAwJyA6ICcgJyk7XG59XG5leHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG4vKipcbiAqIFZhbGlkYXRlcyBtbmVtb25pYyBmb3IgYmVpbmcgMTItMjQgd29yZHMgY29udGFpbmVkIGluIGB3b3JkbGlzdGAuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNbmVtb25pYyA9IHZhbGlkYXRlTW5lbW9uaWM7XG5jb25zdCBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoYG1uZW1vbmljJHtwYXNzcGhyYXNlfWApO1xuLyoqXG4gKiBJcnJldmVyc2libGU6IFVzZXMgS0RGIHRvIGRlcml2ZSA2NCBieXRlcyBvZiBrZXkgZGF0YSBmcm9tIG1uZW1vbmljICsgb3B0aW9uYWwgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSBwYXNzcGhyYXNlIHN0cmluZyB0aGF0IHdpbGwgYWRkaXRpb25hbGx5IHByb3RlY3QgdGhlIGtleVxuICogQHJldHVybnMgNjQgYnl0ZXMgb2Yga2V5IGRhdGFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBhd2FpdCBtbmVtb25pY1RvU2VlZChtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gKDAsIHBia2RmMl8xLnBia2RmMkFzeW5jKShzaGE1MTJfMS5zaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbW5lbW9uaWNUb1NlZWQ7XG4vKipcbiAqIElycmV2ZXJzaWJsZTogVXNlcyBLREYgdG8gZGVyaXZlIDY0IGJ5dGVzIG9mIGtleSBkYXRhIGZyb20gbW5lbW9uaWMgKyBvcHRpb25hbCBwYXNzd29yZC5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHBhc3NwaHJhc2Ugc3RyaW5nIHRoYXQgd2lsbCBhZGRpdGlvbmFsbHkgcHJvdGVjdCB0aGUga2V5XG4gKiBAcmV0dXJucyA2NCBieXRlcyBvZiBrZXkgZGF0YVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuICgwLCBwYmtkZjJfMS5wYmtkZjIpKHNoYTUxMl8xLnNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbmV4cG9ydHMubW5lbW9uaWNUb1NlZWRTeW5jID0gbW5lbW9uaWNUb1NlZWRTeW5jO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW5lbW9uaWNUb1NlZWRTeW5jIiwibW5lbW9uaWNUb1NlZWQiLCJ2YWxpZGF0ZU1uZW1vbmljIiwiZW50cm9weVRvTW5lbW9uaWMiLCJtbmVtb25pY1RvRW50cm9weSIsImdlbmVyYXRlTW5lbW9uaWMiLCJfYXNzZXJ0XzEiLCJyZXF1aXJlIiwicGJrZGYyXzEiLCJzaGEyNTZfMSIsInNoYTUxMl8xIiwidXRpbHNfMSIsImJhc2VfMSIsImlzSmFwYW5lc2UiLCJ3b3JkbGlzdCIsIm5ma2QiLCJzdHIiLCJUeXBlRXJyb3IiLCJub3JtYWxpemUiLCJub3JtIiwid29yZHMiLCJzcGxpdCIsImluY2x1ZGVzIiwibGVuZ3RoIiwiRXJyb3IiLCJhc3NlcnRFbnRyb3B5IiwiZW50cm9weSIsImRlZmF1bHQiLCJieXRlcyIsInN0cmVuZ3RoIiwibnVtYmVyIiwicmFuZG9tQnl0ZXMiLCJjYWxjQ2hlY2tzdW0iLCJiaXRzTGVmdCIsIlVpbnQ4QXJyYXkiLCJzaGEyNTYiLCJnZXRDb2RlciIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJpIiwidXRpbHMiLCJjaGFpbiIsImNoZWNrc3VtIiwicmFkaXgyIiwiYWxwaGFiZXQiLCJtbmVtb25pYyIsImRlY29kZSIsImVuY29kZSIsImpvaW4iLCJlIiwic2FsdCIsInBhc3NwaHJhc2UiLCJwYmtkZjJBc3luYyIsInNoYTUxMiIsImMiLCJka0xlbiIsInBia2RmMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@scure+bip39@1.1.0/node_modules/@scure/bip39/index.js\n");

/***/ })

};
;