"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-strings@2.0.0-rc.1_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.8.3";
exports.ids = ["vendor-chunks/@solana+codecs-strings@2.0.0-rc.1_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-strings@2.0.0-rc.1_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.8.3/node_modules/@solana/codecs-strings/dist/index.node.cjs":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-strings@2.0.0-rc.1_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.8.3/node_modules/@solana/codecs-strings/dist/index.node.cjs ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar errors = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/errors/dist/index.node.cjs\");\nvar codecsCore = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.cjs\");\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet4,\n            base: alphabet4.length,\n            value: givenValue\n        });\n    }\n}\nvar getBaseXEncoder = (alphabet4)=>{\n    return codecsCore.createEncoder({\n        getSizeFromValue: (value)=>{\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) return value.length;\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write (value, bytes, offset) {\n            assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            const tailBytes = [];\n            while(base10Number > 0n){\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            const bytesToAdd = [\n                ...Array(leadingZeroes.length).fill(0),\n                ...tailBytes\n            ];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar getBaseXDecoder = (alphabet4)=>{\n    return codecsCore.createDecoder({\n        read (rawBytes, offset) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                0\n            ];\n            let trailIndex = bytes.findIndex((n)=>n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet4[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [\n                leadingZeroes,\n                rawBytes.length\n            ];\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte)=>sum * 256n + BigInt(byte), 0n);\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n            return [\n                leadingZeroes + tailChars,\n                rawBytes.length\n            ];\n        }\n    });\n};\nvar getBaseXCodec = (alphabet4)=>codecsCore.combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [\n        leadingZeros,\n        tailChars\n    ];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    let sum = 0n;\n    for (const char of value){\n        sum *= base;\n        sum += BigInt(alphabet4.indexOf(char));\n    }\n    return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    const tailChars = [];\n    while(value > 0n){\n        tailChars.unshift(alphabet4[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join(\"\");\n}\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = ()=>getBaseXEncoder(alphabet);\nvar getBase10Decoder = ()=>getBaseXDecoder(alphabet);\nvar getBase10Codec = ()=>getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: \"0123456789abcdef\",\n    base: 16\n};\nfunction charCodeToBase16(char) {\n    if (char >= 48 /* ZERO */  && char <= 57 /* NINE */ ) return char - 48 /* ZERO */ ;\n    if (char >= 65 /* A_UP */  && char <= 70 /* F_UP */ ) return char - (65 /* A_UP */  - 10);\n    if (char >= 97 /* A_LO */  && char <= 102 /* F_LO */ ) return char - (97 /* A_LO */  - 10);\n}\nvar getBase16Encoder = ()=>codecsCore.createEncoder({\n        getSizeFromValue: (value)=>Math.ceil(value.length / 2),\n        write (value, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === void 0) {\n                    throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value\n                    });\n                }\n                bytes.set([\n                    n\n                ], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for(let i = 0, j = 0; i < al; i++){\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n                    throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n            }\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        }\n    });\nvar getBase16Decoder = ()=>codecsCore.createDecoder({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nvar getBase16Codec = ()=>codecsCore.combineCodec(getBase16Encoder(), getBase16Decoder());\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = ()=>getBaseXEncoder(alphabet2);\nvar getBase58Decoder = ()=>getBaseXDecoder(alphabet2);\nvar getBase58Codec = ()=>getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits)=>codecsCore.createEncoder({\n        getSizeFromValue: (value)=>Math.floor(value.length * bits / 8),\n        write (value, bytes, offset) {\n            assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const charIndices = [\n                ...value\n            ].map((c)=>alphabet4.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        }\n    });\nvar getBaseXResliceDecoder = (alphabet4, bits)=>codecsCore.createDecoder({\n        read (rawBytes, offset = 0) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                rawBytes.length\n            ];\n            const charIndices = reslice([\n                ...bytes\n            ], 8, bits, true);\n            return [\n                charIndices.map((i)=>alphabet4[i]).join(\"\"),\n                rawBytes.length\n            ];\n        }\n    });\nvar getBaseXResliceCodec = (alphabet4, bits)=>codecsCore.combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input){\n        accumulator = accumulator << inputBits | value;\n        bitsInAccumulator += inputBits;\n        while(bitsInAccumulator >= outputBits){\n            bitsInAccumulator -= outputBits;\n            output.push(accumulator >> bitsInAccumulator & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push(accumulator << outputBits - bitsInAccumulator & mask);\n    }\n    return output;\n}\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = ()=>{\n    {\n        return codecsCore.createEncoder({\n            getSizeFromValue: (value)=>Buffer.from(value, \"base64\").length,\n            write (value, bytes, offset) {\n                assertValidBaseString(alphabet3, value.replace(/=/g, \"\"));\n                const buffer = Buffer.from(value, \"base64\");\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            }\n        });\n    }\n};\nvar getBase64Decoder = ()=>{\n    {\n        return codecsCore.createDecoder({\n            read: (bytes, offset = 0)=>[\n                    Buffer.from(bytes, offset).toString(\"base64\"),\n                    bytes.length\n                ]\n        });\n    }\n};\nvar getBase64Codec = ()=>codecsCore.combineCodec(getBase64Encoder(), getBase64Decoder());\n// src/null-characters.ts\nvar removeNullCharacters = (value)=>// eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars)=>value.padEnd(chars, \"\\x00\");\n// ../text-encoding-impl/dist/index.node.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n// src/utf8.ts\nvar getUtf8Encoder = ()=>{\n    let textEncoder;\n    return codecsCore.createEncoder({\n        getSizeFromValue: (value)=>(textEncoder ||= new o()).encode(value).length,\n        write: (value, bytes, offset)=>{\n            const bytesToAdd = (textEncoder ||= new o()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar getUtf8Decoder = ()=>{\n    let textDecoder;\n    return codecsCore.createDecoder({\n        read (bytes, offset) {\n            const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n            return [\n                removeNullCharacters(value),\n                bytes.length\n            ];\n        }\n    });\n};\nvar getUtf8Codec = ()=>codecsCore.combineCodec(getUtf8Encoder(), getUtf8Decoder());\nexports.assertValidBaseString = assertValidBaseString;\nexports.getBase10Codec = getBase10Codec;\nexports.getBase10Decoder = getBase10Decoder;\nexports.getBase10Encoder = getBase10Encoder;\nexports.getBase16Codec = getBase16Codec;\nexports.getBase16Decoder = getBase16Decoder;\nexports.getBase16Encoder = getBase16Encoder;\nexports.getBase58Codec = getBase58Codec;\nexports.getBase58Decoder = getBase58Decoder;\nexports.getBase58Encoder = getBase58Encoder;\nexports.getBase64Codec = getBase64Codec;\nexports.getBase64Decoder = getBase64Decoder;\nexports.getBase64Encoder = getBase64Encoder;\nexports.getBaseXCodec = getBaseXCodec;\nexports.getBaseXDecoder = getBaseXDecoder;\nexports.getBaseXEncoder = getBaseXEncoder;\nexports.getBaseXResliceCodec = getBaseXResliceCodec;\nexports.getBaseXResliceDecoder = getBaseXResliceDecoder;\nexports.getBaseXResliceEncoder = getBaseXResliceEncoder;\nexports.getUtf8Codec = getUtf8Codec;\nexports.getUtf8Decoder = getUtf8Decoder;\nexports.getUtf8Encoder = getUtf8Encoder;\nexports.padNullCharacters = padNullCharacters;\nexports.removeNullCharacters = removeNullCharacters; //# sourceMappingURL=index.node.cjs.map\n //# sourceMappingURL=index.node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3Mtc3RyaW5nc0AyLjAuMC1yYy4xX2Zhc3Rlc3RzbWFsbGVzdHRleHRlbmNvZGVyZGVjb2RlckAxLjAuMjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3Mtc3RyaW5ncy9kaXN0L2luZGV4Lm5vZGUuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUM7QUFFekIsb0JBQW9CO0FBQ3BCLFNBQVNFLHNCQUFzQkMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLGFBQWFELFNBQVM7SUFDekUsSUFBSSxDQUFDQSxVQUFVRSxLQUFLLENBQUMsSUFBSUMsT0FBTyxDQUFDLEVBQUUsRUFBRUosVUFBVSxHQUFHLENBQUMsSUFBSTtRQUNyRCxNQUFNLElBQUlKLE9BQU9TLFdBQVcsQ0FBQ1QsT0FBT1UsNkNBQTZDLEVBQUU7WUFDakZDLFVBQVVQO1lBQ1ZRLE1BQU1SLFVBQVVTLE1BQU07WUFDdEJDLE9BQU9SO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsSUFBSVMsa0JBQWtCLENBQUNYO0lBQ3JCLE9BQU9GLFdBQVdjLGFBQWEsQ0FBQztRQUM5QkMsa0JBQWtCLENBQUNIO1lBQ2pCLE1BQU0sQ0FBQ0ksZUFBZUMsVUFBVSxHQUFHQyx1QkFBdUJOLE9BQU9WLFNBQVMsQ0FBQyxFQUFFO1lBQzdFLElBQUksQ0FBQ2UsV0FBVyxPQUFPTCxNQUFNRCxNQUFNO1lBQ25DLE1BQU1RLGVBQWVDLG1CQUFtQkgsV0FBV2Y7WUFDbkQsT0FBT2MsY0FBY0wsTUFBTSxHQUFHVSxLQUFLQyxJQUFJLENBQUNILGFBQWFJLFFBQVEsQ0FBQyxJQUFJWixNQUFNLEdBQUc7UUFDN0U7UUFDQWEsT0FBTVosS0FBSyxFQUFFYSxLQUFLLEVBQUVDLE1BQU07WUFDeEJ6QixzQkFBc0JDLFdBQVdVO1lBQ2pDLElBQUlBLFVB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LE9BQU87Z0JBQUNtRixxQkFBcUJqRztnQkFBUWEsTUFBTWQsTUFBTTthQUFDO1FBQ3BEO0lBQ0Y7QUFDRjtBQUNBLElBQUlpSCxlQUFlLElBQU01SCxXQUFXa0QsWUFBWSxDQUFDb0Usa0JBQWtCRztBQUVuRUksNkJBQTZCLEdBQUc1SDtBQUNoQzRILHNCQUFzQixHQUFHbEU7QUFDekJrRSx3QkFBd0IsR0FBR25FO0FBQzNCbUUsd0JBQXdCLEdBQUdwRTtBQUMzQm9FLHNCQUFzQixHQUFHL0M7QUFDekIrQyx3QkFBd0IsR0FBR2xEO0FBQzNCa0Qsd0JBQXdCLEdBQUcvRDtBQUMzQitELHNCQUFzQixHQUFHM0M7QUFDekIyQyx3QkFBd0IsR0FBRzVDO0FBQzNCNEMsd0JBQXdCLEdBQUc3QztBQUMzQjZDLHNCQUFzQixHQUFHakI7QUFDekJpQix3QkFBd0IsR0FBR2xCO0FBQzNCa0Isd0JBQXdCLEdBQUd2QjtBQUMzQnVCLHFCQUFxQixHQUFHNUU7QUFDeEI0RSx1QkFBdUIsR0FBRzFGO0FBQzFCMEYsdUJBQXVCLEdBQUdoSDtBQUMxQmdILDRCQUE0QixHQUFHbEM7QUFDL0JrQyw4QkFBOEIsR0FBR25DO0FBQ2pDbUMsOEJBQThCLEdBQUcxQztBQUNqQzBDLG9CQUFvQixHQUFHRDtBQUN2QkMsc0JBQXNCLEdBQUdKO0FBQ3pCSSxzQkFBc0IsR0FBR1A7QUFDekJPLHlCQUF5QixHQUFHZjtBQUM1QmUsNEJBQTRCLEdBQUdoQixzQkFDL0IsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3Mtc3RyaW5nc0AyLjAuMC1yYy4xX2Zhc3Rlc3RzbWFsbGVzdHRleHRlbmNvZGVyZGVjb2RlckAxLjAuMjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3Mtc3RyaW5ncy9kaXN0L2luZGV4Lm5vZGUuY2pzPzU2YWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnQHNvbGFuYS9lcnJvcnMnKTtcbnZhciBjb2RlY3NDb3JlID0gcmVxdWlyZSgnQHNvbGFuYS9jb2RlY3MtY29yZScpO1xuXG4vLyBzcmMvYXNzZXJ0aW9ucy50c1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRCYXNlU3RyaW5nKGFscGhhYmV0NCwgdGVzdFZhbHVlLCBnaXZlblZhbHVlID0gdGVzdFZhbHVlKSB7XG4gIGlmICghdGVzdFZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF5bJHthbHBoYWJldDR9XSokYCkpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFLCB7XG4gICAgICBhbHBoYWJldDogYWxwaGFiZXQ0LFxuICAgICAgYmFzZTogYWxwaGFiZXQ0Lmxlbmd0aCxcbiAgICAgIHZhbHVlOiBnaXZlblZhbHVlXG4gICAgfSk7XG4gIH1cbn1cbnZhciBnZXRCYXNlWEVuY29kZXIgPSAoYWxwaGFiZXQ0KSA9PiB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgW2xlYWRpbmdaZXJvZXMsIHRhaWxDaGFyc10gPSBwYXJ0aXRpb25MZWFkaW5nWmVyb2VzKHZhbHVlLCBhbHBoYWJldDRbMF0pO1xuICAgICAgaWYgKCF0YWlsQ2hhcnMpIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICBjb25zdCBiYXNlMTBOdW1iZXIgPSBnZXRCaWdJbnRGcm9tQmFzZVgodGFpbENoYXJzLCBhbHBoYWJldDQpO1xuICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvZXMubGVuZ3RoICsgTWF0aC5jZWlsKGJhc2UxME51bWJlci50b1N0cmluZygxNikubGVuZ3RoIC8gMik7XG4gICAgfSxcbiAgICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgICAgYXNzZXJ0VmFsaWRCYXNlU3RyaW5nKGFscGhhYmV0NCwgdmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSByZXR1cm4gb2Zmc2V0O1xuICAgICAgY29uc3QgW2xlYWRpbmdaZXJvZXMsIHRhaWxDaGFyc10gPSBwYXJ0aXRpb25MZWFkaW5nWmVyb2VzKHZhbHVlLCBhbHBoYWJldDRbMF0pO1xuICAgICAgaWYgKCF0YWlsQ2hhcnMpIHtcbiAgICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGxlYWRpbmdaZXJvZXMubGVuZ3RoKS5maWxsKDApLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbGVhZGluZ1plcm9lcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBsZXQgYmFzZTEwTnVtYmVyID0gZ2V0QmlnSW50RnJvbUJhc2VYKHRhaWxDaGFycywgYWxwaGFiZXQ0KTtcbiAgICAgIGNvbnN0IHRhaWxCeXRlcyA9IFtdO1xuICAgICAgd2hpbGUgKGJhc2UxME51bWJlciA+IDBuKSB7XG4gICAgICAgIHRhaWxCeXRlcy51bnNoaWZ0KE51bWJlcihiYXNlMTBOdW1iZXIgJSAyNTZuKSk7XG4gICAgICAgIGJhc2UxME51bWJlciAvPSAyNTZuO1xuICAgICAgfVxuICAgICAgY29uc3QgYnl0ZXNUb0FkZCA9IFsuLi5BcnJheShsZWFkaW5nWmVyb2VzLmxlbmd0aCkuZmlsbCgwKSwgLi4udGFpbEJ5dGVzXTtcbiAgICAgIGJ5dGVzLnNldChieXRlc1RvQWRkLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVzVG9BZGQubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIGdldEJhc2VYRGVjb2RlciA9IChhbHBoYWJldDQpID0+IHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRGVjb2Rlcih7XG4gICAgcmVhZChyYXdCeXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb25zdCBieXRlcyA9IG9mZnNldCA9PT0gMCA/IHJhd0J5dGVzIDogcmF3Qnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHJldHVybiBbXCJcIiwgMF07XG4gICAgICBsZXQgdHJhaWxJbmRleCA9IGJ5dGVzLmZpbmRJbmRleCgobikgPT4gbiAhPT0gMCk7XG4gICAgICB0cmFpbEluZGV4ID0gdHJhaWxJbmRleCA9PT0gLTEgPyBieXRlcy5sZW5ndGggOiB0cmFpbEluZGV4O1xuICAgICAgY29uc3QgbGVhZGluZ1plcm9lcyA9IGFscGhhYmV0NFswXS5yZXBlYXQodHJhaWxJbmRleCk7XG4gICAgICBpZiAodHJhaWxJbmRleCA9PT0gYnl0ZXMubGVuZ3RoKSByZXR1cm4gW2xlYWRpbmdaZXJvZXMsIHJhd0J5dGVzLmxlbmd0aF07XG4gICAgICBjb25zdCBiYXNlMTBOdW1iZXIgPSBieXRlcy5zbGljZSh0cmFpbEluZGV4KS5yZWR1Y2UoKHN1bSwgYnl0ZSkgPT4gc3VtICogMjU2biArIEJpZ0ludChieXRlKSwgMG4pO1xuICAgICAgY29uc3QgdGFpbENoYXJzID0gZ2V0QmFzZVhGcm9tQmlnSW50KGJhc2UxME51bWJlciwgYWxwaGFiZXQ0KTtcbiAgICAgIHJldHVybiBbbGVhZGluZ1plcm9lcyArIHRhaWxDaGFycywgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBnZXRCYXNlWENvZGVjID0gKGFscGhhYmV0NCkgPT4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0QmFzZVhFbmNvZGVyKGFscGhhYmV0NCksIGdldEJhc2VYRGVjb2RlcihhbHBoYWJldDQpKTtcbmZ1bmN0aW9uIHBhcnRpdGlvbkxlYWRpbmdaZXJvZXModmFsdWUsIHplcm9DaGFyYWN0ZXIpIHtcbiAgY29uc3QgW2xlYWRpbmdaZXJvcywgdGFpbENoYXJzXSA9IHZhbHVlLnNwbGl0KG5ldyBSZWdFeHAoYCgoPyEke3plcm9DaGFyYWN0ZXJ9KS4qKWApKTtcbiAgcmV0dXJuIFtsZWFkaW5nWmVyb3MsIHRhaWxDaGFyc107XG59XG5mdW5jdGlvbiBnZXRCaWdJbnRGcm9tQmFzZVgodmFsdWUsIGFscGhhYmV0NCkge1xuICBjb25zdCBiYXNlID0gQmlnSW50KGFscGhhYmV0NC5sZW5ndGgpO1xuICBsZXQgc3VtID0gMG47XG4gIGZvciAoY29uc3QgY2hhciBvZiB2YWx1ZSkge1xuICAgIHN1bSAqPSBiYXNlO1xuICAgIHN1bSArPSBCaWdJbnQoYWxwaGFiZXQ0LmluZGV4T2YoY2hhcikpO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiBnZXRCYXNlWEZyb21CaWdJbnQodmFsdWUsIGFscGhhYmV0NCkge1xuICBjb25zdCBiYXNlID0gQmlnSW50KGFscGhhYmV0NC5sZW5ndGgpO1xuICBjb25zdCB0YWlsQ2hhcnMgPSBbXTtcbiAgd2hpbGUgKHZhbHVlID4gMG4pIHtcbiAgICB0YWlsQ2hhcnMudW5zaGlmdChhbHBoYWJldDRbTnVtYmVyKHZhbHVlICUgYmFzZSldKTtcbiAgICB2YWx1ZSAvPSBiYXNlO1xuICB9XG4gIHJldHVybiB0YWlsQ2hhcnMuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2Jhc2UxMC50c1xudmFyIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5XCI7XG52YXIgZ2V0QmFzZTEwRW5jb2RlciA9ICgpID0+IGdldEJhc2VYRW5jb2RlcihhbHBoYWJldCk7XG52YXIgZ2V0QmFzZTEwRGVjb2RlciA9ICgpID0+IGdldEJhc2VYRGVjb2RlcihhbHBoYWJldCk7XG52YXIgZ2V0QmFzZTEwQ29kZWMgPSAoKSA9PiBnZXRCYXNlWENvZGVjKGFscGhhYmV0KTtcbnZhciBJTlZBTElEX1NUUklOR19FUlJPUl9CQVNFX0NPTkZJRyA9IHtcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLFxuICBiYXNlOiAxNlxufTtcbmZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYoY2hhcikge1xuICBpZiAoY2hhciA+PSA0OCAvKiBaRVJPICovICYmIGNoYXIgPD0gNTcgLyogTklORSAqLykgcmV0dXJuIGNoYXIgLSA0OCAvKiBaRVJPICovO1xuICBpZiAoY2hhciA+PSA2NSAvKiBBX1VQICovICYmIGNoYXIgPD0gNzAgLyogRl9VUCAqLykgcmV0dXJuIGNoYXIgLSAoNjUgLyogQV9VUCAqLyAtIDEwKTtcbiAgaWYgKGNoYXIgPj0gOTcgLyogQV9MTyAqLyAmJiBjaGFyIDw9IDEwMiAvKiBGX0xPICovKSByZXR1cm4gY2hhciAtICg5NyAvKiBBX0xPICovIC0gMTApO1xufVxudmFyIGdldEJhc2UxNkVuY29kZXIgPSAoKSA9PiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAyKSxcbiAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBsZW4gLyAyO1xuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIGNvbnN0IGMgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgY29uc3QgbiA9IGNoYXJDb2RlVG9CYXNlMTYoYyk7XG4gICAgICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSwge1xuICAgICAgICAgIC4uLklOVkFMSURfU1RSSU5HX0VSUk9SX0JBU0VfQ09ORklHLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnl0ZXMuc2V0KFtuXSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiAxICsgb2Zmc2V0O1xuICAgIH1cbiAgICBjb25zdCBoZXhCeXRlcyA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBhbDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaisrKTtcbiAgICAgIGNvbnN0IGMyID0gdmFsdWUuY2hhckNvZGVBdChqKyspO1xuICAgICAgY29uc3QgbjEgPSBjaGFyQ29kZVRvQmFzZTE2KGMxKTtcbiAgICAgIGNvbnN0IG4yID0gY2hhckNvZGVUb0Jhc2UxNihjMik7XG4gICAgICBpZiAobjEgPT09IHZvaWQgMCB8fCBuMiA9PT0gdm9pZCAwICYmICFOdW1iZXIuaXNOYU4oYzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSwge1xuICAgICAgICAgIC4uLklOVkFMSURfU1RSSU5HX0VSUk9SX0JBU0VfQ09ORklHLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaGV4Qnl0ZXNbaV0gPSAhTnVtYmVyLmlzTmFOKGMyKSA/IG4xIDw8IDQgfCAobjIgPz8gMCkgOiBuMTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGhleEJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBoZXhCeXRlcy5sZW5ndGggKyBvZmZzZXQ7XG4gIH1cbn0pO1xudmFyIGdldEJhc2UxNkRlY29kZXIgPSAoKSA9PiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICByZWFkKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzLnNsaWNlKG9mZnNldCkucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG4gICAgcmV0dXJuIFt2YWx1ZSwgYnl0ZXMubGVuZ3RoXTtcbiAgfVxufSk7XG52YXIgZ2V0QmFzZTE2Q29kZWMgPSAoKSA9PiBjb2RlY3NDb3JlLmNvbWJpbmVDb2RlYyhnZXRCYXNlMTZFbmNvZGVyKCksIGdldEJhc2UxNkRlY29kZXIoKSk7XG5cbi8vIHNyYy9iYXNlNTgudHNcbnZhciBhbHBoYWJldDIgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBnZXRCYXNlNThFbmNvZGVyID0gKCkgPT4gZ2V0QmFzZVhFbmNvZGVyKGFscGhhYmV0Mik7XG52YXIgZ2V0QmFzZTU4RGVjb2RlciA9ICgpID0+IGdldEJhc2VYRGVjb2RlcihhbHBoYWJldDIpO1xudmFyIGdldEJhc2U1OENvZGVjID0gKCkgPT4gZ2V0QmFzZVhDb2RlYyhhbHBoYWJldDIpO1xudmFyIGdldEJhc2VYUmVzbGljZUVuY29kZXIgPSAoYWxwaGFiZXQ0LCBiaXRzKSA9PiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoICogYml0cyAvIDgpLFxuICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgIGFzc2VydFZhbGlkQmFzZVN0cmluZyhhbHBoYWJldDQsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IFwiXCIpIHJldHVybiBvZmZzZXQ7XG4gICAgY29uc3QgY2hhckluZGljZXMgPSBbLi4udmFsdWVdLm1hcCgoYykgPT4gYWxwaGFiZXQ0LmluZGV4T2YoYykpO1xuICAgIGNvbnN0IHJlc2xpY2VkQnl0ZXMgPSByZXNsaWNlKGNoYXJJbmRpY2VzLCBiaXRzLCA4LCBmYWxzZSk7XG4gICAgYnl0ZXMuc2V0KHJlc2xpY2VkQnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJlc2xpY2VkQnl0ZXMubGVuZ3RoICsgb2Zmc2V0O1xuICB9XG59KTtcbnZhciBnZXRCYXNlWFJlc2xpY2VEZWNvZGVyID0gKGFscGhhYmV0NCwgYml0cykgPT4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHtcbiAgcmVhZChyYXdCeXRlcywgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGJ5dGVzID0gb2Zmc2V0ID09PSAwID8gcmF3Qnl0ZXMgOiByYXdCeXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHJldHVybiBbXCJcIiwgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgICBjb25zdCBjaGFySW5kaWNlcyA9IHJlc2xpY2UoWy4uLmJ5dGVzXSwgOCwgYml0cywgdHJ1ZSk7XG4gICAgcmV0dXJuIFtjaGFySW5kaWNlcy5tYXAoKGkpID0+IGFscGhhYmV0NFtpXSkuam9pbihcIlwiKSwgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgfVxufSk7XG52YXIgZ2V0QmFzZVhSZXNsaWNlQ29kZWMgPSAoYWxwaGFiZXQ0LCBiaXRzKSA9PiBjb2RlY3NDb3JlLmNvbWJpbmVDb2RlYyhnZXRCYXNlWFJlc2xpY2VFbmNvZGVyKGFscGhhYmV0NCwgYml0cyksIGdldEJhc2VYUmVzbGljZURlY29kZXIoYWxwaGFiZXQ0LCBiaXRzKSk7XG5mdW5jdGlvbiByZXNsaWNlKGlucHV0LCBpbnB1dEJpdHMsIG91dHB1dEJpdHMsIHVzZVJlbWFpbmRlcikge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgbGV0IGFjY3VtdWxhdG9yID0gMDtcbiAgbGV0IGJpdHNJbkFjY3VtdWxhdG9yID0gMDtcbiAgY29uc3QgbWFzayA9ICgxIDw8IG91dHB1dEJpdHMpIC0gMTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBpbnB1dCkge1xuICAgIGFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IgPDwgaW5wdXRCaXRzIHwgdmFsdWU7XG4gICAgYml0c0luQWNjdW11bGF0b3IgKz0gaW5wdXRCaXRzO1xuICAgIHdoaWxlIChiaXRzSW5BY2N1bXVsYXRvciA+PSBvdXRwdXRCaXRzKSB7XG4gICAgICBiaXRzSW5BY2N1bXVsYXRvciAtPSBvdXRwdXRCaXRzO1xuICAgICAgb3V0cHV0LnB1c2goYWNjdW11bGF0b3IgPj4gYml0c0luQWNjdW11bGF0b3IgJiBtYXNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZVJlbWFpbmRlciAmJiBiaXRzSW5BY2N1bXVsYXRvciA+IDApIHtcbiAgICBvdXRwdXQucHVzaChhY2N1bXVsYXRvciA8PCBvdXRwdXRCaXRzIC0gYml0c0luQWNjdW11bGF0b3IgJiBtYXNrKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvYmFzZTY0LnRzXG52YXIgYWxwaGFiZXQzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgZ2V0QmFzZTY0RW5jb2RlciA9ICgpID0+IHtcbiAge1xuICAgIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIikubGVuZ3RoLFxuICAgICAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRCYXNlU3RyaW5nKGFscGhhYmV0MywgdmFsdWUucmVwbGFjZSgvPS9nLCBcIlwiKSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICAgICAgYnl0ZXMuc2V0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5sZW5ndGggKyBvZmZzZXQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgZ2V0QmFzZTY0RGVjb2RlciA9ICgpID0+IHtcbiAge1xuICAgIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICAgICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBbQnVmZmVyLmZyb20oYnl0ZXMsIG9mZnNldCkudG9TdHJpbmcoXCJiYXNlNjRcIiksIGJ5dGVzLmxlbmd0aF1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBnZXRCYXNlNjRDb2RlYyA9ICgpID0+IGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldEJhc2U2NEVuY29kZXIoKSwgZ2V0QmFzZTY0RGVjb2RlcigpKTtcblxuLy8gc3JjL251bGwtY2hhcmFjdGVycy50c1xudmFyIHJlbW92ZU51bGxDaGFyYWN0ZXJzID0gKHZhbHVlKSA9PiAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gIHZhbHVlLnJlcGxhY2UoL1xcdTAwMDAvZywgXCJcIilcbik7XG52YXIgcGFkTnVsbENoYXJhY3RlcnMgPSAodmFsdWUsIGNoYXJzKSA9PiB2YWx1ZS5wYWRFbmQoY2hhcnMsIFwiXFwwXCIpO1xuXG4vLyAuLi90ZXh0LWVuY29kaW5nLWltcGwvZGlzdC9pbmRleC5ub2RlLm1qc1xudmFyIGUgPSBnbG9iYWxUaGlzLlRleHREZWNvZGVyO1xudmFyIG8gPSBnbG9iYWxUaGlzLlRleHRFbmNvZGVyO1xuXG4vLyBzcmMvdXRmOC50c1xudmFyIGdldFV0ZjhFbmNvZGVyID0gKCkgPT4ge1xuICBsZXQgdGV4dEVuY29kZXI7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gKHRleHRFbmNvZGVyIHx8PSBuZXcgbygpKS5lbmNvZGUodmFsdWUpLmxlbmd0aCxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBieXRlc1RvQWRkID0gKHRleHRFbmNvZGVyIHx8PSBuZXcgbygpKS5lbmNvZGUodmFsdWUpO1xuICAgICAgYnl0ZXMuc2V0KGJ5dGVzVG9BZGQsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNUb0FkZC5sZW5ndGg7XG4gICAgfVxuICB9KTtcbn07XG52YXIgZ2V0VXRmOERlY29kZXIgPSAoKSA9PiB7XG4gIGxldCB0ZXh0RGVjb2RlcjtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRGVjb2Rlcih7XG4gICAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICh0ZXh0RGVjb2RlciB8fD0gbmV3IGUoKSkuZGVjb2RlKGJ5dGVzLnNsaWNlKG9mZnNldCkpO1xuICAgICAgcmV0dXJuIFtyZW1vdmVOdWxsQ2hhcmFjdGVycyh2YWx1ZSksIGJ5dGVzLmxlbmd0aF07XG4gICAgfVxuICB9KTtcbn07XG52YXIgZ2V0VXRmOENvZGVjID0gKCkgPT4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0VXRmOEVuY29kZXIoKSwgZ2V0VXRmOERlY29kZXIoKSk7XG5cbmV4cG9ydHMuYXNzZXJ0VmFsaWRCYXNlU3RyaW5nID0gYXNzZXJ0VmFsaWRCYXNlU3RyaW5nO1xuZXhwb3J0cy5nZXRCYXNlMTBDb2RlYyA9IGdldEJhc2UxMENvZGVjO1xuZXhwb3J0cy5nZXRCYXNlMTBEZWNvZGVyID0gZ2V0QmFzZTEwRGVjb2RlcjtcbmV4cG9ydHMuZ2V0QmFzZTEwRW5jb2RlciA9IGdldEJhc2UxMEVuY29kZXI7XG5leHBvcnRzLmdldEJhc2UxNkNvZGVjID0gZ2V0QmFzZTE2Q29kZWM7XG5leHBvcnRzLmdldEJhc2UxNkRlY29kZXIgPSBnZXRCYXNlMTZEZWNvZGVyO1xuZXhwb3J0cy5nZXRCYXNlMTZFbmNvZGVyID0gZ2V0QmFzZTE2RW5jb2RlcjtcbmV4cG9ydHMuZ2V0QmFzZTU4Q29kZWMgPSBnZXRCYXNlNThDb2RlYztcbmV4cG9ydHMuZ2V0QmFzZTU4RGVjb2RlciA9IGdldEJhc2U1OERlY29kZXI7XG5leHBvcnRzLmdldEJhc2U1OEVuY29kZXIgPSBnZXRCYXNlNThFbmNvZGVyO1xuZXhwb3J0cy5nZXRCYXNlNjRDb2RlYyA9IGdldEJhc2U2NENvZGVjO1xuZXhwb3J0cy5nZXRCYXNlNjREZWNvZGVyID0gZ2V0QmFzZTY0RGVjb2RlcjtcbmV4cG9ydHMuZ2V0QmFzZTY0RW5jb2RlciA9IGdldEJhc2U2NEVuY29kZXI7XG5leHBvcnRzLmdldEJhc2VYQ29kZWMgPSBnZXRCYXNlWENvZGVjO1xuZXhwb3J0cy5nZXRCYXNlWERlY29kZXIgPSBnZXRCYXNlWERlY29kZXI7XG5leHBvcnRzLmdldEJhc2VYRW5jb2RlciA9IGdldEJhc2VYRW5jb2RlcjtcbmV4cG9ydHMuZ2V0QmFzZVhSZXNsaWNlQ29kZWMgPSBnZXRCYXNlWFJlc2xpY2VDb2RlYztcbmV4cG9ydHMuZ2V0QmFzZVhSZXNsaWNlRGVjb2RlciA9IGdldEJhc2VYUmVzbGljZURlY29kZXI7XG5leHBvcnRzLmdldEJhc2VYUmVzbGljZUVuY29kZXIgPSBnZXRCYXNlWFJlc2xpY2VFbmNvZGVyO1xuZXhwb3J0cy5nZXRVdGY4Q29kZWMgPSBnZXRVdGY4Q29kZWM7XG5leHBvcnRzLmdldFV0ZjhEZWNvZGVyID0gZ2V0VXRmOERlY29kZXI7XG5leHBvcnRzLmdldFV0ZjhFbmNvZGVyID0gZ2V0VXRmOEVuY29kZXI7XG5leHBvcnRzLnBhZE51bGxDaGFyYWN0ZXJzID0gcGFkTnVsbENoYXJhY3RlcnM7XG5leHBvcnRzLnJlbW92ZU51bGxDaGFyYWN0ZXJzID0gcmVtb3ZlTnVsbENoYXJhY3RlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmNqcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuY2pzLm1hcCJdLCJuYW1lcyI6WyJlcnJvcnMiLCJyZXF1aXJlIiwiY29kZWNzQ29yZSIsImFzc2VydFZhbGlkQmFzZVN0cmluZyIsImFscGhhYmV0NCIsInRlc3RWYWx1ZSIsImdpdmVuVmFsdWUiLCJtYXRjaCIsIlJlZ0V4cCIsIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFIiwiYWxwaGFiZXQiLCJiYXNlIiwibGVuZ3RoIiwidmFsdWUiLCJnZXRCYXNlWEVuY29kZXIiLCJjcmVhdGVFbmNvZGVyIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImxlYWRpbmdaZXJvZXMiLCJ0YWlsQ2hhcnMiLCJwYXJ0aXRpb25MZWFkaW5nWmVyb2VzIiwiYmFzZTEwTnVtYmVyIiwiZ2V0QmlnSW50RnJvbUJhc2VYIiwiTWF0aCIsImNlaWwiLCJ0b1N0cmluZyIsIndyaXRlIiwiYnl0ZXMiLCJvZmZzZXQiLCJzZXQiLCJVaW50OEFycmF5IiwiZmlsbCIsInRhaWxCeXRlcyIsInVuc2hpZnQiLCJOdW1iZXIiLCJieXRlc1RvQWRkIiwiQXJyYXkiLCJnZXRCYXNlWERlY29kZXIiLCJjcmVhdGVEZWNvZGVyIiwicmVhZCIsInJhd0J5dGVzIiwic2xpY2UiLCJ0cmFpbEluZGV4IiwiZmluZEluZGV4IiwibiIsInJlcGVhdCIsInJlZHVjZSIsInN1bSIsImJ5dGUiLCJCaWdJbnQiLCJnZXRCYXNlWEZyb21CaWdJbnQiLCJnZXRCYXNlWENvZGVjIiwiY29tYmluZUNvZGVjIiwiemVyb0NoYXJhY3RlciIsImxlYWRpbmdaZXJvcyIsInNwbGl0IiwiY2hhciIsImluZGV4T2YiLCJqb2luIiwiZ2V0QmFzZTEwRW5jb2RlciIsImdldEJhc2UxMERlY29kZXIiLCJnZXRCYXNlMTBDb2RlYyIsIklOVkFMSURfU1RSSU5HX0VSUk9SX0JBU0VfQ09ORklHIiwiY2hhckNvZGVUb0Jhc2UxNiIsImdldEJhc2UxNkVuY29kZXIiLCJsZW4iLCJhbCIsImMiLCJjaGFyQ29kZUF0IiwiaGV4Qnl0ZXMiLCJpIiwiaiIsImMxIiwiYzIiLCJuMSIsIm4yIiwiaXNOYU4iLCJnZXRCYXNlMTZEZWNvZGVyIiwic3RyIiwicGFkU3RhcnQiLCJnZXRCYXNlMTZDb2RlYyIsImFscGhhYmV0MiIsImdldEJhc2U1OEVuY29kZXIiLCJnZXRCYXNlNThEZWNvZGVyIiwiZ2V0QmFzZTU4Q29kZWMiLCJnZXRCYXNlWFJlc2xpY2VFbmNvZGVyIiwiYml0cyIsImZsb29yIiwiY2hhckluZGljZXMiLCJtYXAiLCJyZXNsaWNlZEJ5dGVzIiwicmVzbGljZSIsImdldEJhc2VYUmVzbGljZURlY29kZXIiLCJnZXRCYXNlWFJlc2xpY2VDb2RlYyIsImlucHV0IiwiaW5wdXRCaXRzIiwib3V0cHV0Qml0cyIsInVzZVJlbWFpbmRlciIsIm91dHB1dCIsImFjY3VtdWxhdG9yIiwiYml0c0luQWNjdW11bGF0b3IiLCJtYXNrIiwicHVzaCIsImFscGhhYmV0MyIsImdldEJhc2U2NEVuY29kZXIiLCJCdWZmZXIiLCJmcm9tIiwicmVwbGFjZSIsImJ1ZmZlciIsImdldEJhc2U2NERlY29kZXIiLCJnZXRCYXNlNjRDb2RlYyIsInJlbW92ZU51bGxDaGFyYWN0ZXJzIiwicGFkTnVsbENoYXJhY3RlcnMiLCJjaGFycyIsInBhZEVuZCIsImUiLCJnbG9iYWxUaGlzIiwiVGV4dERlY29kZXIiLCJvIiwiVGV4dEVuY29kZXIiLCJnZXRVdGY4RW5jb2RlciIsInRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZ2V0VXRmOERlY29kZXIiLCJ0ZXh0RGVjb2RlciIsImRlY29kZSIsImdldFV0ZjhDb2RlYyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-strings@2.0.0-rc.1_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.8.3/node_modules/@solana/codecs-strings/dist/index.node.cjs\n");

/***/ })

};
;