"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp@0.0.33";
exports.ids = ["vendor-chunks/tmp@0.0.33"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/tmp@0.0.33/node_modules/tmp/lib/tmp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/.pnpm/tmp@0.0.33/node_modules/tmp/lib/tmp.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */ /*\n * Module dependencies.\n */ \nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst osTmpDir = __webpack_require__(/*! os-tmpdir */ \"(ssr)/./node_modules/.pnpm/os-tmpdir@1.0.2/node_modules/os-tmpdir/index.js\");\nconst _c = process.binding(\"constants\");\n/*\n * The working inner variables.\n */ const /**\n   * The temporary directory.\n   * @type {string}\n   */ tmpDir = osTmpDir(), // the random characters to choose from\nRANDOM_CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448 /* 0o700 */ , FILE_MODE = 384 /* 0o600 */ , // this will hold the objects need to be removed on exit\n_removeObjects = [];\nvar _gracefulCleanup = false, _uncaughtException = false;\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */ function _randomChars(howMany) {\n    var value = [], rnd = null;\n    // make sure that we do not fail because we ran out of entropy\n    try {\n        rnd = crypto.randomBytes(howMany);\n    } catch (e) {\n        rnd = crypto.pseudoRandomBytes(howMany);\n    }\n    for(var i = 0; i < howMany; i++){\n        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n    }\n    return value.join(\"\");\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */ function _isUndefined(obj) {\n    return typeof obj === \"undefined\";\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */ function _parseArguments(options, callback) {\n    if (typeof options == \"function\") {\n        return [\n            callback || {},\n            options\n        ];\n    }\n    if (_isUndefined(options)) {\n        return [\n            {},\n            callback\n        ];\n    }\n    return [\n        options,\n        callback\n    ];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */ function _generateTmpName(opts) {\n    if (opts.name) {\n        return path.join(opts.dir || tmpDir, opts.name);\n    }\n    // mkstemps like template\n    if (opts.template) {\n        return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n    }\n    // prefix and postfix\n    const name = [\n        opts.prefix || \"tmp-\",\n        process.pid,\n        _randomChars(12),\n        opts.postfix || \"\"\n    ].join(\"\");\n    return path.join(opts.dir || tmpDir, name);\n}\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */ function tmpName(options, callback) {\n    var args = _parseArguments(options, callback), opts = args[0], cb = args[1], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n    if (isNaN(tries) || tries < 0) return cb(new Error(\"Invalid tries\"));\n    if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error(\"Invalid template provided\"));\n    (function _getUniqueName() {\n        const name = _generateTmpName(opts);\n        // check whether the path exists then retry if needed\n        fs.stat(name, function(err) {\n            if (!err) {\n                if (tries-- > 0) return _getUniqueName();\n                return cb(new Error(\"Could not get a unique tmp filename, max tries reached \" + name));\n            }\n            cb(null, name);\n        });\n    })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */ function tmpNameSync(options) {\n    var args = _parseArguments(options), opts = args[0], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n    if (isNaN(tries) || tries < 0) throw new Error(\"Invalid tries\");\n    if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error(\"Invalid template provided\");\n    do {\n        const name = _generateTmpName(opts);\n        try {\n            fs.statSync(name);\n        } catch (e) {\n            return name;\n        }\n    }while (tries-- > 0);\n    throw new Error(\"Could not get a unique tmp filename, max tries reached\");\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */ function file(options, callback) {\n    var args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    opts.postfix = _isUndefined(opts.postfix) ? \".tmp\" : opts.postfix;\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        if (err) return cb(err);\n        // create and open the file\n        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n            if (err) return cb(err);\n            if (opts.discardDescriptor) {\n                return fs.close(fd, function _discardCallback(err) {\n                    if (err) {\n                        // Low probability, and the file exists, so this could be\n                        // ignored.  If it isn't we certainly need to unlink the\n                        // file, and if that fails too its error is more\n                        // important.\n                        try {\n                            fs.unlinkSync(name);\n                        } catch (e) {\n                            if (!isENOENT(e)) {\n                                err = e;\n                            }\n                        }\n                        return cb(err);\n                    }\n                    cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n                });\n            }\n            if (opts.detachDescriptor) {\n                return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n            }\n            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n        });\n    });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */ function fileSync(options) {\n    var args = _parseArguments(options), opts = args[0];\n    opts.postfix = opts.postfix || \".tmp\";\n    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n    const name = tmpNameSync(opts);\n    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n    if (opts.discardDescriptor) {\n        fs.closeSync(fd);\n        fd = undefined;\n    }\n    return {\n        name: name,\n        fd: fd,\n        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n    };\n}\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {string} root\n * @private\n */ function _rmdirRecursiveSync(root) {\n    const dirs = [\n        root\n    ];\n    do {\n        var dir = dirs.pop(), deferred = false, files = fs.readdirSync(dir);\n        for(var i = 0, length = files.length; i < length; i++){\n            var file = path.join(dir, files[i]), stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n            if (stat.isDirectory()) {\n                if (!deferred) {\n                    deferred = true;\n                    dirs.push(dir);\n                }\n                dirs.push(file);\n            } else {\n                fs.unlinkSync(file);\n            }\n        }\n        if (!deferred) {\n            fs.rmdirSync(dir);\n        }\n    }while (dirs.length !== 0);\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */ function dir(options, callback) {\n    var args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        if (err) return cb(err);\n        // create the directory\n        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n            if (err) return cb(err);\n            cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n        });\n    });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */ function dirSync(options) {\n    var args = _parseArguments(options), opts = args[0];\n    const name = tmpNameSync(opts);\n    fs.mkdirSync(name, opts.mode || DIR_MODE);\n    return {\n        name: name,\n        removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n    };\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */ function _prepareTmpFileRemoveCallback(name, fd, opts) {\n    const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n        try {\n            if (0 <= fdPath[0]) {\n                fs.closeSync(fdPath[0]);\n            }\n        } catch (e) {\n            // under some node/windows related circumstances, a temporary file\n            // may have not be created as expected or the file was already closed\n            // by the user, in which case we will simply ignore the error\n            if (!isEBADF(e) && !isENOENT(e)) {\n                // reraise any unanticipated error\n                throw e;\n            }\n        }\n        try {\n            fs.unlinkSync(fdPath[1]);\n        } catch (e) {\n            if (!isENOENT(e)) {\n                // reraise any unanticipated error\n                throw e;\n            }\n        }\n    }, [\n        fd,\n        name\n    ]);\n    if (!opts.keep) {\n        _removeObjects.unshift(removeCallback);\n    }\n    return removeCallback;\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */ function _prepareTmpDirRemoveCallback(name, opts) {\n    const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n    const removeCallback = _prepareRemoveCallback(removeFunction, name);\n    if (!opts.keep) {\n        _removeObjects.unshift(removeCallback);\n    }\n    return removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */ function _prepareRemoveCallback(removeFunction, arg) {\n    var called = false;\n    return function _cleanupCallback(next) {\n        if (!called) {\n            const index = _removeObjects.indexOf(_cleanupCallback);\n            if (index >= 0) {\n                _removeObjects.splice(index, 1);\n            }\n            called = true;\n            removeFunction(arg);\n        }\n        if (next) next(null);\n    };\n}\n/**\n * The garbage collector.\n *\n * @private\n */ function _garbageCollector() {\n    if (_uncaughtException && !_gracefulCleanup) {\n        return;\n    }\n    // the function being called removes itself from _removeObjects,\n    // loop until _removeObjects is empty\n    while(_removeObjects.length){\n        try {\n            _removeObjects[0].call(null);\n        } catch (e) {\n        // already removed?\n        }\n    }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */ function isEBADF(error) {\n    return isExpectedError(error, -EBADF, \"EBADF\");\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */ function isENOENT(error) {\n    return isExpectedError(error, -ENOENT, \"ENOENT\");\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {String}\n *   error.errno {String|Number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {Number} negated\n *   error.errno n/a\n */ function isExpectedError(error, code, errno) {\n    return error.code == code || error.code == errno;\n}\n/**\n * Sets the graceful cleanup.\n *\n * Also removes the created files and directories when an uncaught exception occurs.\n */ function setGracefulCleanup() {\n    _gracefulCleanup = true;\n}\nconst version = process.versions.node.split(\".\").map(function(value) {\n    return parseInt(value, 10);\n});\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n    process.addListener(\"uncaughtException\", function _uncaughtExceptionThrown(err) {\n        _uncaughtException = true;\n        _garbageCollector();\n        throw err;\n    });\n}\nprocess.addListener(\"exit\", function _exit(code) {\n    if (code) _uncaughtException = true;\n    _garbageCollector();\n});\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n */ /**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */ /**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */ /**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */ /**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */ /**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */ // exporting all the needed methods\nmodule.exports.tmpdir = tmpDir;\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdG1wQDAuMC4zMy9ub2RlX21vZHVsZXMvdG1wL2xpYi90bXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBRUQ7O0NBRUM7QUFDRCxNQUFNQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNuQixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNSSxLQUFLQyxRQUFRQyxPQUFPLENBQUM7QUFFM0I7O0NBRUMsR0FDRCxNQUNFOzs7R0FHQyxHQUNEQyxTQUFTSixZQUVULHVDQUF1QztBQUN2Q0ssZUFBZSxrRUFFZkMsbUJBQW1CLFVBRW5CQyxnQkFBZ0IsR0FFaEJDLGVBQWUsQ0FBQ1AsR0FBR1EsT0FBTyxJQUFJUixHQUFHTCxFQUFFLENBQUNhLE9BQU8sSUFBS1IsQ0FBQUEsR0FBR1MsTUFBTSxJQUFJVCxHQUFHTCxFQUFFLENBQUNjLE1BQU0sSUFBS1QsQ0FBQUEsR0FBR1UsTUFBTSxJQUFJVixHQUFHTCxFQUFFLENBQUNlLE1BQU0sR0FFdkdDLFFBQVFYLEdBQUdXLEtBQUssSUFBSVgsR0FBR1ksRUFBRSxDQUFDQyxLQUFLLENBQUNGLEtBQUssRUFDckNHLFNBQVNkLEdBQUdjLE1BQU0sSUFBSWQsR0FBR1ksRUFBRSxDQUFDQyxLQUFLLENBQUNDLE1BQU0sRUFFeENDLFdBQVcsSUFBSSxTQUFTLEtBQ3hCQyxZQUFZLElBQUksU0FBUyxLQUV6Qix3REFBd0Q7QUFDeERDLGlCQUFpQixFQUFFO0FBRXJCLElBQ0VDLG1CQUFtQixPQUNuQkMscUJBQXFCO0FBRXZCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxhQUFhQyxPQUFPO0lBQzNCLElBQ0VDLFFBQVEsRUFBRSxFQUNWQyxNQUFNO0lBRVIsOERBQThEO0lBQzlELElBQUk7UUFDRkEsTUFBTXpCLE9BQU8wQixXQUFXLENBQUNIO0lBQzNCLEVB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QVEsQ0FBQ0MsSUFBSSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLFNBQVUvRixLQUFLO0lBQ2xFLE9BQU9nRyxTQUFTaEcsT0FBTztBQUN6QjtBQUVBLElBQUkyRixPQUFPLENBQUMsRUFBRSxLQUFLLEtBQU1BLENBQUFBLE9BQU8sQ0FBQyxFQUFFLEdBQUcsS0FBS0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxLQUFLQSxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUk7SUFDOUVoSCxRQUFRc0gsV0FBVyxDQUFDLHFCQUFxQixTQUFTQyx5QkFBeUJsRSxHQUFHO1FBQzVFbkMscUJBQXFCO1FBQ3JCd0Y7UUFFQSxNQUFNckQ7SUFDUjtBQUNGO0FBRUFyRCxRQUFRc0gsV0FBVyxDQUFDLFFBQVEsU0FBU0UsTUFBTVYsSUFBSTtJQUM3QyxJQUFJQSxNQUFNNUYscUJBQXFCO0lBQy9Cd0Y7QUFDRjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7O0NBSUMsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQsbUNBQW1DO0FBQ25DZSxxQkFBcUIsR0FBR3ZIO0FBRXhCdUgsa0JBQWtCLEdBQUduRjtBQUNyQm1GLHNCQUFzQixHQUFHakM7QUFFekJpQyxtQkFBbUIsR0FBR2pFO0FBQ3RCaUUsdUJBQXVCLEdBQUduRDtBQUUxQm1ELHNCQUFzQixHQUFHN0U7QUFDekI2RSwwQkFBMEIsR0FBR25FO0FBRTdCbUUsaUNBQWlDLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS90bXBAMC4wLjMzL25vZGVfbW9kdWxlcy90bXAvbGliL3RtcC5qcz9hZDU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVG1wXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTcgS0FSQVNaSSBJc3R2YW4gPGdpdGh1YkBzcGFtLnJhc3ppLmh1PlxuICpcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBvc1RtcERpciA9IHJlcXVpcmUoJ29zLXRtcGRpcicpO1xuY29uc3QgX2MgPSBwcm9jZXNzLmJpbmRpbmcoJ2NvbnN0YW50cycpO1xuXG4vKlxuICogVGhlIHdvcmtpbmcgaW5uZXIgdmFyaWFibGVzLlxuICovXG5jb25zdFxuICAvKipcbiAgICogVGhlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0bXBEaXIgPSBvc1RtcERpcigpLFxuXG4gIC8vIHRoZSByYW5kb20gY2hhcmFjdGVycyB0byBjaG9vc2UgZnJvbVxuICBSQU5ET01fQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuXG4gIFRFTVBMQVRFX1BBVFRFUk4gPSAvWFhYWFhYLyxcblxuICBERUZBVUxUX1RSSUVTID0gMyxcblxuICBDUkVBVEVfRkxBR1MgPSAoX2MuT19DUkVBVCB8fCBfYy5mcy5PX0NSRUFUKSB8IChfYy5PX0VYQ0wgfHwgX2MuZnMuT19FWENMKSB8IChfYy5PX1JEV1IgfHwgX2MuZnMuT19SRFdSKSxcblxuICBFQkFERiA9IF9jLkVCQURGIHx8IF9jLm9zLmVycm5vLkVCQURGLFxuICBFTk9FTlQgPSBfYy5FTk9FTlQgfHwgX2Mub3MuZXJybm8uRU5PRU5ULFxuXG4gIERJUl9NT0RFID0gNDQ4IC8qIDBvNzAwICovLFxuICBGSUxFX01PREUgPSAzODQgLyogMG82MDAgKi8sXG5cbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXTtcblxudmFyXG4gIF9ncmFjZWZ1bENsZWFudXAgPSBmYWxzZSxcbiAgX3VuY2F1Z2h0RXhjZXB0aW9uID0gZmFsc2U7XG5cbi8qKlxuICogUmFuZG9tIG5hbWUgZ2VuZXJhdG9yIGJhc2VkIG9uIGNyeXB0by5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwOi8vYmxvZy50b21wYXdsYWsub3JnL2hvdy10by1nZW5lcmF0ZS1yYW5kb20tdmFsdWVzLW5vZGVqcy1qYXZhc2NyaXB0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGhvd01hbnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgcmFuZG9tIG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yYW5kb21DaGFycyhob3dNYW55KSB7XG4gIHZhclxuICAgIHZhbHVlID0gW10sXG4gICAgcm5kID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgZmFpbCBiZWNhdXNlIHdlIHJhbiBvdXQgb2YgZW50cm9weVxuICB0cnkge1xuICAgIHJuZCA9IGNyeXB0by5yYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJuZCA9IGNyeXB0by5wc2V1ZG9SYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgdmFsdWUucHVzaChSQU5ET01fQ0hBUlNbcm5kW2ldICUgUkFORE9NX0NIQVJTLmxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBhcnNlZCBhcmd1bWVudHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBbY2FsbGJhY2sgfHwge30sIG9wdGlvbnNdO1xuICB9XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHJldHVybiBbe30sIGNhbGxiYWNrXTtcbiAgfVxuXG4gIHJldHVybiBbb3B0aW9ucywgY2FsbGJhY2tdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyB0ZW1wb3JhcnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5ldyByYW5kb20gbmFtZSBhY2NvcmRpbmcgdG8gb3B0c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlVG1wTmFtZShvcHRzKSB7XG4gIGlmIChvcHRzLm5hbWUpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKG9wdHMuZGlyIHx8IHRtcERpciwgb3B0cy5uYW1lKTtcbiAgfVxuXG4gIC8vIG1rc3RlbXBzIGxpa2UgdGVtcGxhdGVcbiAgaWYgKG9wdHMudGVtcGxhdGUpIHtcbiAgICByZXR1cm4gb3B0cy50ZW1wbGF0ZS5yZXBsYWNlKFRFTVBMQVRFX1BBVFRFUk4sIF9yYW5kb21DaGFycyg2KSk7XG4gIH1cblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCB8fCAndG1wLScsXG4gICAgcHJvY2Vzcy5waWQsXG4gICAgX3JhbmRvbUNoYXJzKDEyKSxcbiAgICBvcHRzLnBvc3RmaXggfHwgJydcbiAgXS5qb2luKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKG9wdHMuZGlyIHx8IHRtcERpciwgbmFtZSk7XG59XG5cbi8qKlxuICogR2V0cyBhIHRlbXBvcmFyeSBmaWxlIG5hbWUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3x0bXBOYW1lQ2FsbGJhY2spfSBvcHRpb25zIG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSB7P3RtcE5hbWVDYWxsYmFja30gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyXG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdLFxuICAgIHRyaWVzID0gb3B0cy5uYW1lID8gMSA6IG9wdHMudHJpZXMgfHwgREVGQVVMVF9UUklFUztcblxuICBpZiAoaXNOYU4odHJpZXMpIHx8IHRyaWVzIDwgMClcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIHRyaWVzJykpO1xuXG4gIGlmIChvcHRzLnRlbXBsYXRlICYmICFvcHRzLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUgcHJvdmlkZWQnKSk7XG5cbiAgKGZ1bmN0aW9uIF9nZXRVbmlxdWVOYW1lKCkge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcGF0aCBleGlzdHMgdGhlbiByZXRyeSBpZiBuZWVkZWRcbiAgICBmcy5zdGF0KG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGlmICh0cmllcy0tID4gMCkgcmV0dXJuIF9nZXRVbmlxdWVOYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGNiKG51bGwsIG5hbWUpO1xuICAgIH0pO1xuICB9KCkpO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgdG1wTmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkIG9yIGNvdWxkIG5vdCBnZW5lcmF0ZSBhIGZpbGVuYW1lXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWVTeW5jKG9wdGlvbnMpIHtcbiAgdmFyXG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICB0cmllcyA9IG9wdHMubmFtZSA/IDEgOiBvcHRzLnRyaWVzIHx8IERFRkFVTFRfVFJJRVM7XG5cbiAgaWYgKGlzTmFOKHRyaWVzKSB8fCB0cmllcyA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyaWVzJyk7XG5cbiAgaWYgKG9wdHMudGVtcGxhdGUgJiYgIW9wdHMudGVtcGxhdGUubWF0Y2goVEVNUExBVEVfUEFUVEVSTikpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRlbXBsYXRlIHByb3ZpZGVkJyk7XG5cbiAgZG8ge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICBmcy5zdGF0U3luYyhuYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH0gd2hpbGUgKHRyaWVzLS0gPiAwKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIG9wZW5zIGEgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xmaWxlQ2FsbGJhY2spfSBvcHRpb25zIHRoZSBjb25maWcgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2ZpbGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmlsZShvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgb3B0cy5wb3N0Zml4ID0gKF9pc1VuZGVmaW5lZChvcHRzLnBvc3RmaXgpKSA/ICcudG1wJyA6IG9wdHMucG9zdGZpeDtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIGFuZCBvcGVuIHRoZSBmaWxlXG4gICAgZnMub3BlbihuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUsIGZ1bmN0aW9uIF9maWxlQ3JlYXRlZChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKG9wdHMuZGlzY2FyZERlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiBfZGlzY2FyZENhbGxiYWNrKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIC8vIExvdyBwcm9iYWJpbGl0eSwgYW5kIHRoZSBmaWxlIGV4aXN0cywgc28gdGhpcyBjb3VsZCBiZVxuICAgICAgICAgICAgLy8gaWdub3JlZC4gIElmIGl0IGlzbid0IHdlIGNlcnRhaW5seSBuZWVkIHRvIHVubGluayB0aGVcbiAgICAgICAgICAgIC8vIGZpbGUsIGFuZCBpZiB0aGF0IGZhaWxzIHRvbyBpdHMgZXJyb3IgaXMgbW9yZVxuICAgICAgICAgICAgLy8gaW1wb3J0YW50LlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhuYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0VOT0VOVChlKSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsLCBuYW1lLCB1bmRlZmluZWQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIC0xLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZGV0YWNoRGVzY3JpcHRvcikge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgbmFtZSwgZmQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIC0xLCBvcHRzKSk7XG4gICAgICB9XG4gICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZmQsIG9wdHMpKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBmaWxlLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0ZpbGVTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSwgZmQgYW5kIHJlbW92ZUNhbGxiYWNrXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2Fubm90IGNyZWF0ZSBhIGZpbGVcbiAqL1xuZnVuY3Rpb24gZmlsZVN5bmMob3B0aW9ucykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIG9wdHMucG9zdGZpeCA9IG9wdHMucG9zdGZpeCB8fCAnLnRtcCc7XG5cbiAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIHZhciBmZCA9IGZzLm9wZW5TeW5jKG5hbWUsIENSRUFURV9GTEFHUywgb3B0cy5tb2RlIHx8IEZJTEVfTU9ERSk7XG4gIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZkKTsgXG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cylcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIGFuZCBmb2xkZXJzIGluIGEgZGlyZWN0b3J5IHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb290XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcm1kaXJSZWN1cnNpdmVTeW5jKHJvb3QpIHtcbiAgY29uc3QgZGlycyA9IFtyb290XTtcblxuICBkbyB7XG4gICAgdmFyXG4gICAgICBkaXIgPSBkaXJzLnBvcCgpLFxuICAgICAgZGVmZXJyZWQgPSBmYWxzZSxcbiAgICAgIGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBmaWxlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyXG4gICAgICAgIGZpbGUgPSBwYXRoLmpvaW4oZGlyLCBmaWxlc1tpXSksXG4gICAgICAgIHN0YXQgPSBmcy5sc3RhdFN5bmMoZmlsZSk7IC8vIGxzdGF0IHNvIHdlIGRvbid0IHJlY3Vyc2UgaW50byBzeW1saW5rZWQgZGlyZWN0b3JpZXNcblxuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgICAgZGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgIGRpcnMucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZzLnVubGlua1N5bmMoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgZnMucm1kaXJTeW5jKGRpcik7XG4gICAgfVxuICB9IHdoaWxlIChkaXJzLmxlbmd0aCAhPT0gMCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xkaXJDYWxsYmFjayl9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9kaXJDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZGlyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhclxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGNiKG51bGwsIG5hbWUsIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cykpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGRpci5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtEaXJTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBjYW5ub3QgY3JlYXRlIGEgZGlyZWN0b3J5XG4gKi9cbmZ1bmN0aW9uIGRpclN5bmMob3B0aW9ucykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IG5hbWUgPSB0bXBOYW1lU3luYyhvcHRzKTtcbiAgZnMubWtkaXJTeW5jKG5hbWUsIG9wdHMubW9kZSB8fCBESVJfTU9ERSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMpXG4gIH07XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHtmaWxlQ2FsbGJhY2t9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBmZCwgb3B0cykge1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soZnVuY3Rpb24gX3JlbW92ZUNhbGxiYWNrKGZkUGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoMCA8PSBmZFBhdGhbMF0pIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkUGF0aFswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyB1bmRlciBzb21lIG5vZGUvd2luZG93cyByZWxhdGVkIGNpcmN1bXN0YW5jZXMsIGEgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIC8vIG1heSBoYXZlIG5vdCBiZSBjcmVhdGVkIGFzIGV4cGVjdGVkIG9yIHRoZSBmaWxlIHdhcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgLy8gYnkgdGhlIHVzZXIsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBzaW1wbHkgaWdub3JlIHRoZSBlcnJvclxuICAgICAgaWYgKCFpc0VCQURGKGUpICYmICFpc0VOT0VOVChlKSkge1xuICAgICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmcy51bmxpbmtTeW5jKGZkUGF0aFsxXSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWlzRU5PRU5UKGUpKSB7XG4gICAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtmZCwgbmFtZV0pO1xuXG4gIGlmICghb3B0cy5rZWVwKSB7XG4gICAgX3JlbW92ZU9iamVjdHMudW5zaGlmdChyZW1vdmVDYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cykge1xuICBjb25zdCByZW1vdmVGdW5jdGlvbiA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IF9ybWRpclJlY3Vyc2l2ZVN5bmMgOiBmcy5ybWRpclN5bmMuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIHtcbiAgICBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW1vdmVGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgYXJnKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gX3JlbW92ZU9iamVjdHMuaW5kZXhPZihfY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIF9yZW1vdmVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICByZW1vdmVGdW5jdGlvbihhcmcpO1xuICAgIH1cblxuICAgIGlmIChuZXh0KSBuZXh0KG51bGwpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2FyYmFnZUNvbGxlY3RvcigpIHtcbiAgaWYgKF91bmNhdWdodEV4Y2VwdGlvbiAmJiAhX2dyYWNlZnVsQ2xlYW51cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQgcmVtb3ZlcyBpdHNlbGYgZnJvbSBfcmVtb3ZlT2JqZWN0cyxcbiAgLy8gbG9vcCB1bnRpbCBfcmVtb3ZlT2JqZWN0cyBpcyBlbXB0eVxuICB3aGlsZSAoX3JlbW92ZU9iamVjdHMubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9yZW1vdmVPYmplY3RzWzBdLmNhbGwobnVsbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gYWxyZWFkeSByZW1vdmVkP1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVCQURGIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKi9cbmZ1bmN0aW9uIGlzRUJBREYoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVCQURGLCAnRUJBREYnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFTk9FTlQgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqL1xuZnVuY3Rpb24gaXNFTk9FTlQoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVOT0VOVCwgJ0VOT0VOVCcpO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZXhwZWN0ZWQgZXJyb3IgY29kZSBtYXRjaGVzIHRoZSBhY3R1YWwgY29kZSBhbmQgZXJybm8sXG4gKiB3aGljaCB3aWxsIGRpZmZlciBiZXR3ZWVuIHRoZSBzdXBwb3J0ZWQgbm9kZSB2ZXJzaW9ucy5cbiAqXG4gKiAtIE5vZGUgPj0gNy4wOlxuICogICBlcnJvci5jb2RlIHtTdHJpbmd9XG4gKiAgIGVycm9yLmVycm5vIHtTdHJpbmd8TnVtYmVyfSBhbnkgbnVtZXJpY2FsIHZhbHVlIHdpbGwgYmUgbmVnYXRlZFxuICpcbiAqIC0gTm9kZSA+PSA2LjAgPCA3LjA6XG4gKiAgIGVycm9yLmNvZGUge1N0cmluZ31cbiAqICAgZXJyb3IuZXJybm8ge051bWJlcn0gbmVnYXRlZFxuICpcbiAqIC0gTm9kZSA+PSA0LjAgPCA2LjA6IGludHJvZHVjZXMgU3lzdGVtRXJyb3JcbiAqICAgZXJyb3IuY29kZSB7U3RyaW5nfVxuICogICBlcnJvci5lcnJubyB7TnVtYmVyfSBuZWdhdGVkXG4gKlxuICogLSBOb2RlID49IDAuMTAgPCA0LjA6XG4gKiAgIGVycm9yLmNvZGUge051bWJlcn0gbmVnYXRlZFxuICogICBlcnJvci5lcnJubyBuL2FcbiAqL1xuZnVuY3Rpb24gaXNFeHBlY3RlZEVycm9yKGVycm9yLCBjb2RlLCBlcnJubykge1xuICByZXR1cm4gZXJyb3IuY29kZSA9PSBjb2RlIHx8IGVycm9yLmNvZGUgPT0gZXJybm87XG59XG5cbi8qKlxuICogU2V0cyB0aGUgZ3JhY2VmdWwgY2xlYW51cC5cbiAqXG4gKiBBbHNvIHJlbW92ZXMgdGhlIGNyZWF0ZWQgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIHdoZW4gYW4gdW5jYXVnaHQgZXhjZXB0aW9uIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gc2V0R3JhY2VmdWxDbGVhbnVwKCkge1xuICBfZ3JhY2VmdWxDbGVhbnVwID0gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59KTtcblxuaWYgKHZlcnNpb25bMF0gPT09IDAgJiYgKHZlcnNpb25bMV0gPCA5IHx8IHZlcnNpb25bMV0gPT09IDkgJiYgdmVyc2lvblsyXSA8IDUpKSB7XG4gIHByb2Nlc3MuYWRkTGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gX3VuY2F1Z2h0RXhjZXB0aW9uVGhyb3duKGVycikge1xuICAgIF91bmNhdWdodEV4Y2VwdGlvbiA9IHRydWU7XG4gICAgX2dhcmJhZ2VDb2xsZWN0b3IoKTtcblxuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbnByb2Nlc3MuYWRkTGlzdGVuZXIoJ2V4aXQnLCBmdW5jdGlvbiBfZXhpdChjb2RlKSB7XG4gIGlmIChjb2RlKSBfdW5jYXVnaHRFeGNlcHRpb24gPSB0cnVlO1xuICBfZ2FyYmFnZUNvbGxlY3RvcigpO1xufSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdHJpZXMgdGhlIG51bWJlciBvZiB0cmllcyBiZWZvcmUgZ2l2ZSB1cCB0aGUgbmFtZSBnZW5lcmF0aW9uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRlbXBsYXRlIHRoZSBcIm1rc3RlbXBcIiBsaWtlIGZpbGVuYW1lIHRlbXBsYXRlXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG5hbWUgZml4IG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGlyIHRoZSB0bXAgZGlyZWN0b3J5IHRvIHVzZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcG9zdGZpeCBwb3N0Zml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaXJTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZGlyZWN0b3J5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgdG1wTmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGRpckNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtzaW1wbGVDYWxsYmFja30gW25leHRdIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZW50cnkgd2FzIHJlbW92ZWRcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXN6aS9ub2RlLXRtcC9pc3N1ZXMvNTd8cmFzemkvbm9kZS10bXAjNTd9XG4gKlxuICogQGNhbGxiYWNrIHNpbXBsZUNhbGxiYWNrXG4gKi9cblxuLy8gZXhwb3J0aW5nIGFsbCB0aGUgbmVlZGVkIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzLnRtcGRpciA9IHRtcERpcjtcblxubW9kdWxlLmV4cG9ydHMuZGlyID0gZGlyO1xubW9kdWxlLmV4cG9ydHMuZGlyU3luYyA9IGRpclN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLmZpbGUgPSBmaWxlO1xubW9kdWxlLmV4cG9ydHMuZmlsZVN5bmMgPSBmaWxlU3luYztcblxubW9kdWxlLmV4cG9ydHMudG1wTmFtZSA9IHRtcE5hbWU7XG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lU3luYyA9IHRtcE5hbWVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRHcmFjZWZ1bENsZWFudXAgPSBzZXRHcmFjZWZ1bENsZWFudXA7XG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwicGF0aCIsImNyeXB0byIsIm9zVG1wRGlyIiwiX2MiLCJwcm9jZXNzIiwiYmluZGluZyIsInRtcERpciIsIlJBTkRPTV9DSEFSUyIsIlRFTVBMQVRFX1BBVFRFUk4iLCJERUZBVUxUX1RSSUVTIiwiQ1JFQVRFX0ZMQUdTIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fUkRXUiIsIkVCQURGIiwib3MiLCJlcnJubyIsIkVOT0VOVCIsIkRJUl9NT0RFIiwiRklMRV9NT0RFIiwiX3JlbW92ZU9iamVjdHMiLCJfZ3JhY2VmdWxDbGVhbnVwIiwiX3VuY2F1Z2h0RXhjZXB0aW9uIiwiX3JhbmRvbUNoYXJzIiwiaG93TWFueSIsInZhbHVlIiwicm5kIiwicmFuZG9tQnl0ZXMiLCJlIiwicHNldWRvUmFuZG9tQnl0ZXMiLCJpIiwicHVzaCIsImxlbmd0aCIsImpvaW4iLCJfaXNVbmRlZmluZWQiLCJvYmoiLCJfcGFyc2VBcmd1bWVudHMiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJfZ2VuZXJhdGVUbXBOYW1lIiwib3B0cyIsIm5hbWUiLCJkaXIiLCJ0ZW1wbGF0ZSIsInJlcGxhY2UiLCJwcmVmaXgiLCJwaWQiLCJwb3N0Zml4IiwidG1wTmFtZSIsImFyZ3MiLCJjYiIsInRyaWVzIiwiaXNOYU4iLCJFcnJvciIsIm1hdGNoIiwiX2dldFVuaXF1ZU5hbWUiLCJzdGF0IiwiZXJyIiwidG1wTmFtZVN5bmMiLCJzdGF0U3luYyIsImZpbGUiLCJfdG1wTmFtZUNyZWF0ZWQiLCJvcGVuIiwibW9kZSIsIl9maWxlQ3JlYXRlZCIsImZkIiwiZGlzY2FyZERlc2NyaXB0b3IiLCJjbG9zZSIsIl9kaXNjYXJkQ2FsbGJhY2siLCJ1bmxpbmtTeW5jIiwiaXNFTk9FTlQiLCJ1bmRlZmluZWQiLCJfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayIsImRldGFjaERlc2NyaXB0b3IiLCJmaWxlU3luYyIsImRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IiLCJvcGVuU3luYyIsImNsb3NlU3luYyIsInJlbW92ZUNhbGxiYWNrIiwiX3JtZGlyUmVjdXJzaXZlU3luYyIsInJvb3QiLCJkaXJzIiwicG9wIiwiZGVmZXJyZWQiLCJmaWxlcyIsInJlYWRkaXJTeW5jIiwibHN0YXRTeW5jIiwiaXNEaXJlY3RvcnkiLCJybWRpclN5bmMiLCJta2RpciIsIl9kaXJDcmVhdGVkIiwiX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayIsImRpclN5bmMiLCJta2RpclN5bmMiLCJfcHJlcGFyZVJlbW92ZUNhbGxiYWNrIiwiX3JlbW92ZUNhbGxiYWNrIiwiZmRQYXRoIiwiaXNFQkFERiIsImtlZXAiLCJ1bnNoaWZ0IiwicmVtb3ZlRnVuY3Rpb24iLCJ1bnNhZmVDbGVhbnVwIiwiYmluZCIsImFyZyIsImNhbGxlZCIsIl9jbGVhbnVwQ2FsbGJhY2siLCJuZXh0IiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiX2dhcmJhZ2VDb2xsZWN0b3IiLCJjYWxsIiwiZXJyb3IiLCJpc0V4cGVjdGVkRXJyb3IiLCJjb2RlIiwic2V0R3JhY2VmdWxDbGVhbnVwIiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9kZSIsInNwbGl0IiwibWFwIiwicGFyc2VJbnQiLCJhZGRMaXN0ZW5lciIsIl91bmNhdWdodEV4Y2VwdGlvblRocm93biIsIl9leGl0IiwibW9kdWxlIiwiZXhwb3J0cyIsInRtcGRpciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tmp@0.0.33/node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;