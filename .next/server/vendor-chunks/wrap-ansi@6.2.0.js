"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/wrap-ansi@6.2.0";
exports.ids = ["vendor-chunks/wrap-ansi@6.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst stringWidth = __webpack_require__(/*! string-width */ \"(ssr)/./node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js\");\nconst stripAnsi = __webpack_require__(/*! strip-ansi */ \"(ssr)/./node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js\");\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"(ssr)/./node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js\");\nconst ESCAPES = new Set([\n    \"\\x1b\",\n    \"\\x9b\"\n]);\nconst END_CODE = 39;\nconst wrapAnsi = (code)=>`${ESCAPES.values().next().value}[${code}m`;\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = (string)=>string.split(\" \").map((character)=>stringWidth(character));\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns)=>{\n    const characters = [\n        ...word\n    ];\n    let isInsideEscape = false;\n    let visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n    for (const [index, character] of characters.entries()){\n        const characterLength = stringWidth(character);\n        if (visible + characterLength <= columns) {\n            rows[rows.length - 1] += character;\n        } else {\n            rows.push(character);\n            visible = 0;\n        }\n        if (ESCAPES.has(character)) {\n            isInsideEscape = true;\n        } else if (isInsideEscape && character === \"m\") {\n            isInsideEscape = false;\n            continue;\n        }\n        if (isInsideEscape) {\n            continue;\n        }\n        visible += characterLength;\n        if (visible === columns && index < characters.length - 1) {\n            rows.push(\"\");\n            visible = 0;\n        }\n    }\n    // It's possible that the last row we copy over is only\n    // ansi escape characters, handle this edge-case\n    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n        rows[rows.length - 2] += rows.pop();\n    }\n};\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = (str)=>{\n    const words = str.split(\" \");\n    let last = words.length;\n    while(last > 0){\n        if (stringWidth(words[last - 1]) > 0) {\n            break;\n        }\n        last--;\n    }\n    if (last === words.length) {\n        return str;\n    }\n    return words.slice(0, last).join(\" \") + words.slice(last).join(\"\");\n};\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {})=>{\n    if (options.trim !== false && string.trim() === \"\") {\n        return \"\";\n    }\n    let pre = \"\";\n    let ret = \"\";\n    let escapeCode;\n    const lengths = wordLengths(string);\n    let rows = [\n        \"\"\n    ];\n    for (const [index, word] of string.split(\" \").entries()){\n        if (options.trim !== false) {\n            rows[rows.length - 1] = rows[rows.length - 1].trimLeft();\n        }\n        let rowLength = stringWidth(rows[rows.length - 1]);\n        if (index !== 0) {\n            if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n                // If we start with a new word but the current row length equals the length of the columns, add a new row\n                rows.push(\"\");\n                rowLength = 0;\n            }\n            if (rowLength > 0 || options.trim === false) {\n                rows[rows.length - 1] += \" \";\n                rowLength++;\n            }\n        }\n        // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n        if (options.hard && lengths[index] > columns) {\n            const remainingColumns = columns - rowLength;\n            const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n            const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n            if (breaksStartingNextLine < breaksStartingThisLine) {\n                rows.push(\"\");\n            }\n            wrapWord(rows, word, columns);\n            continue;\n        }\n        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n            if (options.wordWrap === false && rowLength < columns) {\n                wrapWord(rows, word, columns);\n                continue;\n            }\n            rows.push(\"\");\n        }\n        if (rowLength + lengths[index] > columns && options.wordWrap === false) {\n            wrapWord(rows, word, columns);\n            continue;\n        }\n        rows[rows.length - 1] += word;\n    }\n    if (options.trim !== false) {\n        rows = rows.map(stringVisibleTrimSpacesRight);\n    }\n    pre = rows.join(\"\\n\");\n    for (const [index, character] of [\n        ...pre\n    ].entries()){\n        ret += character;\n        if (ESCAPES.has(character)) {\n            const code = parseFloat(/\\d[^m]*/.exec(pre.slice(index, index + 4)));\n            escapeCode = code === END_CODE ? null : code;\n        }\n        const code = ansiStyles.codes.get(Number(escapeCode));\n        if (escapeCode && code) {\n            if (pre[index + 1] === \"\\n\") {\n                ret += wrapAnsi(code);\n            } else if (character === \"\\n\") {\n                ret += wrapAnsi(escapeCode);\n            }\n        }\n    }\n    return ret;\n};\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options)=>{\n    return String(string).normalize().replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map((line)=>exec(line, columns, options)).join(\"\\n\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd3JhcC1hbnNpQDYuMi4wL25vZGVfbW9kdWxlcy93cmFwLWFuc2kvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxjQUFjQyxtQkFBT0EsQ0FBQztBQUM1QixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUUzQixNQUFNRyxVQUFVLElBQUlDLElBQUk7SUFDdkI7SUFDQTtDQUNBO0FBRUQsTUFBTUMsV0FBVztBQUVqQixNQUFNQyxXQUFXQyxDQUFBQSxPQUFRLENBQUMsRUFBRUosUUFBUUssTUFBTSxHQUFHQyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxDQUFDLEVBQUVILEtBQUssQ0FBQyxDQUFDO0FBRXBFLHVEQUF1RDtBQUN2RCxrREFBa0Q7QUFDbEQsTUFBTUksY0FBY0MsQ0FBQUEsU0FBVUEsT0FBT0MsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsWUFBYWhCLFlBQVlnQjtBQUU3RSx3Q0FBd0M7QUFDeEMsZ0RBQWdEO0FBQ2hELE1BQU1DLFdBQVcsQ0FBQ0MsTUFBTUMsTUFBTUM7SUFDN0IsTUFBTUMsYUFBYTtXQUFJRjtLQUFLO0lBRTVCLElBQUlHLGlCQUFpQjtJQUNyQixJQUFJQyxVQUFVdkIsWUFBWUUsVUFBVWdCLElBQUksQ0FBQ0EsS0FBS00sTUFBTSxHQUFHLEVBQUU7SUFFekQsS0FBSyxNQUFNLENBQUNDLE9BQU9ULFVBQVUsSUFBSUssV0FBV0ssT0FBTyxHQUFJO1FBQ3RELE1BQU1DLGtCQUFrQjNCLFlBQVlnQjtRQUVwQyxJQUFJTyxVQUFVSSxtQkFBbUJQLFNBQVM7WUFDekNGLElBQUksQ0FBQ0EsS0FBS00sTUFBTSxHQUFHLEVBQUUsSUFBSVI7UUFDMUIsT0FBTztZQUNORSxLQUFLVSxJQUFJLENBQUNaO1lBQ1ZPLFVBQVU7UUFDWDtRQUVBLElBQUluQixRQUFReUIsR0FBRyxDQUFDYixZQUFZO1lBQzNCTSxp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QUNqQixPQUFPLElBQUlRLGNBQWMsTUFBTTtnQkFDOUJ5QixPQUFPbEMsU0FBU21DO1lBQ2pCO1FBQ0Q7SUFDRDtJQUVBLE9BQU9EO0FBQ1I7QUFFQSxpREFBaUQ7QUFDakRnQixPQUFPQyxPQUFPLEdBQUcsQ0FBQzdDLFFBQVFPLFNBQVNrQjtJQUNsQyxPQUFPcUIsT0FBTzlDLFFBQ1orQyxTQUFTLEdBQ1RDLE9BQU8sQ0FBQyxTQUFTLE1BQ2pCL0MsS0FBSyxDQUFDLE1BQ05DLEdBQUcsQ0FBQytDLENBQUFBLE9BQVF6QixLQUFLeUIsTUFBTTFDLFNBQVNrQixVQUNoQ0YsSUFBSSxDQUFDO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dyYXAtYW5zaUA2LjIuMC9ub2RlX21vZHVsZXMvd3JhcC1hbnNpL2luZGV4LmpzPzRjYWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgc3RyaW5nV2lkdGggPSByZXF1aXJlKCdzdHJpbmctd2lkdGgnKTtcbmNvbnN0IHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcbmNvbnN0IGFuc2lTdHlsZXMgPSByZXF1aXJlKCdhbnNpLXN0eWxlcycpO1xuXG5jb25zdCBFU0NBUEVTID0gbmV3IFNldChbXG5cdCdcXHUwMDFCJyxcblx0J1xcdTAwOUInXG5dKTtcblxuY29uc3QgRU5EX0NPREUgPSAzOTtcblxuY29uc3Qgd3JhcEFuc2kgPSBjb2RlID0+IGAke0VTQ0FQRVMudmFsdWVzKCkubmV4dCgpLnZhbHVlfVske2NvZGV9bWA7XG5cbi8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHdvcmRzIHNwbGl0IG9uICcgJywgaWdub3Jpbmdcbi8vIHRoZSBleHRyYSBjaGFyYWN0ZXJzIGFkZGVkIGJ5IGFuc2kgZXNjYXBlIGNvZGVzXG5jb25zdCB3b3JkTGVuZ3RocyA9IHN0cmluZyA9PiBzdHJpbmcuc3BsaXQoJyAnKS5tYXAoY2hhcmFjdGVyID0+IHN0cmluZ1dpZHRoKGNoYXJhY3RlcikpO1xuXG4vLyBXcmFwIGEgbG9uZyB3b3JkIGFjcm9zcyBtdWx0aXBsZSByb3dzXG4vLyBBbnNpIGVzY2FwZSBjb2RlcyBkbyBub3QgY291bnQgdG93YXJkcyBsZW5ndGhcbmNvbnN0IHdyYXBXb3JkID0gKHJvd3MsIHdvcmQsIGNvbHVtbnMpID0+IHtcblx0Y29uc3QgY2hhcmFjdGVycyA9IFsuLi53b3JkXTtcblxuXHRsZXQgaXNJbnNpZGVFc2NhcGUgPSBmYWxzZTtcblx0bGV0IHZpc2libGUgPSBzdHJpbmdXaWR0aChzdHJpcEFuc2kocm93c1tyb3dzLmxlbmd0aCAtIDFdKSk7XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIGNoYXJhY3Rlcl0gb2YgY2hhcmFjdGVycy5lbnRyaWVzKCkpIHtcblx0XHRjb25zdCBjaGFyYWN0ZXJMZW5ndGggPSBzdHJpbmdXaWR0aChjaGFyYWN0ZXIpO1xuXG5cdFx0aWYgKHZpc2libGUgKyBjaGFyYWN0ZXJMZW5ndGggPD0gY29sdW1ucykge1xuXHRcdFx0cm93c1tyb3dzLmxlbmd0aCAtIDFdICs9IGNoYXJhY3Rlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cm93cy5wdXNoKGNoYXJhY3Rlcik7XG5cdFx0XHR2aXNpYmxlID0gMDtcblx0XHR9XG5cblx0XHRpZiAoRVNDQVBFUy5oYXMoY2hhcmFjdGVyKSkge1xuXHRcdFx0aXNJbnNpZGVFc2NhcGUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaXNJbnNpZGVFc2NhcGUgJiYgY2hhcmFjdGVyID09PSAnbScpIHtcblx0XHRcdGlzSW5zaWRlRXNjYXBlID0gZmFsc2U7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoaXNJbnNpZGVFc2NhcGUpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZpc2libGUgKz0gY2hhcmFjdGVyTGVuZ3RoO1xuXG5cdFx0aWYgKHZpc2libGUgPT09IGNvbHVtbnMgJiYgaW5kZXggPCBjaGFyYWN0ZXJzLmxlbmd0aCAtIDEpIHtcblx0XHRcdHJvd3MucHVzaCgnJyk7XG5cdFx0XHR2aXNpYmxlID0gMDtcblx0XHR9XG5cdH1cblxuXHQvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGxhc3Qgcm93IHdlIGNvcHkgb3ZlciBpcyBvbmx5XG5cdC8vIGFuc2kgZXNjYXBlIGNoYXJhY3RlcnMsIGhhbmRsZSB0aGlzIGVkZ2UtY2FzZVxuXHRpZiAoIXZpc2libGUgJiYgcm93c1tyb3dzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgJiYgcm93cy5sZW5ndGggPiAxKSB7XG5cdFx0cm93c1tyb3dzLmxlbmd0aCAtIDJdICs9IHJvd3MucG9wKCk7XG5cdH1cbn07XG5cbi8vIFRyaW1zIHNwYWNlcyBmcm9tIGEgc3RyaW5nIGlnbm9yaW5nIGludmlzaWJsZSBzZXF1ZW5jZXNcbmNvbnN0IHN0cmluZ1Zpc2libGVUcmltU3BhY2VzUmlnaHQgPSBzdHIgPT4ge1xuXHRjb25zdCB3b3JkcyA9IHN0ci5zcGxpdCgnICcpO1xuXHRsZXQgbGFzdCA9IHdvcmRzLmxlbmd0aDtcblxuXHR3aGlsZSAobGFzdCA+IDApIHtcblx0XHRpZiAoc3RyaW5nV2lkdGgod29yZHNbbGFzdCAtIDFdKSA+IDApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGxhc3QtLTtcblx0fVxuXG5cdGlmIChsYXN0ID09PSB3b3Jkcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0cmV0dXJuIHdvcmRzLnNsaWNlKDAsIGxhc3QpLmpvaW4oJyAnKSArIHdvcmRzLnNsaWNlKGxhc3QpLmpvaW4oJycpO1xufTtcblxuLy8gVGhlIHdyYXAtYW5zaSBtb2R1bGUgY2FuIGJlIGludm9rZWQgaW4gZWl0aGVyICdoYXJkJyBvciAnc29mdCcgd3JhcCBtb2RlXG4vL1xuLy8gJ2hhcmQnIHdpbGwgbmV2ZXIgYWxsb3cgYSBzdHJpbmcgdG8gdGFrZSB1cCBtb3JlIHRoYW4gY29sdW1ucyBjaGFyYWN0ZXJzXG4vL1xuLy8gJ3NvZnQnIGFsbG93cyBsb25nIHdvcmRzIHRvIGV4cGFuZCBwYXN0IHRoZSBjb2x1bW4gbGVuZ3RoXG5jb25zdCBleGVjID0gKHN0cmluZywgY29sdW1ucywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmIChvcHRpb25zLnRyaW0gIT09IGZhbHNlICYmIHN0cmluZy50cmltKCkgPT09ICcnKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0bGV0IHByZSA9ICcnO1xuXHRsZXQgcmV0ID0gJyc7XG5cdGxldCBlc2NhcGVDb2RlO1xuXG5cdGNvbnN0IGxlbmd0aHMgPSB3b3JkTGVuZ3RocyhzdHJpbmcpO1xuXHRsZXQgcm93cyA9IFsnJ107XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIHdvcmRdIG9mIHN0cmluZy5zcGxpdCgnICcpLmVudHJpZXMoKSkge1xuXHRcdGlmIChvcHRpb25zLnRyaW0gIT09IGZhbHNlKSB7XG5cdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV0udHJpbUxlZnQoKTtcblx0XHR9XG5cblx0XHRsZXQgcm93TGVuZ3RoID0gc3RyaW5nV2lkdGgocm93c1tyb3dzLmxlbmd0aCAtIDFdKTtcblxuXHRcdGlmIChpbmRleCAhPT0gMCkge1xuXHRcdFx0aWYgKHJvd0xlbmd0aCA+PSBjb2x1bW5zICYmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSB8fCBvcHRpb25zLnRyaW0gPT09IGZhbHNlKSkge1xuXHRcdFx0XHQvLyBJZiB3ZSBzdGFydCB3aXRoIGEgbmV3IHdvcmQgYnV0IHRoZSBjdXJyZW50IHJvdyBsZW5ndGggZXF1YWxzIHRoZSBsZW5ndGggb2YgdGhlIGNvbHVtbnMsIGFkZCBhIG5ldyByb3dcblx0XHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHRcdFx0cm93TGVuZ3RoID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJvd0xlbmd0aCA+IDAgfHwgb3B0aW9ucy50cmltID09PSBmYWxzZSkge1xuXHRcdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gKz0gJyAnO1xuXHRcdFx0XHRyb3dMZW5ndGgrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbiAnaGFyZCcgd3JhcCBtb2RlLCB0aGUgbGVuZ3RoIG9mIGEgbGluZSBpcyBuZXZlciBhbGxvd2VkIHRvIGV4dGVuZCBwYXN0ICdjb2x1bW5zJ1xuXHRcdGlmIChvcHRpb25zLmhhcmQgJiYgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zKSB7XG5cdFx0XHRjb25zdCByZW1haW5pbmdDb2x1bW5zID0gKGNvbHVtbnMgLSByb3dMZW5ndGgpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSA9IDEgKyBNYXRoLmZsb29yKChsZW5ndGhzW2luZGV4XSAtIHJlbWFpbmluZ0NvbHVtbnMgLSAxKSAvIGNvbHVtbnMpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdOZXh0TGluZSA9IE1hdGguZmxvb3IoKGxlbmd0aHNbaW5kZXhdIC0gMSkgLyBjb2x1bW5zKTtcblx0XHRcdGlmIChicmVha3NTdGFydGluZ05leHRMaW5lIDwgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSkge1xuXHRcdFx0XHRyb3dzLnB1c2goJycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChyb3dMZW5ndGggKyBsZW5ndGhzW2luZGV4XSA+IGNvbHVtbnMgJiYgcm93TGVuZ3RoID4gMCAmJiBsZW5ndGhzW2luZGV4XSA+IDApIHtcblx0XHRcdGlmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSAmJiByb3dMZW5ndGggPCBjb2x1bW5zKSB7XG5cdFx0XHRcdHdyYXBXb3JkKHJvd3MsIHdvcmQsIGNvbHVtbnMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHR9XG5cblx0XHRpZiAocm93TGVuZ3RoICsgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zICYmIG9wdGlvbnMud29yZFdyYXAgPT09IGZhbHNlKSB7XG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHJvd3Nbcm93cy5sZW5ndGggLSAxXSArPSB3b3JkO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMudHJpbSAhPT0gZmFsc2UpIHtcblx0XHRyb3dzID0gcm93cy5tYXAoc3RyaW5nVmlzaWJsZVRyaW1TcGFjZXNSaWdodCk7XG5cdH1cblxuXHRwcmUgPSByb3dzLmpvaW4oJ1xcbicpO1xuXG5cdGZvciAoY29uc3QgW2luZGV4LCBjaGFyYWN0ZXJdIG9mIFsuLi5wcmVdLmVudHJpZXMoKSkge1xuXHRcdHJldCArPSBjaGFyYWN0ZXI7XG5cblx0XHRpZiAoRVNDQVBFUy5oYXMoY2hhcmFjdGVyKSkge1xuXHRcdFx0Y29uc3QgY29kZSA9IHBhcnNlRmxvYXQoL1xcZFtebV0qLy5leGVjKHByZS5zbGljZShpbmRleCwgaW5kZXggKyA0KSkpO1xuXHRcdFx0ZXNjYXBlQ29kZSA9IGNvZGUgPT09IEVORF9DT0RFID8gbnVsbCA6IGNvZGU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29kZSA9IGFuc2lTdHlsZXMuY29kZXMuZ2V0KE51bWJlcihlc2NhcGVDb2RlKSk7XG5cblx0XHRpZiAoZXNjYXBlQ29kZSAmJiBjb2RlKSB7XG5cdFx0XHRpZiAocHJlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG5cdFx0XHRcdHJldCArPSB3cmFwQW5zaShjb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnXFxuJykge1xuXHRcdFx0XHRyZXQgKz0gd3JhcEFuc2koZXNjYXBlQ29kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cbi8vIEZvciBlYWNoIG5ld2xpbmUsIGludm9rZSB0aGUgbWV0aG9kIHNlcGFyYXRlbHlcbm1vZHVsZS5leHBvcnRzID0gKHN0cmluZywgY29sdW1ucywgb3B0aW9ucykgPT4ge1xuXHRyZXR1cm4gU3RyaW5nKHN0cmluZylcblx0XHQubm9ybWFsaXplKClcblx0XHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKGxpbmUgPT4gZXhlYyhsaW5lLCBjb2x1bW5zLCBvcHRpb25zKSlcblx0XHQuam9pbignXFxuJyk7XG59O1xuIl0sIm5hbWVzIjpbInN0cmluZ1dpZHRoIiwicmVxdWlyZSIsInN0cmlwQW5zaSIsImFuc2lTdHlsZXMiLCJFU0NBUEVTIiwiU2V0IiwiRU5EX0NPREUiLCJ3cmFwQW5zaSIsImNvZGUiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJ3b3JkTGVuZ3RocyIsInN0cmluZyIsInNwbGl0IiwibWFwIiwiY2hhcmFjdGVyIiwid3JhcFdvcmQiLCJyb3dzIiwid29yZCIsImNvbHVtbnMiLCJjaGFyYWN0ZXJzIiwiaXNJbnNpZGVFc2NhcGUiLCJ2aXNpYmxlIiwibGVuZ3RoIiwiaW5kZXgiLCJlbnRyaWVzIiwiY2hhcmFjdGVyTGVuZ3RoIiwicHVzaCIsImhhcyIsInBvcCIsInN0cmluZ1Zpc2libGVUcmltU3BhY2VzUmlnaHQiLCJzdHIiLCJ3b3JkcyIsImxhc3QiLCJzbGljZSIsImpvaW4iLCJleGVjIiwib3B0aW9ucyIsInRyaW0iLCJwcmUiLCJyZXQiLCJlc2NhcGVDb2RlIiwibGVuZ3RocyIsInRyaW1MZWZ0Iiwicm93TGVuZ3RoIiwid29yZFdyYXAiLCJoYXJkIiwicmVtYWluaW5nQ29sdW1ucyIsImJyZWFrc1N0YXJ0aW5nVGhpc0xpbmUiLCJNYXRoIiwiZmxvb3IiLCJicmVha3NTdGFydGluZ05leHRMaW5lIiwicGFyc2VGbG9hdCIsImNvZGVzIiwiZ2V0IiwiTnVtYmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN0cmluZyIsIm5vcm1hbGl6ZSIsInJlcGxhY2UiLCJsaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js\n");

/***/ })

};
;