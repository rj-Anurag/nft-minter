"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+ed25519@1.7.5";
exports.ids = ["vendor-chunks/@noble+ed25519@1.7.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@noble+ed25519@1.7.5/node_modules/@noble/ed25519/lib/esm/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+ed25519@1.7.5/node_modules/@noble/ed25519/lib/esm/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   ExtendedPoint: () => (/* binding */ ExtendedPoint),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   curve25519: () => (/* binding */ curve25519),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ \nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\");\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n    P: BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\"),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n    Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\")\n});\n\nconst POW_2_256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\nconst SQRT_M1 = BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\nconst SQRT_D = BigInt(\"6853475219497561581579357271197624642482790079785650197046958215289687604742\");\nconst SQRT_AD_MINUS_ONE = BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\nconst INVSQRT_A_MINUS_D = BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\nconst ONE_MINUS_D_SQ = BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\nconst D_MINUS_ONE_SQ = BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\nclass ExtendedPoint {\n    constructor(x, y, z, t){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError(\"ExtendedPoint#fromAffine: expected Point\");\n        }\n        if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p)=>p.z));\n        return points.map((p, i)=>p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const M = mod;\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(_2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        assertExtPoint(other);\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const { a, d } = CURVE;\n        const M = mod;\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            for(let i = 1; i < 2 ** (W - 1); i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n        if (256 % W) {\n            throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for(let window = 0; window < windows; window++){\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            } else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([\n            p,\n            f\n        ])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n) return P0;\n        if (this.equals(P0) || n === _1n) return this;\n        if (this.equals(G)) return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while(n > _0n){\n            if (n & _1n) p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n) p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null) invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0) return Point.ZERO;\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint)) throw new TypeError(\"ExtendedPoint expected\");\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint)) throw new TypeError(\"RistrettoPoint expected\");\n}\nfunction legacyRist() {\n    throw new Error(\"Legacy method: switch to RistrettoPoint\");\n}\nclass RistrettoPoint {\n    constructor(ep){\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_)) s_ = mod(-s_);\n        if (!Ns_D_is_sq) s = s_;\n        if (!Ns_D_is_sq) c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = \"RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint\";\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x)) x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv)) y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s)) s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P) throw new Error(\"Expected 0 < hex < P\");\n        if (!strict && y >= POW_2_256) throw new Error(\"Expected 0 < hex < 2**256\");\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid) throw new Error(\"Point.fromHex: invalid y coordinate\");\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point)) throw new Error(\"Expected Point instance\");\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\n\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\nfunction concatBytes(...arrays) {\n    arrays.every(abytes);\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);\n    return;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, \"0\");\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    abytes(uint8a);\n    return BigInt(\"0x\" + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (num === _0n) return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i)=>{\n        if (num === _0n) return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = x * x % P;\n    const b2 = x2 * x % P;\n    const b4 = pow2(b2, _2n) * b2 % P;\n    const b5 = pow2(b4, _1n) * x % P;\n    const b10 = pow2(b5, _5n) * b5 % P;\n    const b20 = pow2(b10, _10n) * b10 % P;\n    const b40 = pow2(b20, _20n) * b20 % P;\n    const b80 = pow2(b40, _40n) * b40 % P;\n    const b160 = pow2(b80, _80n) * b80 % P;\n    const b240 = pow2(b160, _80n) * b80 % P;\n    const b250 = pow2(b240, _10n) * b10 % P;\n    const pow_p_5_8 = pow2(b250, _2n) * x % P;\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2;\n    if (edIsNegative(x)) x = mod(-x);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for(let i = 0; i < b1.length; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = isBytes(hex) ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === \"number\" && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max) throw new TypeError(\"Specify max value\");\n    if (typeof num === \"number\" && Number.isSafeInteger(num)) num = BigInt(num);\n    if (typeof num === \"bigint\" && num < max) {\n        if (strict) {\n            if (_0n < num) return num;\n        } else {\n            if (_0n <= num) return num;\n        }\n    }\n    throw new TypeError(\"Expected valid scalar: 0 < scalar < max\");\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key = typeof key === \"bigint\" || typeof key === \"number\" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);\n    if (key.length !== 32) throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return {\n        head,\n        prefix,\n        scalar,\n        point,\n        pointBytes\n    };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== \"function\") throw new Error(\"utils.sha512Sync must be set to use sync methods\");\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nasync function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nasync function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return {\n        r,\n        s,\n        SB,\n        pub: publicKey,\n        msg: message\n    };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nasync function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nconst sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync\n};\nasync function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [\n        x_2,\n        x_3\n    ];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for(let t = BigInt(255 - 1); t >= _0n; t--){\n        const k_t = k >> t & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nconst curve25519 = {\n    BASE_POINT_U: \"0900000000000000000000000000000000000000000000000000000000000000\",\n    scalarMult (privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n) throw new Error(\"Invalid private or public key received\");\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase (privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    }\n};\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined\n};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        \"0100000000000000000000000000000000000000000000000000000000000000\",\n        \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n        \"0000000000000000000000000000000000000000000000000000000000000080\",\n        \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n        \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n        \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n    ],\n    hashToPrivateScalar: (hash)=>{\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024) throw new Error(\"Expected 40-1024 bytes of private key as per FIPS 186\");\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32)=>{\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        } else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        } else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: ()=>{\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages)=>{\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest(\"SHA-512\", message.buffer);\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash(\"sha512\").update(message).digest());\n        } else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute (windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get () {\n            return _sha512Sync;\n        },\n        set (val) {\n            if (!_sha512Sync) _sha512Sync = val;\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2VkMjU1MTlAMS43LjUvbm9kZV9tb2R1bGVzL0Bub2JsZS9lZDI1NTE5L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFFQUFxRSxHQUNoQztBQUNyQyxNQUFNQyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLE9BQU9KLE9BQU87QUFDcEIsTUFBTUssUUFBUUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3hCQyxHQUFHUixPQUFPLENBQUM7SUFDWFMsR0FBR1QsT0FBTztJQUNWVSxHQUFHVixPQUFPO0lBQ1ZXLEdBQUdQO0lBQ0hRLEdBQUdSO0lBQ0hTLEdBQUdiLE9BQU87SUFDVmMsSUFBSWQsT0FBTztJQUNYZSxJQUFJZixPQUFPO0FBQ2Y7QUFDaUI7QUFDakIsTUFBTWdCLFlBQVloQixPQUFPO0FBQ3pCLE1BQU1pQixVQUFVakIsT0FBTztBQUN2QixNQUFNa0IsU0FBU2xCLE9BQU87QUFDdEIsTUFBTW1CLG9CQUFvQm5CLE9BQU87QUFDakMsTUFBTW9CLG9CQUFvQnBCLE9BQU87QUFDakMsTUFBTXFCLGlCQUFpQnJCLE9BQU87QUFDOUIsTUFBTXNCLGlCQUFpQnRCLE9BQU87QUFDOUIsTUFBTXVCO0lBQ0ZDLFlBQVlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsQ0FBRTtRQUNwQixJQUFJLENBQUNILENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0E7SUFDYjtJQUNBLE9BQU9DLFdBQVdDLENBQUMsRUFBRTtRQUNqQixJQUFJLENBQUVBLENBQUFBLGFBQWFDLEtBQUksR0FBSTtZQUN2QixNQUFNLElB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QUFNVCxPQUFPRSxHQUFHLENBQUNVLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLFdBQVcxRCxRQUFRc0QsTUFBTTtZQUN2RSxPQUFPLElBQUk5SixXQUFXOEo7UUFDMUIsT0FDSyxJQUFJVCxPQUFPQyxJQUFJLEVBQUU7WUFDbEIsT0FBT3RKLFdBQVdnQixJQUFJLENBQUNxSSxPQUFPQyxJQUFJLENBQUNhLFVBQVUsQ0FBQyxVQUFVQyxNQUFNLENBQUM1RCxTQUFTMEQsTUFBTTtRQUNsRixPQUNLO1lBQ0QsTUFBTSxJQUFJdFIsTUFBTTtRQUNwQjtJQUNKO0lBQ0F5UixZQUFXblIsYUFBYSxDQUFDLEVBQUV3RyxRQUFRckssTUFBTXFELElBQUk7UUFDekMsTUFBTTRSLFNBQVM1SyxNQUFNbkssTUFBTSxDQUFDRixNQUFNcUQsSUFBSSxJQUFJZ0gsUUFBUSxJQUFJckssTUFBTXFLLE1BQU0zSyxDQUFDLEVBQUUySyxNQUFNMUssQ0FBQztRQUM1RXNWLE9BQU94TCxjQUFjLENBQUM1RjtRQUN0Qm9SLE9BQU90USxRQUFRLENBQUN4RztRQUNoQixPQUFPOFc7SUFDWDtJQUNBQyxZQUFZdEk7QUFDaEIsRUFBRTtBQUNGck8sT0FBTzRXLGdCQUFnQixDQUFDdEUsT0FBTztJQUMzQnFFLFlBQVk7UUFDUkUsY0FBYztRQUNkMVI7WUFDSSxPQUFPaU47UUFDWDtRQUNBaE4sS0FBSTBSLEdBQUc7WUFDSCxJQUFJLENBQUMxRSxhQUNEQSxjQUFjMEU7UUFDdEI7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrZWQyNTUxOUAxLjcuNS9ub2RlX21vZHVsZXMvQG5vYmxlL2VkMjU1MTkvbGliL2VzbS9pbmRleC5qcz9hOTNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1lZDI1NTE5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMTkgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgKiBhcyBub2RlQ3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfOG4gPSBCaWdJbnQoOCk7XG5jb25zdCBDVV9PID0gQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5Jyk7XG5jb25zdCBDVVJWRSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGE6IEJpZ0ludCgtMSksXG4gICAgZDogQmlnSW50KCczNzA5NTcwNTkzNDY2OTQzOTM0MzEzODA4MzUwODc1NDU2NTE4OTU0MjExMzg3OTg0MzIxOTAxNjM4ODc4NTUzMzA4NTk0MDI4MzU1NScpLFxuICAgIFA6IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKSxcbiAgICBsOiBDVV9PLFxuICAgIG46IENVX08sXG4gICAgaDogQmlnSW50KDgpLFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbn0pO1xuZXhwb3J0IHsgQ1VSVkUgfTtcbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbmNvbnN0IFNRUlRfRCA9IEJpZ0ludCgnNjg1MzQ3NTIxOTQ5NzU2MTU4MTU3OTM1NzI3MTE5NzYyNDY0MjQ4Mjc5MDA3OTc4NTY1MDE5NzA0Njk1ODIxNTI4OTY4NzYwNDc0MicpO1xuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IEJpZ0ludCgnNTQ0NjkzMDcwMDg5MDkzMTY5MjA5OTU4MTM4Njg3NDUxNDE2MDUzOTM1OTcyOTI5Mjc0NTY5MjEyMDUzMTI4OTYzMTE3MjEwMTc1NzgnKTtcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG5jb25zdCBEX01JTlVTX09ORV9TUSA9IEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbmNsYXNzIEV4dGVuZGVkUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHosIHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgdGhpcy50ID0gdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHRlbmRlZFBvaW50I2Zyb21BZmZpbmU6IGV4cGVjdGVkIFBvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkUG9pbnQuWkVSTztcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbmRlZFBvaW50KHAueCwgcC55LCBfMW4sIG1vZChwLnggKiBwLnkpKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQWZmaW5lQmF0Y2gocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC56KSk7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZUJhdGNoKHBvaW50cykubWFwKHRoaXMuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRFeHRQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgY29uc3QgWDFaMiA9IG1vZChYMSAqIFoyKTtcbiAgICAgICAgY29uc3QgWDJaMSA9IG1vZChYMiAqIFoxKTtcbiAgICAgICAgY29uc3QgWTFaMiA9IG1vZChZMSAqIFoyKTtcbiAgICAgICAgY29uc3QgWTJaMSA9IG1vZChZMiAqIFoxKTtcbiAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuZGVkUG9pbnQobW9kKC10aGlzLngpLCB0aGlzLnksIHRoaXMueiwgbW9kKC10aGlzLnQpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IE0gPSBtb2Q7XG4gICAgICAgIGNvbnN0IEEgPSBNKFgxICogWDEpO1xuICAgICAgICBjb25zdCBCID0gTShZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IE0oXzJuICogTShaMSAqIFoxKSk7XG4gICAgICAgIGNvbnN0IEQgPSBNKGEgKiBBKTtcbiAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgIGNvbnN0IEUgPSBNKE0oeDF5MSAqIHgxeTEpIC0gQSAtIEIpO1xuICAgICAgICBjb25zdCBHID0gRCArIEI7XG4gICAgICAgIGNvbnN0IEYgPSBHIC0gQztcbiAgICAgICAgY29uc3QgSCA9IEQgLSBCO1xuICAgICAgICBjb25zdCBYMyA9IE0oRSAqIEYpO1xuICAgICAgICBjb25zdCBZMyA9IE0oRyAqIEgpO1xuICAgICAgICBjb25zdCBUMyA9IE0oRSAqIEgpO1xuICAgICAgICBjb25zdCBaMyA9IE0oRiAqIEcpO1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuZGVkUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxLCB0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgYXNzZXJ0RXh0UG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIsIHQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgTSA9IG1vZDtcbiAgICAgICAgY29uc3QgQSA9IE0oWDEgKiBYMik7XG4gICAgICAgIGNvbnN0IEIgPSBNKFkxICogWTIpO1xuICAgICAgICBjb25zdCBDID0gTShUMSAqIGQgKiBUMik7XG4gICAgICAgIGNvbnN0IEQgPSBNKFoxICogWjIpO1xuICAgICAgICBjb25zdCBFID0gTSgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7XG4gICAgICAgIGNvbnN0IEYgPSBNKEQgLSBDKTtcbiAgICAgICAgY29uc3QgRyA9IE0oRCArIEMpO1xuICAgICAgICBjb25zdCBIID0gTShCIC0gYSAqIEEpO1xuICAgICAgICBjb25zdCBYMyA9IE0oRSAqIEYpO1xuICAgICAgICBjb25zdCBZMyA9IE0oRyAqIEgpO1xuICAgICAgICBjb25zdCBUMyA9IE0oRSAqIEgpO1xuICAgICAgICBjb25zdCBaMyA9IE0oRiAqIEcpO1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuZGVkUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBwcmVjb21wdXRlV2luZG93KFcpIHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IDEgKyAyNTYgLyBXO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAyICoqIChXIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHdOQUYobiwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgaWYgKCFhZmZpbmVQb2ludCAmJiB0aGlzLmVxdWFscyhFeHRlbmRlZFBvaW50LkJBU0UpKVxuICAgICAgICAgICAgYWZmaW5lUG9pbnQgPSBQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBXID0gKGFmZmluZVBvaW50ICYmIGFmZmluZVBvaW50Ll9XSU5ET1dfU0laRSkgfHwgMTtcbiAgICAgICAgaWYgKDI1NiAlIFcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQjd05BRjogSW52YWxpZCBwcmVjb21wdXRhdGlvbiB3aW5kb3csIG11c3QgYmUgcG93ZXIgb2YgMicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVjb21wdXRlcyA9IGFmZmluZVBvaW50ICYmIHBvaW50UHJlY29tcHV0ZXMuZ2V0KGFmZmluZVBvaW50KTtcbiAgICAgICAgaWYgKCFwcmVjb21wdXRlcykge1xuICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coVyk7XG4gICAgICAgICAgICBpZiAoYWZmaW5lUG9pbnQgJiYgVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzID0gRXh0ZW5kZWRQb2ludC5ub3JtYWxpemVaKHByZWNvbXB1dGVzKTtcbiAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChhZmZpbmVQb2ludCwgcHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwID0gRXh0ZW5kZWRQb2ludC5aRVJPO1xuICAgICAgICBsZXQgZiA9IEV4dGVuZGVkUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IDEgKyAyNTYgLyBXO1xuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxO1xuICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXh0ZW5kZWRQb2ludC5ub3JtYWxpemVaKFtwLCBmXSlbMF07XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhciwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud05BRihub3JtYWxpemVTY2FsYXIoc2NhbGFyLCBDVVJWRS5sKSwgYWZmaW5lUG9pbnQpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyLCBDVVJWRS5sLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IEcgPSBFeHRlbmRlZFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFAwID0gRXh0ZW5kZWRQb2ludC5aRVJPO1xuICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIFAwO1xuICAgICAgICBpZiAodGhpcy5lcXVhbHMoUDApIHx8IG4gPT09IF8xbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcy5lcXVhbHMoRykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKG4pO1xuICAgICAgICBsZXQgcCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKS5lcXVhbHMoRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICB9XG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmwgLyBfMm4pLmRvdWJsZSgpO1xuICAgICAgICBpZiAoQ1VSVkUubCAlIF8ybilcbiAgICAgICAgICAgIHAgPSBwLmFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHAuZXF1YWxzKEV4dGVuZGVkUG9pbnQuWkVSTyk7XG4gICAgfVxuICAgIHRvQWZmaW5lKGludlopIHtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpczAgPSB0aGlzLmVxdWFscyhFeHRlbmRlZFBvaW50LlpFUk8pO1xuICAgICAgICBpZiAoaW52WiA9PSBudWxsKVxuICAgICAgICAgICAgaW52WiA9IGlzMCA/IF84biA6IGludmVydCh6KTtcbiAgICAgICAgY29uc3QgYXggPSBtb2QoeCAqIGludlopO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaW52Wik7XG4gICAgICAgIGNvbnN0IHp6ID0gbW9kKHogKiBpbnZaKTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGF4LCBheSk7XG4gICAgfVxuICAgIGZyb21SaXN0cmV0dG9CeXRlcygpIHtcbiAgICAgICAgbGVnYWN5UmlzdCgpO1xuICAgIH1cbiAgICB0b1Jpc3RyZXR0b0J5dGVzKCkge1xuICAgICAgICBsZWdhY3lSaXN0KCk7XG4gICAgfVxuICAgIGZyb21SaXN0cmV0dG9IYXNoKCkge1xuICAgICAgICBsZWdhY3lSaXN0KCk7XG4gICAgfVxufVxuRXh0ZW5kZWRQb2ludC5CQVNFID0gbmV3IEV4dGVuZGVkUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG5FeHRlbmRlZFBvaW50LlpFUk8gPSBuZXcgRXh0ZW5kZWRQb2ludChfMG4sIF8xbiwgXzFuLCBfMG4pO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiBhc3NlcnRFeHRQb2ludChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRXh0ZW5kZWRQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFJzdFBvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSaXN0cmV0dG9Qb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Jpc3RyZXR0b1BvaW50IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBsZWdhY3lSaXN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGVnYWN5IG1ldGhvZDogc3dpdGNoIHRvIFJpc3RyZXR0b1BvaW50Jyk7XG59XG5jbGFzcyBSaXN0cmV0dG9Qb2ludCB7XG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgdGhpcy5lcCA9IGVwO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgICAgICBjb25zdCB7IGQgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCByID0gbW9kKFNRUlRfTTEgKiByMCAqIHIwKTtcbiAgICAgICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpO1xuICAgICAgICBsZXQgYyA9IEJpZ0ludCgtMSk7XG4gICAgICAgIGNvbnN0IEQgPSBtb2QoKGMgLSBkICogcikgKiBtb2QociArIGQpKTtcbiAgICAgICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpO1xuICAgICAgICBsZXQgc18gPSBtb2QocyAqIHIwKTtcbiAgICAgICAgaWYgKCFlZElzTmVnYXRpdmUoc18pKVxuICAgICAgICAgICAgc18gPSBtb2QoLXNfKTtcbiAgICAgICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICAgICAgcyA9IHNfO1xuICAgICAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgICAgICBjID0gcjtcbiAgICAgICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7XG4gICAgICAgIGNvbnN0IHMyID0gcyAqIHM7XG4gICAgICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTtcbiAgICAgICAgY29uc3QgVzEgPSBtb2QoTnQgKiBTUVJUX0FEX01JTlVTX09ORSk7XG4gICAgICAgIGNvbnN0IFcyID0gbW9kKF8xbiAtIHMyKTtcbiAgICAgICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpO1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuZGVkUG9pbnQobW9kKFcwICogVzMpLCBtb2QoVzIgKiBXMSksIG1vZChXMSAqIFczKSwgbW9kKFcwICogVzIpKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcyhoZXgsIDY0KTtcbiAgICAgICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IFIxID0gdGhpcy5jYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICAgICAgY29uc3QgcjIgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICBjb25zdCBSMiA9IHRoaXMuY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQoUjEuYWRkKFIyKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcyhoZXgsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZW1zZyA9ICdSaXN0cmV0dG9Qb2ludC5mcm9tSGV4OiB0aGUgaGV4IGlzIG5vdCB2YWxpZCBlbmNvZGluZyBvZiBSaXN0cmV0dG9Qb2ludCc7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4KTtcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKG51bWJlclRvMzJCeXRlc0xFKHMpLCBoZXgpIHx8IGVkSXNOZWdhdGl2ZShzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpO1xuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpO1xuICAgICAgICBjb25zdCB1MV8yID0gbW9kKHUxICogdTEpO1xuICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGEgKiBkICogdTFfMiAtIHUyXzIpO1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpO1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpO1xuICAgICAgICBjb25zdCBEeSA9IG1vZChJICogRHggKiB2KTtcbiAgICAgICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTtcbiAgICAgICAgaWYgKGVkSXNOZWdhdGl2ZSh4KSlcbiAgICAgICAgICAgIHggPSBtb2QoLXgpO1xuICAgICAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpO1xuICAgICAgICBjb25zdCB0ID0gbW9kKHggKiB5KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IGVkSXNOZWdhdGl2ZSh0KSB8fCB5ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQobmV3IEV4dGVuZGVkUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IHgsIHksIHosIHQgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZCh6ICsgeSkgKiBtb2QoeiAtIHkpKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoeCAqIHkpO1xuICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBpbnZzcXJ0IH0gPSBpbnZlcnRTcXJ0KG1vZCh1MSAqIHUyc3EpKTtcbiAgICAgICAgY29uc3QgRDEgPSBtb2QoaW52c3FydCAqIHUxKTtcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTtcbiAgICAgICAgY29uc3QgekludiA9IG1vZChEMSAqIEQyICogdCk7XG4gICAgICAgIGxldCBEO1xuICAgICAgICBpZiAoZWRJc05lZ2F0aXZlKHQgKiB6SW52KSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKHkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZCh4ICogU1FSVF9NMSk7XG4gICAgICAgICAgICB4ID0gX3g7XG4gICAgICAgICAgICB5ID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZElzTmVnYXRpdmUoeCAqIHpJbnYpKVxuICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIGxldCBzID0gbW9kKCh6IC0geSkgKiBEKTtcbiAgICAgICAgaWYgKGVkSXNOZWdhdGl2ZShzKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVG8zMkJ5dGVzTEUocyk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgYiA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBvbmUgPSBtb2QoYS54ICogYi55KSA9PT0gbW9kKGEueSAqIGIueCk7XG4gICAgICAgIGNvbnN0IHR3byA9IG1vZChhLnkgKiBiLnkpID09PSBtb2QoYS54ICogYi54KTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RyZXR0b1BvaW50KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQodGhpcy5lcC5tdWx0aXBseVVuc2FmZShzY2FsYXIpKTtcbiAgICB9XG59XG5SaXN0cmV0dG9Qb2ludC5CQVNFID0gbmV3IFJpc3RyZXR0b1BvaW50KEV4dGVuZGVkUG9pbnQuQkFTRSk7XG5SaXN0cmV0dG9Qb2ludC5aRVJPID0gbmV3IFJpc3RyZXR0b1BvaW50KEV4dGVuZGVkUG9pbnQuWkVSTyk7XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIFBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4LCBzdHJpY3QgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZCwgUCB9ID0gQ1VSVkU7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKGhleCwgMzIpO1xuICAgICAgICBjb25zdCBub3JtZWQgPSBoZXguc2xpY2UoKTtcbiAgICAgICAgbm9ybWVkWzMxXSA9IGhleFszMV0gJiB+MHg4MDtcbiAgICAgICAgY29uc3QgeSA9IGJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIHkgPj0gUClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMCA8IGhleCA8IFAnKTtcbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgeSA+PSBQT1dfMl8yNTYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDAgPCBoZXggPCAyKioyNTYnKTtcbiAgICAgICAgY29uc3QgeTIgPSBtb2QoeSAqIHkpO1xuICAgICAgICBjb25zdCB1ID0gbW9kKHkyIC0gXzFuKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZChkICogeTIgKyBfMW4pO1xuICAgICAgICBsZXQgeyBpc1ZhbGlkLCB2YWx1ZTogeCB9ID0gdXZSYXRpbyh1LCB2KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiBpbnZhbGlkIHkgY29vcmRpbmF0ZScpO1xuICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChoZXhbMzFdICYgMHg4MCkgIT09IDA7XG4gICAgICAgIGlmIChpc0xhc3RCeXRlT2RkICE9PSBpc1hPZGQpIHtcbiAgICAgICAgICAgIHggPSBtb2QoLXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdmF0ZUtleSkpLnBvaW50O1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IG51bWJlclRvMzJCeXRlc0xFKHRoaXMueSk7XG4gICAgICAgIGJ5dGVzWzMxXSB8PSB0aGlzLnggJiBfMW4gPyAweDgwIDogMDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpO1xuICAgIH1cbiAgICB0b1gyNTUxOSgpIHtcbiAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB1ID0gbW9kKChfMW4gKyB5KSAqIGludmVydChfMW4gLSB5KSk7XG4gICAgICAgIHJldHVybiBudW1iZXJUbzMyQnl0ZXNMRSh1KTtcbiAgICB9XG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgcmV0dXJuIEV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5pc1RvcnNpb25GcmVlKCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZCgtdGhpcy54KSwgdGhpcy55KTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBFeHRlbmRlZFBvaW50LmZyb21BZmZpbmUodGhpcykuYWRkKEV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShvdGhlcikpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKHRoaXMpLm11bHRpcGx5KHNjYWxhciwgdGhpcykudG9BZmZpbmUoKTtcbiAgICB9XG59XG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSk7XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuKTtcbmNsYXNzIFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCwgNjQpO1xuICAgICAgICBjb25zdCByID0gUG9pbnQuZnJvbUhleChieXRlcy5zbGljZSgwLCAzMiksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXJMRShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFBvaW50IGluc3RhbmNlJyk7XG4gICAgICAgIG5vcm1hbGl6ZVNjYWxhcihzLCBDVVJWRS5sLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdTguc2V0KHRoaXMuci50b1Jhd0J5dGVzKCkpO1xuICAgICAgICB1OC5zZXQobnVtYmVyVG8zMkJ5dGVzTEUodGhpcy5zKSwgMzIpO1xuICAgICAgICByZXR1cm4gdTg7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRXh0ZW5kZWRQb2ludCwgUG9pbnQsIFJpc3RyZXR0b1BvaW50LCBTaWduYXR1cmUgfTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbmZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGFycmF5cy5ldmVyeShhYnl0ZXMpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7XG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gbnVtYmVyVG8zMkJ5dGVzQkUobnVtKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gMzI7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW5ndGggKiAyLCAnMCcpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBudW1iZXJUbzMyQnl0ZXNMRShudW0pIHtcbiAgICByZXR1cm4gbnVtYmVyVG8zMkJ5dGVzQkUobnVtKS5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBlZElzTmVnYXRpdmUobnVtKSB7XG4gICAgcmV0dXJuIChtb2QobnVtKSAmIF8xbikgPT09IF8xbjtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRSh1aW50OGEpIHtcbiAgICBhYnl0ZXModWludDhhKTtcbiAgICByZXR1cm4gQmlnSW50KCcweCcgKyBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbSh1aW50OGEpLnJldmVyc2UoKSkpO1xufVxuY29uc3QgTUFYXzI1NUIgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuZnVuY3Rpb24gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIG1vZChieXRlc1RvTnVtYmVyTEUoYnl0ZXMpICYgTUFYXzI1NUIpO1xufVxuZnVuY3Rpb24gbW9kKGEsIGIgPSBDVVJWRS5QKSB7XG4gICAgY29uc3QgcmVzID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlcyA+PSBfMG4gPyByZXMgOiBiICsgcmVzO1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgXzFuKTtcbiAgICBjb25zdCBpbnZlcnRlZCA9IGludmVydChsYXN0TXVsdGlwbGllZCwgcCk7XG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gbW9kKGFjYyAqIHRtcFtpXSwgcCk7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgXzVuID0gQmlnSW50KDUpO1xuICAgIGNvbnN0IF8xMG4gPSBCaWdJbnQoMTApO1xuICAgIGNvbnN0IF8yMG4gPSBCaWdJbnQoMjApO1xuICAgIGNvbnN0IF80MG4gPSBCaWdJbnQoNDApO1xuICAgIGNvbnN0IF84MG4gPSBCaWdJbnQoODApO1xuICAgIGNvbnN0IHgyID0gKHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjIgPSAoeDIgKiB4KSAlIFA7XG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuKSAqIHgpICUgUDtcbiAgICBjb25zdCBiMTAgPSAocG93MihiNSwgXzVuKSAqIGI1KSAlIFA7XG4gICAgY29uc3QgYjIwID0gKHBvdzIoYjEwLCBfMTBuKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IGI0MCA9IChwb3cyKGIyMCwgXzIwbikgKiBiMjApICUgUDtcbiAgICBjb25zdCBiODAgPSAocG93MihiNDAsIF80MG4pICogYjQwKSAlIFA7XG4gICAgY29uc3QgYjE2MCA9IChwb3cyKGI4MCwgXzgwbikgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgXzgwbikgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjUwID0gKHBvdzIoYjI0MCwgXzEwbikgKiBiMTApICUgUDtcbiAgICBjb25zdCBwb3dfcF81XzggPSAocG93MihiMjUwLCBfMm4pICogeCkgJSBQO1xuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIHV2UmF0aW8odSwgdikge1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdik7XG4gICAgY29uc3QgdjcgPSBtb2QodjMgKiB2MyAqIHYpO1xuICAgIGNvbnN0IHBvdyA9IHBvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdyk7XG4gICAgY29uc3QgdngyID0gbW9kKHYgKiB4ICogeCk7XG4gICAgY29uc3Qgcm9vdDEgPSB4O1xuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBTUVJUX00xKTtcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTtcbiAgICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gbW9kKC11KTtcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIFNRUlRfTTEpO1xuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjtcbiAgICBpZiAoZWRJc05lZ2F0aXZlKHgpKVxuICAgICAgICB4ID0gbW9kKC14KTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmZ1bmN0aW9uIGludmVydFNxcnQobnVtYmVyKSB7XG4gICAgcmV0dXJuIHV2UmF0aW8oXzFuLCBudW1iZXIpO1xufVxuZnVuY3Rpb24gbW9kbExFKGhhc2gpIHtcbiAgICByZXR1cm4gbW9kKGJ5dGVzVG9OdW1iZXJMRShoYXNoKSwgQ1VSVkUubCk7XG59XG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQnl0ZXMoaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVzID0gaXNCeXRlcyhoZXgpID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgYnl0ZXMubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlc2ApO1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjYWxhcihudW0sIG1heCwgc3RyaWN0ID0gdHJ1ZSkge1xuICAgIGlmICghbWF4KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTcGVjaWZ5IG1heCB2YWx1ZScpO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKVxuICAgICAgICBudW0gPSBCaWdJbnQobnVtKTtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgbnVtIDwgbWF4KSB7XG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChfMG4gPCBudW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfMG4gPD0gbnVtKVxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgc2NhbGFyOiAwIDwgc2NhbGFyIDwgbWF4Jyk7XG59XG5mdW5jdGlvbiBhZGp1c3RCeXRlczI1NTE5KGJ5dGVzKSB7XG4gICAgYnl0ZXNbMF0gJj0gMjQ4O1xuICAgIGJ5dGVzWzMxXSAmPSAxMjc7XG4gICAgYnl0ZXNbMzFdIHw9IDY0O1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGRlY29kZVNjYWxhcjI1NTE5KG4pIHtcbiAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKGFkanVzdEJ5dGVzMjU1MTkoZW5zdXJlQnl0ZXMobiwgMzIpKSk7XG59XG5mdW5jdGlvbiBjaGVja1ByaXZhdGVLZXkoa2V5KSB7XG4gICAga2V5ID1cbiAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIGtleSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gbnVtYmVyVG8zMkJ5dGVzQkUobm9ybWFsaXplU2NhbGFyKGtleSwgUE9XXzJfMjU2KSlcbiAgICAgICAgICAgIDogZW5zdXJlQnl0ZXMoa2V5KTtcbiAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgMzIgYnl0ZXNgKTtcbiAgICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZ2V0S2V5RnJvbUhhc2goaGFzaGVkKSB7XG4gICAgY29uc3QgaGVhZCA9IGFkanVzdEJ5dGVzMjU1MTkoaGFzaGVkLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKDMyLCA2NCk7XG4gICAgY29uc3Qgc2NhbGFyID0gbW9kbExFKGhlYWQpO1xuICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuQkFTRS5tdWx0aXBseShzY2FsYXIpO1xuICAgIGNvbnN0IHBvaW50Qnl0ZXMgPSBwb2ludC50b1Jhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG59XG5sZXQgX3NoYTUxMlN5bmM7XG5mdW5jdGlvbiBzaGE1MTJzKC4uLm0pIHtcbiAgICBpZiAodHlwZW9mIF9zaGE1MTJTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V0aWxzLnNoYTUxMlN5bmMgbXVzdCBiZSBzZXQgdG8gdXNlIHN5bmMgbWV0aG9kcycpO1xuICAgIHJldHVybiBfc2hhNTEyU3luYyguLi5tKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV4dGVuZGVkUHVibGljS2V5KGtleSkge1xuICAgIHJldHVybiBnZXRLZXlGcm9tSGFzaChhd2FpdCB1dGlscy5zaGE1MTIoY2hlY2tQcml2YXRlS2V5KGtleSkpKTtcbn1cbmZ1bmN0aW9uIGdldEV4dGVuZGVkUHVibGljS2V5U3luYyhrZXkpIHtcbiAgICByZXR1cm4gZ2V0S2V5RnJvbUhhc2goc2hhNTEycyhjaGVja1ByaXZhdGVLZXkoa2V5KSkpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIChhd2FpdCBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2YXRlS2V5KSkucG9pbnRCeXRlcztcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY0tleVN5bmMocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleVN5bmMocHJpdmF0ZUtleSkucG9pbnRCeXRlcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpIHtcbiAgICBtZXNzYWdlID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgY29uc3QgeyBwcmVmaXgsIHNjYWxhciwgcG9pbnRCeXRlcyB9ID0gYXdhaXQgZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3QgciA9IG1vZGxMRShhd2FpdCB1dGlscy5zaGE1MTIocHJlZml4LCBtZXNzYWdlKSk7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHkocik7XG4gICAgY29uc3QgayA9IG1vZGxMRShhd2FpdCB1dGlscy5zaGE1MTIoUi50b1Jhd0J5dGVzKCksIHBvaW50Qnl0ZXMsIG1lc3NhZ2UpKTtcbiAgICBjb25zdCBzID0gbW9kKHIgKyBrICogc2NhbGFyLCBDVVJWRS5sKTtcbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShSLCBzKS50b1Jhd0J5dGVzKCk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtZXNzYWdlLCBwcml2YXRlS2V5KSB7XG4gICAgbWVzc2FnZSA9IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5U3luYyhwcml2YXRlS2V5KTtcbiAgICBjb25zdCByID0gbW9kbExFKHNoYTUxMnMocHJlZml4LCBtZXNzYWdlKSk7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHkocik7XG4gICAgY29uc3QgayA9IG1vZGxMRShzaGE1MTJzKFIudG9SYXdCeXRlcygpLCBwb2ludEJ5dGVzLCBtZXNzYWdlKSk7XG4gICAgY29uc3QgcyA9IG1vZChyICsgayAqIHNjYWxhciwgQ1VSVkUubCk7XG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoUiwgcykudG9SYXdCeXRlcygpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVZlcmlmaWNhdGlvbihzaWcsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIG1lc3NhZ2UgPSBlbnN1cmVCeXRlcyhtZXNzYWdlKTtcbiAgICBpZiAoIShwdWJsaWNLZXkgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgIHB1YmxpY0tleSA9IFBvaW50LmZyb21IZXgocHVibGljS2V5LCBmYWxzZSk7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUgPyBzaWcuYXNzZXJ0VmFsaWRpdHkoKSA6IFNpZ25hdHVyZS5mcm9tSGV4KHNpZyk7XG4gICAgY29uc3QgU0IgPSBFeHRlbmRlZFBvaW50LkJBU0UubXVsdGlwbHlVbnNhZmUocyk7XG4gICAgcmV0dXJuIHsgciwgcywgU0IsIHB1YjogcHVibGljS2V5LCBtc2c6IG1lc3NhZ2UgfTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFZlcmlmaWNhdGlvbihwdWJsaWNLZXksIHIsIFNCLCBoYXNoZWQpIHtcbiAgICBjb25zdCBrID0gbW9kbExFKGhhc2hlZCk7XG4gICAgY29uc3Qga0EgPSBFeHRlbmRlZFBvaW50LmZyb21BZmZpbmUocHVibGljS2V5KS5tdWx0aXBseVVuc2FmZShrKTtcbiAgICBjb25zdCBSa0EgPSBFeHRlbmRlZFBvaW50LmZyb21BZmZpbmUocikuYWRkKGtBKTtcbiAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5tdWx0aXBseVVuc2FmZShDVVJWRS5oKS5lcXVhbHMoRXh0ZW5kZWRQb2ludC5aRVJPKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCB7IHIsIFNCLCBtc2csIHB1YiB9ID0gcHJlcGFyZVZlcmlmaWNhdGlvbihzaWcsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgY29uc3QgaGFzaGVkID0gYXdhaXQgdXRpbHMuc2hhNTEyKHIudG9SYXdCeXRlcygpLCBwdWIudG9SYXdCeXRlcygpLCBtc2cpO1xuICAgIHJldHVybiBmaW5pc2hWZXJpZmljYXRpb24ocHViLCByLCBTQiwgaGFzaGVkKTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVN5bmMoc2lnLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCB7IHIsIFNCLCBtc2csIHB1YiB9ID0gcHJlcGFyZVZlcmlmaWNhdGlvbihzaWcsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgY29uc3QgaGFzaGVkID0gc2hhNTEycyhyLnRvUmF3Qnl0ZXMoKSwgcHViLnRvUmF3Qnl0ZXMoKSwgbXNnKTtcbiAgICByZXR1cm4gZmluaXNoVmVyaWZpY2F0aW9uKHB1YiwgciwgU0IsIGhhc2hlZCk7XG59XG5leHBvcnQgY29uc3Qgc3luYyA9IHtcbiAgICBnZXRFeHRlbmRlZFB1YmxpY0tleTogZ2V0RXh0ZW5kZWRQdWJsaWNLZXlTeW5jLFxuICAgIGdldFB1YmxpY0tleTogZ2V0UHVibGljS2V5U3luYyxcbiAgICBzaWduOiBzaWduU3luYyxcbiAgICB2ZXJpZnk6IHZlcmlmeVN5bmMsXG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlS2V5LCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCB7IGhlYWQgfSA9IGF3YWl0IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHUgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSkudG9YMjU1MTkoKTtcbiAgICByZXR1cm4gY3VydmUyNTUxOS5zY2FsYXJNdWx0KGhlYWQsIHUpO1xufVxuUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbmZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgY29uc3QgZHVtbXkgPSBtb2Qoc3dhcCAqICh4XzIgLSB4XzMpKTtcbiAgICB4XzIgPSBtb2QoeF8yIC0gZHVtbXkpO1xuICAgIHhfMyA9IG1vZCh4XzMgKyBkdW1teSk7XG4gICAgcmV0dXJuIFt4XzIsIHhfM107XG59XG5mdW5jdGlvbiBtb250Z29tZXJ5TGFkZGVyKHBvaW50VSwgc2NhbGFyKSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCB1ID0gbm9ybWFsaXplU2NhbGFyKHBvaW50VSwgUCk7XG4gICAgY29uc3QgayA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIsIFApO1xuICAgIGNvbnN0IGEyNCA9IEJpZ0ludCgxMjE2NjUpO1xuICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgbGV0IHhfMiA9IF8xbjtcbiAgICBsZXQgel8yID0gXzBuO1xuICAgIGxldCB4XzMgPSB1O1xuICAgIGxldCB6XzMgPSBfMW47XG4gICAgbGV0IHN3YXAgPSBfMG47XG4gICAgbGV0IHN3O1xuICAgIGZvciAobGV0IHQgPSBCaWdJbnQoMjU1IC0gMSk7IHQgPj0gXzBuOyB0LS0pIHtcbiAgICAgICAgY29uc3Qga190ID0gKGsgPj4gdCkgJiBfMW47XG4gICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgeF8yID0gc3dbMF07XG4gICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICAgICAgel8yID0gc3dbMF07XG4gICAgICAgIHpfMyA9IHN3WzFdO1xuICAgICAgICBzd2FwID0ga190O1xuICAgICAgICBjb25zdCBBID0geF8yICsgel8yO1xuICAgICAgICBjb25zdCBBQSA9IG1vZChBICogQSk7XG4gICAgICAgIGNvbnN0IEIgPSB4XzIgLSB6XzI7XG4gICAgICAgIGNvbnN0IEJCID0gbW9kKEIgKiBCKTtcbiAgICAgICAgY29uc3QgRSA9IEFBIC0gQkI7XG4gICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgIGNvbnN0IERBID0gbW9kKEQgKiBBKTtcbiAgICAgICAgY29uc3QgQ0IgPSBtb2QoQyAqIEIpO1xuICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICB4XzMgPSBtb2QoZGFjYiAqIGRhY2IpO1xuICAgICAgICB6XzMgPSBtb2QoeF8xICogbW9kKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgeF8yID0gbW9kKEFBICogQkIpO1xuICAgICAgICB6XzIgPSBtb2QoRSAqIChBQSArIG1vZChhMjQgKiBFKSkpO1xuICAgIH1cbiAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICB4XzIgPSBzd1swXTtcbiAgICB4XzMgPSBzd1sxXTtcbiAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICB6XzIgPSBzd1swXTtcbiAgICB6XzMgPSBzd1sxXTtcbiAgICBjb25zdCB7IHBvd19wXzVfOCwgYjIgfSA9IHBvd18yXzI1Ml8zKHpfMik7XG4gICAgY29uc3QgeHAyID0gbW9kKHBvdzIocG93X3BfNV84LCBCaWdJbnQoMykpICogYjIpO1xuICAgIHJldHVybiBtb2QoeF8yICogeHAyKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVVDb29yZGluYXRlKHUpIHtcbiAgICByZXR1cm4gbnVtYmVyVG8zMkJ5dGVzTEUobW9kKHUsIENVUlZFLlApKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcbiAgICBjb25zdCB1ID0gZW5zdXJlQnl0ZXModUVuYywgMzIpO1xuICAgIHVbMzFdICY9IDEyNztcbiAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKHUpO1xufVxuZXhwb3J0IGNvbnN0IGN1cnZlMjU1MTkgPSB7XG4gICAgQkFTRV9QT0lOVF9VOiAnMDkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpIHtcbiAgICAgICAgY29uc3QgdSA9IGRlY29kZVVDb29yZGluYXRlKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHAgPSBkZWNvZGVTY2FsYXIyNTUxOShwcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKHUsIHApO1xuICAgICAgICBpZiAocHUgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIG9yIHB1YmxpYyBrZXkgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVDb29yZGluYXRlKHB1KTtcbiAgICB9LFxuICAgIHNjYWxhck11bHRCYXNlKHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlMjU1MTkuc2NhbGFyTXVsdChwcml2YXRlS2V5LCBjdXJ2ZTI1NTE5LkJBU0VfUE9JTlRfVSk7XG4gICAgfSxcbn07XG5jb25zdCBjcnlwdG8gPSB7XG4gICAgbm9kZTogbm9kZUNyeXB0byxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgaGV4VG9CeXRlcyxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICBtb2QsXG4gICAgaW52ZXJ0LFxuICAgIFRPUlNJT05fU1VCR1JPVVA6IFtcbiAgICAgICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDM3YScsXG4gICAgICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAgICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICAgICAnZWNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY3ZicsXG4gICAgICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDNmYScsXG4gICAgXSxcbiAgICBoYXNoVG9Qcml2YXRlU2NhbGFyOiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA8IDQwIHx8IGhhc2gubGVuZ3RoID4gMTAyNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgNDAtMTAyNCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODYnKTtcbiAgICAgICAgcmV0dXJuIG1vZChieXRlc1RvTnVtYmVyTEUoaGFzaCksIENVUlZFLmwgLSBfMW4pICsgXzFuO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlscy5yYW5kb21CeXRlcygzMik7XG4gICAgfSxcbiAgICBzaGE1MTI6IGFzeW5jICguLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY29uY2F0Qnl0ZXMoLi4ubWVzc2FnZXMpO1xuICAgICAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuZGlnZXN0KCdTSEEtNTEyJywgbWVzc2FnZS5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvLm5vZGUuY3JlYXRlSGFzaCgnc2hhNTEyJykudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgc2hhNTEyIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcG9pbnQuZXF1YWxzKFBvaW50LkJBU0UpID8gcG9pbnQgOiBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGNhY2hlZC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgY2FjaGVkLm11bHRpcGx5KF8ybik7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfSxcbiAgICBzaGE1MTJTeW5jOiB1bmRlZmluZWQsXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXModXRpbHMsIHtcbiAgICBzaGE1MTJTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2hhNTEyU3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfc2hhNTEyU3luYylcbiAgICAgICAgICAgICAgICBfc2hhNTEyU3luYyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG4iXSwibmFtZXMiOlsibm9kZUNyeXB0byIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsIkNVX08iLCJDVVJWRSIsIk9iamVjdCIsImZyZWV6ZSIsImEiLCJkIiwiUCIsImwiLCJuIiwiaCIsIkd4IiwiR3kiLCJQT1dfMl8yNTYiLCJTUVJUX00xIiwiU1FSVF9EIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJFeHRlbmRlZFBvaW50IiwiY29uc3RydWN0b3IiLCJ4IiwieSIsInoiLCJ0IiwiZnJvbUFmZmluZSIsInAiLCJQb2ludCIsIlR5cGVFcnJvciIsImVxdWFscyIsIlpFUk8iLCJtb2QiLCJ0b0FmZmluZUJhdGNoIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImkiLCJ0b0FmZmluZSIsIm5vcm1hbGl6ZVoiLCJvdGhlciIsImFzc2VydEV4dFBvaW50IiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiWDFaMiIsIlgyWjEiLCJZMVoyIiwiWTJaMSIsIm5lZ2F0ZSIsImRvdWJsZSIsIk0iLCJBIiwiQiIsIkMiLCJEIiwieDF5MSIsIkUiLCJHIiwiRiIsIkgiLCJYMyIsIlkzIiwiVDMiLCJaMyIsImFkZCIsIlQxIiwiVDIiLCJzdWJ0cmFjdCIsInByZWNvbXB1dGVXaW5kb3ciLCJXIiwid2luZG93cyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwid05BRiIsImFmZmluZVBvaW50IiwiQkFTRSIsIl9XSU5ET1dfU0laRSIsIkVycm9yIiwicHJlY29tcHV0ZXMiLCJwb2ludFByZWNvbXB1dGVzIiwiZ2V0Iiwic2V0IiwiZiIsIndpbmRvd1NpemUiLCJtYXNrIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIm9mZnNldCIsIndiaXRzIiwiTnVtYmVyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJNYXRoIiwiYWJzIiwiY29uZDEiLCJjb25kMiIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5Iiwic2NhbGFyIiwibm9ybWFsaXplU2NhbGFyIiwibXVsdGlwbHlVbnNhZmUiLCJQMCIsImlzU21hbGxPcmRlciIsImlzVG9yc2lvbkZyZWUiLCJpbnZaIiwiaXMwIiwiaW52ZXJ0IiwiYXgiLCJheSIsInp6IiwiZnJvbVJpc3RyZXR0b0J5dGVzIiwibGVnYWN5UmlzdCIsInRvUmlzdHJldHRvQnl0ZXMiLCJmcm9tUmlzdHJldHRvSGFzaCIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJhc3NlcnRSc3RQb2ludCIsIlJpc3RyZXR0b1BvaW50IiwiZXAiLCJjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwIiwicjAiLCJyIiwiTnMiLCJjIiwiaXNWYWxpZCIsIk5zX0RfaXNfc3EiLCJ2YWx1ZSIsInMiLCJ1dlJhdGlvIiwic18iLCJlZElzTmVnYXRpdmUiLCJOdCIsInMyIiwiVzAiLCJXMSIsIlcyIiwiVzMiLCJoYXNoVG9DdXJ2ZSIsImhleCIsImVuc3VyZUJ5dGVzIiwicjEiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJzbGljZSIsIlIxIiwicjIiLCJSMiIsImZyb21IZXgiLCJlbXNnIiwiZXF1YWxCeXRlcyIsIm51bWJlclRvMzJCeXRlc0xFIiwidTEiLCJ1MiIsInUxXzIiLCJ1Ml8yIiwidiIsIkkiLCJpbnZlcnRTcXJ0IiwiRHgiLCJEeSIsInRvUmF3Qnl0ZXMiLCJ1MnNxIiwiaW52c3FydCIsIkQxIiwiRDIiLCJ6SW52IiwiX3giLCJfeSIsInRvSGV4IiwiYnl0ZXNUb0hleCIsInRvU3RyaW5nIiwiYiIsIm9uZSIsInR3byIsIldlYWtNYXAiLCJfc2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsInN0cmljdCIsIm5vcm1lZCIsImJ5dGVzVG9OdW1iZXJMRSIsInkyIiwidSIsImlzWE9kZCIsImlzTGFzdEJ5dGVPZGQiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJnZXRFeHRlbmRlZFB1YmxpY0tleSIsInBvaW50IiwiYnl0ZXMiLCJ0b1gyNTUxOSIsIlNpZ25hdHVyZSIsImFzc2VydFZhbGlkaXR5IiwidTgiLCJVaW50OEFycmF5IiwiaXNCeXRlcyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwibmFtZSIsImFieXRlcyIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwiZXZlcnkiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhcnIiLCJyZXN1bHQiLCJwYWQiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJwYWRTdGFydCIsImFzY2lpcyIsIl8wIiwiXzkiLCJhc2NpaVRvQmFzZTE2IiwiY2giLCJoZXhUb0J5dGVzIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwiY2hhciIsIm51bWJlclRvMzJCeXRlc0JFIiwibnVtIiwicmV2ZXJzZSIsInVpbnQ4YSIsIk1BWF8yNTVCIiwicmVzIiwibnVtYmVyIiwibW9kdWxvIiwicSIsIm0iLCJnY2QiLCJudW1zIiwidG1wIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpbnZlcnRlZCIsInJlZHVjZVJpZ2h0IiwicG93MiIsInBvd2VyIiwicG93XzJfMjUyXzMiLCJfNW4iLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwieDIiLCJiMiIsImI0IiwiYjUiLCJiMTAiLCJiMjAiLCJiNDAiLCJiODAiLCJiMTYwIiwiYjI0MCIsImIyNTAiLCJwb3dfcF81XzgiLCJ2MyIsInY3IiwicG93IiwidngyIiwicm9vdDEiLCJyb290MiIsInVzZVJvb3QxIiwidXNlUm9vdDIiLCJub1Jvb3QiLCJtb2RsTEUiLCJoYXNoIiwiYjEiLCJleHBlY3RlZExlbmd0aCIsIm1heCIsImlzU2FmZUludGVnZXIiLCJhZGp1c3RCeXRlczI1NTE5IiwiZGVjb2RlU2NhbGFyMjU1MTkiLCJjaGVja1ByaXZhdGVLZXkiLCJrZXkiLCJnZXRLZXlGcm9tSGFzaCIsImhhc2hlZCIsImhlYWQiLCJwcmVmaXgiLCJwb2ludEJ5dGVzIiwiX3NoYTUxMlN5bmMiLCJzaGE1MTJzIiwidXRpbHMiLCJzaGE1MTIiLCJnZXRFeHRlbmRlZFB1YmxpY0tleVN5bmMiLCJnZXRQdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXlTeW5jIiwic2lnbiIsIm1lc3NhZ2UiLCJSIiwiayIsInNpZ25TeW5jIiwicHJlcGFyZVZlcmlmaWNhdGlvbiIsInNpZyIsInB1YmxpY0tleSIsIlNCIiwicHViIiwibXNnIiwiZmluaXNoVmVyaWZpY2F0aW9uIiwia0EiLCJSa0EiLCJ2ZXJpZnkiLCJ2ZXJpZnlTeW5jIiwic3luYyIsImdldFNoYXJlZFNlY3JldCIsImN1cnZlMjU1MTkiLCJzY2FsYXJNdWx0IiwiY3N3YXAiLCJzd2FwIiwieF8yIiwieF8zIiwiZHVtbXkiLCJtb250Z29tZXJ5TGFkZGVyIiwicG9pbnRVIiwiYTI0IiwieF8xIiwiel8yIiwiel8zIiwic3ciLCJrX3QiLCJBQSIsIkJCIiwiREEiLCJDQiIsImRhY2IiLCJkYV9jYiIsInhwMiIsImVuY29kZVVDb29yZGluYXRlIiwiZGVjb2RlVUNvb3JkaW5hdGUiLCJ1RW5jIiwiQkFTRV9QT0lOVF9VIiwicHUiLCJzY2FsYXJNdWx0QmFzZSIsImNyeXB0byIsIm5vZGUiLCJ3ZWIiLCJzZWxmIiwiVE9SU0lPTl9TVUJHUk9VUCIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYnVmZmVyIiwicmFuZG9tUHJpdmF0ZUtleSIsIm1lc3NhZ2VzIiwic3VidGxlIiwiZGlnZXN0IiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsInByZWNvbXB1dGUiLCJjYWNoZWQiLCJzaGE1MTJTeW5jIiwiZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsInZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+ed25519@1.7.5/node_modules/@noble/ed25519/lib/esm/index.js\n");

/***/ })

};
;