"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readable-stream@3.6.2";
exports.ids = ["vendor-chunks/readable-stream@3.6.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

eval("\nconst codes = {};\nfunction createErrorType(code, message, Base) {\n    if (!Base) {\n        Base = Error;\n    }\n    function getMessage(arg1, arg2, arg3) {\n        if (typeof message === \"string\") {\n            return message;\n        } else {\n            return message(arg1, arg2, arg3);\n        }\n    }\n    class NodeError extends Base {\n        constructor(arg1, arg2, arg3){\n            super(getMessage(arg1, arg2, arg3));\n        }\n    }\n    NodeError.prototype.name = Base.name;\n    NodeError.prototype.code = code;\n    codes[code] = NodeError;\n}\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n    if (Array.isArray(expected)) {\n        const len = expected.length;\n        expected = expected.map((i)=>String(i));\n        if (len > 2) {\n            return `one of ${thing} ${expected.slice(0, len - 1).join(\", \")}, or ` + expected[len - 1];\n        } else if (len === 2) {\n            return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n        } else {\n            return `of ${thing} ${expected[0]}`;\n        }\n    } else {\n        return `of ${thing} ${String(expected)}`;\n    }\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n    if (this_len === undefined || this_len > str.length) {\n        this_len = str.length;\n    }\n    return str.substring(this_len - search.length, this_len) === search;\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n    if (typeof start !== \"number\") {\n        start = 0;\n    }\n    if (start + search.length > str.length) {\n        return false;\n    } else {\n        return str.indexOf(search, start) !== -1;\n    }\n}\ncreateErrorType(\"ERR_INVALID_OPT_VALUE\", function(name, value) {\n    return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType(\"ERR_INVALID_ARG_TYPE\", function(name, expected, actual) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === \"string\" && startsWith(expected, \"not \")) {\n        determiner = \"must not be\";\n        expected = expected.replace(/^not /, \"\");\n    } else {\n        determiner = \"must be\";\n    }\n    let msg;\n    if (endsWith(name, \" argument\")) {\n        // For cases like 'first argument'\n        msg = `The ${name} ${determiner} ${oneOf(expected, \"type\")}`;\n    } else {\n        const type = includes(name, \".\") ? \"property\" : \"argument\";\n        msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, \"type\")}`;\n    }\n    msg += `. Received type ${typeof actual}`;\n    return msg;\n}, TypeError);\ncreateErrorType(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\");\ncreateErrorType(\"ERR_METHOD_NOT_IMPLEMENTED\", function(name) {\n    return \"The \" + name + \" method is not implemented\";\n});\ncreateErrorType(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\");\ncreateErrorType(\"ERR_STREAM_DESTROYED\", function(name) {\n    return \"Cannot call \" + name + \" after a stream was destroyed\";\n});\ncreateErrorType(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\");\ncreateErrorType(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\");\ncreateErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\ncreateErrorType(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\ncreateErrorType(\"ERR_UNKNOWN_ENCODING\", function(arg) {\n    return \"Unknown encoding: \" + arg;\n}, TypeError);\ncreateErrorType(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\");\nmodule.exports.codes = codes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsUUFBUSxDQUFDO0FBRWYsU0FBU0MsZ0JBQWdCQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsSUFBSTtJQUMxQyxJQUFJLENBQUNBLE1BQU07UUFDVEEsT0FBT0M7SUFDVDtJQUVBLFNBQVNDLFdBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJO1FBQ25DLElBQUksT0FBT04sWUFBWSxVQUFVO1lBQy9CLE9BQU9BO1FBQ1QsT0FBTztZQUNMLE9BQU9BLFFBQVFJLE1BQU1DLE1BQU1DO1FBQzdCO0lBQ0Y7SUFFQSxNQUFNQyxrQkFBa0JOO1FBQ3RCTyxZQUFhSixJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxDQUFFO1lBQzdCLEtBQUssQ0FBQ0gsV0FBV0MsTUFBTUMsTUFBTUM7UUFDL0I7SUFDRjtJQUVBQyxVQUFVRSxTQUFTLENBQUNDLElBQUksR0FBR1QsS0FBS1MsSUFBSTtJQUNwQ0gsVUFBVUUsU0FBUyxDQUFDVixJQUFJLEdBQUdBO0lBRTNCRixLQUFLLENBQUNFLEtBQUssR0FBR1E7QUFDaEI7QUFFQSxxRUFBcUU7QUFDckUsU0FBU0ksTUFBTUMsUUFBUSxFQUFFQyxLQUFLO0lBQzVCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsV0FBVztRQUMzQixNQUFNSSxNQUFNSixTQUFTSyxNQUFNO1FBQzNCTCxXQUFXQSxTQUFTTSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUMsT0FBT0Q7UUFDdEMsSUFBSUgsTUFBTSxHQUFHO1lBQ1gsT0FBTyxDQUFDLE9BQU8sRUFBRUgsTUFBTSxDQUFDLEVBQUVELFNBQVNTLEtBQUssQ0FBQyxHQUFHTCxNQUFNLEdBQUdNLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUMvRFYsUUFBUSxDQUFDSSxNQUFNLEVBQUU7UUFD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RztJQUNuRCxPQUFPLHVCQUF1QkE7QUFDaEMsR0FBR047QUFDSHRDLGdCQUFnQixzQ0FBc0M7QUFFdEQ2QyxvQkFBb0IsR0FBRzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMuanM/OTE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvclxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZSAoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHN1cGVyKGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpO1xuICAgIH1cbiAgfVxuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKChpKSA9PiBTdHJpbmcoaSkpO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgICtcbiAgICAgICAgICAgICBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX0gb3IgJHtleHBlY3RlZFsxXX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke1N0cmluZyhleHBlY3RlZCl9YDtcbiAgfVxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG5cdHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuXHRpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcblx0XHR0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG5cdH1cblx0cmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJ1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICBsZXQgZGV0ZXJtaW5lcjtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIGxldCBtc2c7XG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9XG5cbiAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnXG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnXG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iXSwibmFtZXMiOlsiY29kZXMiLCJjcmVhdGVFcnJvclR5cGUiLCJjb2RlIiwibWVzc2FnZSIsIkJhc2UiLCJFcnJvciIsImdldE1lc3NhZ2UiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJOb2RlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm5hbWUiLCJvbmVPZiIsImV4cGVjdGVkIiwidGhpbmciLCJBcnJheSIsImlzQXJyYXkiLCJsZW4iLCJsZW5ndGgiLCJtYXAiLCJpIiwiU3RyaW5nIiwic2xpY2UiLCJqb2luIiwic3RhcnRzV2l0aCIsInN0ciIsInNlYXJjaCIsInBvcyIsInN1YnN0ciIsImVuZHNXaXRoIiwidGhpc19sZW4iLCJ1bmRlZmluZWQiLCJzdWJzdHJpbmciLCJpbmNsdWRlcyIsInN0YXJ0IiwiaW5kZXhPZiIsInZhbHVlIiwiVHlwZUVycm9yIiwiYWN0dWFsIiwiZGV0ZXJtaW5lciIsInJlcGxhY2UiLCJtc2ciLCJ0eXBlIiwiYXJnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/ var objectKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var key in obj)keys.push(key);\n    return keys;\n};\n/*</replacement>*/ module.exports = Duplex;\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js\");\n__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js\")(Duplex, Readable);\n{\n    // Allow the keys array to be GC'ed.\n    var keys = objectKeys(Writable.prototype);\n    for(var v = 0; v < keys.length; v++){\n        var method = keys[v];\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n    }\n}function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    this.allowHalfOpen = true;\n    if (options) {\n        if (options.readable === false) this.readable = false;\n        if (options.writable === false) this.writable = false;\n        if (options.allowHalfOpen === false) {\n            this.allowHalfOpen = false;\n            this.once(\"end\", onend);\n        }\n    }\n}\nObject.defineProperty(Duplex.prototype, \"writableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState.highWaterMark;\n    }\n});\nObject.defineProperty(Duplex.prototype, \"writableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState && this._writableState.getBuffer();\n    }\n});\nObject.defineProperty(Duplex.prototype, \"writableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState.length;\n    }\n});\n// the no-half-open enforcer\nfunction onend() {\n    // If the writable side ended, then we're ok.\n    if (this._writableState.ended) return;\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n    self.end();\n}\nObject.defineProperty(Duplex.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n        }\n        return this._readableState.destroyed && this._writableState.destroyed;\n    },\n    set: function set(value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n        }\n        // backward compatibility, the user is explicitly\n        // managing destroyed\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsdUVBQXVFO0FBQ3ZFLG9FQUFvRTtBQUNwRSxtRUFBbUU7QUFDbkUsWUFBWTtBQUVaO0FBRUEsZUFBZSxHQUNmLElBQUlBLGFBQWFDLE9BQU9DLElBQUksSUFBSSxTQUFVQyxHQUFHO0lBQzNDLElBQUlELE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSUUsT0FBT0QsSUFBS0QsS0FBS0csSUFBSSxDQUFDRDtJQUMvQixPQUFPRjtBQUNUO0FBQ0EsZ0JBQWdCLEdBRWhCSSxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCLElBQUlDLFdBQVdDLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCQSxtQkFBT0EsQ0FBQywrRkFBWUYsUUFBUUM7QUFDNUI7SUFDRSxvQ0FBb0M7SUFDcEMsSUFBSVAsT0FBT0YsV0FBV1csU0FBU0MsU0FBUztJQUN4QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVgsS0FBS1ksTUFBTSxFQUFFRCxJQUFLO1FBQ3BDLElBQUlFLFNBQVNiLElBQUksQ0FBQ1csRUFBRTtRQUNwQixJQUFJLENBQUNMLE9BQU9JLFNBQVMsQ0FBQ0csT0FBTyxFQUFFUCxPQUFPSSxTQUFTLENBQUNHLE9BQU8sR0FBR0osU0FBU0MsU0FBUyxDQUFDRyxPQUFPO0lBQ3RGO0FBQ0YsQ0FDQSxTQUFTUCxPQUFPUSxPQUFPO0lBQ3JCLElBQUksQ0FBRSxLQUFJLFlBQVlSLE1BQUssR0FBSSxPQUFPLElBQUlBLE9BQU9RO0lBQ2pEUCxTQUFTUSxJQUFJLENBQUMsSUFBSSxFQUFFRDtJQUNwQkwsU0FBU00sSUFBSSxDQUFDLElBQUksRUFBRUQ7SUFDcEIsSUFBSSxDQUFDRSxhQUFhLEdBQUc7SUFDckIsSUFBSUYsU0FBUztRQUNYLElBQUlBLFFBQVFHLFFBQVEsS0FBSyxPQUFPLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1FBQ2hELElBQUlILFFBQVFJLFFBQVEsS0FBSyxPQUFPLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1FBQ2hELElBQUlKLFFBQVFFLGFBQWEsS0FBSyxPQUFPO1lBQ25DLElBQUksQ0FBQ0EsYUFBYSxHQUFHO1lBQ3JCLElBQUksQ0FBQ0csSUFBSSxDQUFDLE9BQU9DO1FBQ25CO0lBQ0Y7QUFDRjtBQUNBckIsT0FBT3NCLGNBQWMsQ0FBQ2YsT0FBT0ksU0FBUyxFQUFFLHlCQUF5QjtJQUMvRCxxREFBcUQ7SUFDckQsbURBQW1EO0lBQ25ELHFCQUFxQjtJQUNyQlksWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsYUFBYTtJQUMxQztBQUNGO0FBQ0ExQixPQUFPc0IsY0FBYyxDQUFDZixPQUFPSSxTQUFTLEVBQUUsa0JBQWtCO0lBQ3hELHFEQUFxRDtJQUNyRCxtREFBbUQ7SUFDbkQscUJBQXFCO0lBQ3JCWSxZQUFZO0lBQ1pDLEtBQUssU0FBU0E7UUFDWixPQUFPLElBQUksQ0FBQ0MsY0FBYyxJQUFJLElBQUksQ0FBQ0EsY0FBYyxDQUFDRSxTQUFTO0lBQzdEO0FBQ0Y7QUFDQTNCLE9BQU9zQixjQUFjLENBQUNmLE9BQU9JLFNBQVMsRUFBRSxrQkFBa0I7SUFDeEQscURBQXFEO0lBQ3JELG1EQUFtRDtJQUNuRCxxQkFBcUI7SUFDckJZLFlBQVk7SUFDWkMsS0FBSyxTQUFTQTtRQUNaLE9BQU8sSUFBSSxDQUFDQyxjQUFjLENBQUNaLE1BQU07SUFDbkM7QUFDRjtBQUVBLDRCQUE0QjtBQUM1QixTQUFTUTtJQUNQLDZDQUE2QztJQUM3QyxJQUFJLElBQUksQ0FBQ0ksY0FBYyxDQUFDRyxLQUFLLEVBQUU7SUFFL0IsK0JBQStCO0lBQy9CLGdEQUFnRDtJQUNoREMsUUFBUUMsUUFBUSxDQUFDQyxTQUFTLElBQUk7QUFDaEM7QUFDQSxTQUFTQSxRQUFRQyxJQUFJO0lBQ25CQSxLQUFLQyxHQUFHO0FBQ1Y7QUFDQWpDLE9BQU9zQixjQUFjLENBQUNmLE9BQU9JLFNBQVMsRUFBRSxhQUFhO0lBQ25ELHFEQUFxRDtJQUNyRCxtREFBbUQ7SUFDbkQscUJBQXFCO0lBQ3JCWSxZQUFZO0lBQ1pDLEtBQUssU0FBU0E7UUFDWixJQUFJLElBQUksQ0FBQ1UsY0FBYyxLQUFLQyxhQUFhLElBQUksQ0FBQ1YsY0FBYyxLQUFLVSxXQUFXO1lBQzFFLE9BQU87UUFDVDtRQUNBLE9BQU8sSUFBSSxDQUFDRCxjQUFjLENBQUNFLFNBQVMsSUFBSSxJQUFJLENBQUNYLGNBQWMsQ0FBQ1csU0FBUztJQUN2RTtJQUNBQyxLQUFLLFNBQVNBLElBQUlDLEtBQUs7UUFDckIsb0NBQW9DO1FBQ3BDLCtCQUErQjtRQUMvQixJQUFJLElBQUksQ0FBQ0osY0FBYyxLQUFLQyxhQUFhLElBQUksQ0FBQ1YsY0FBYyxLQUFLVSxXQUFXO1lBQzFFO1FBQ0Y7UUFFQSxpREFBaUQ7UUFDakQscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0QsY0FBYyxDQUFDRSxTQUFTLEdBQUdFO1FBQ2hDLElBQUksQ0FBQ2IsY0FBYyxDQUFDVyxTQUFTLEdBQUdFO0lBQ2xDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcz84MzAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiXSwibmFtZXMiOlsib2JqZWN0S2V5cyIsIk9iamVjdCIsImtleXMiLCJvYmoiLCJrZXkiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyIsIkR1cGxleCIsIlJlYWRhYmxlIiwicmVxdWlyZSIsIldyaXRhYmxlIiwicHJvdG90eXBlIiwidiIsImxlbmd0aCIsIm1ldGhvZCIsIm9wdGlvbnMiLCJjYWxsIiwiYWxsb3dIYWxmT3BlbiIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJvbmNlIiwib25lbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJfd3JpdGFibGVTdGF0ZSIsImhpZ2hXYXRlck1hcmsiLCJnZXRCdWZmZXIiLCJlbmRlZCIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uRW5kTlQiLCJzZWxmIiwiZW5kIiwiX3JlYWRhYmxlU3RhdGUiLCJ1bmRlZmluZWQiLCJkZXN0cm95ZWQiLCJzZXQiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js\");\n__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js\")(PassThrough, Transform);\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6Qyx3QkFBd0I7QUFDeEIsNERBQTREO0FBQzVELHlDQUF5QztBQUV6QztBQUVBQSxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCLElBQUlDLFlBQVlDLG1CQUFPQSxDQUFDO0FBQ3hCQSxtQkFBT0EsQ0FBQywrRkFBWUYsYUFBYUM7QUFDakMsU0FBU0QsWUFBWUcsT0FBTztJQUMxQixJQUFJLENBQUUsS0FBSSxZQUFZSCxXQUFVLEdBQUksT0FBTyxJQUFJQSxZQUFZRztJQUMzREYsVUFBVUcsSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDdkI7QUFDQUgsWUFBWUssU0FBUyxDQUFDQyxVQUFVLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDOURBLEdBQUcsTUFBTUY7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanM/OTYyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlBhc3NUaHJvdWdoIiwiVHJhbnNmb3JtIiwicmVxdWlyZSIsIm9wdGlvbnMiLCJjYWxsIiwicHJvdG90eXBlIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n/*<replacement>*/ var Duplex;\n/*</replacement>*/ Readable.ReadableState = ReadableState;\n/*<replacement>*/ var EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n    return emitter.listeners(type).length;\n};\n/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar OurUint8Array = (typeof global !== \"undefined\" ? global :  false ? 0 : typeof self !== \"undefined\" ? self : {}).Uint8Array || function() {};\nfunction _uint8ArrayToBuffer(chunk) {\n    return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/ var debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n    debug = debugUtil.debuglog(\"stream\");\n} else {\n    debug = function debug() {};\n}\n/*</replacement>*/ var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js\"), getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js\")(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = [\n    \"error\",\n    \"close\",\n    \"destroy\",\n    \"pause\",\n    \"resume\"\n];\nfunction prependListener(emitter, event, fn) {\n    // Sadly this is not cacheable as some libraries bundle their own\n    // event emitter implementation with them.\n    if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);\n    else emitter._events[event] = [\n        fn,\n        emitter._events[event]\n    ];\n}\nfunction ReadableState(options, stream, isDuplex) {\n    Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n    options = options || {};\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream.\n    // These options can be provided separately as readableXXX and writableXXX.\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    this.highWaterMark = getHighWaterMark(this, options, \"readableHighWaterMark\", isDuplex);\n    // A linked list is used to store data chunks instead of an array because the\n    // linked list can remove elements from the beginning faster than\n    // array.shift()\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    // a flag to be able to tell if the event 'readable'/'data' is emitted\n    // immediately, or on a later tick.  We set this to true at first, because\n    // any actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first read call.\n    this.sync = true;\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n    this.paused = true;\n    // Should close be emitted on destroy. Defaults to true.\n    this.emitClose = options.emitClose !== false;\n    // Should .destroy() be called after 'end' (and potentially 'finish')\n    this.autoDestroy = !!options.autoDestroy;\n    // has it been destroyed\n    this.destroyed = false;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\nfunction Readable(options) {\n    Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n    if (!(this instanceof Readable)) return new Readable(options);\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the ReadableState constructor, at least with V8 6.5\n    var isDuplex = this instanceof Duplex;\n    this._readableState = new ReadableState(options, this, isDuplex);\n    // legacy\n    this.readable = true;\n    if (options) {\n        if (typeof options.read === \"function\") this._read = options.read;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n    }\n    Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        if (this._readableState === undefined) {\n            return false;\n        }\n        return this._readableState.destroyed;\n    },\n    set: function set(value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (!this._readableState) {\n            return;\n        }\n        // backward compatibility, the user is explicitly\n        // managing destroyed\n        this._readableState.destroyed = value;\n    }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    var state = this._readableState;\n    var skipChunkCheck;\n    if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n            encoding = encoding || state.defaultEncoding;\n            if (encoding !== state.encoding) {\n                chunk = Buffer.from(chunk, encoding);\n                encoding = \"\";\n            }\n            skipChunkCheck = true;\n        }\n    } else {\n        skipChunkCheck = true;\n    }\n    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n    return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n    debug(\"readableAddChunk\", chunk);\n    var state = stream._readableState;\n    if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n    } else {\n        var er;\n        if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n        if (er) {\n            errorOrDestroy(stream, er);\n        } else if (state.objectMode || chunk && chunk.length > 0) {\n            if (typeof chunk !== \"string\" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                chunk = _uint8ArrayToBuffer(chunk);\n            }\n            if (addToFront) {\n                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n                else addChunk(stream, state, chunk, true);\n            } else if (state.ended) {\n                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n            } else if (state.destroyed) {\n                return false;\n            } else {\n                state.reading = false;\n                if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n                    else maybeReadMore(stream, state);\n                } else {\n                    addChunk(stream, state, chunk, false);\n                }\n            }\n        } else if (!addToFront) {\n            state.reading = false;\n            maybeReadMore(stream, state);\n        }\n    }\n    // We can push more data if we are below the highWaterMark.\n    // Also, if we have no data yet, we can stand some more bytes.\n    // This is to work around cases where hwm=0, such as the repl.\n    return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n    if (state.flowing && state.length === 0 && !state.sync) {\n        state.awaitDrain = 0;\n        stream.emit(\"data\", chunk);\n    } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        if (state.needReadable) emitReadable(stream);\n    }\n    maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n    var er;\n    if (!_isUint8Array(chunk) && typeof chunk !== \"string\" && chunk !== undefined && !state.objectMode) {\n        er = new ERR_INVALID_ARG_TYPE(\"chunk\", [\n            \"string\",\n            \"Buffer\",\n            \"Uint8Array\"\n        ], chunk);\n    }\n    return er;\n}\nReadable.prototype.isPaused = function() {\n    return this._readableState.flowing === false;\n};\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    var decoder = new StringDecoder(enc);\n    this._readableState.decoder = decoder;\n    // If setEncoding(null), decoder.encoding equals utf8\n    this._readableState.encoding = this._readableState.decoder.encoding;\n    // Iterate over current buffer to convert already stored Buffers:\n    var p = this._readableState.buffer.head;\n    var content = \"\";\n    while(p !== null){\n        content += decoder.write(p.data);\n        p = p.next;\n    }\n    this._readableState.buffer.clear();\n    if (content !== \"\") this._readableState.buffer.push(content);\n    this._readableState.length = content.length;\n    return this;\n};\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n    if (n >= MAX_HWM) {\n        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n        n = MAX_HWM;\n    } else {\n        // Get the next highest power of 2 to prevent increasing hwm excessively in\n        // tiny amounts\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n    }\n    return n;\n}\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return 1;\n    if (n !== n) {\n        // Only flow one buffer at a time\n        if (state.flowing && state.length) return state.buffer.head.data.length;\n        else return state.length;\n    }\n    // If we're asking for more than the current hwm, then raise the hwm.\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state.length) return n;\n    // Don't have enough\n    if (!state.ended) {\n        state.needReadable = true;\n        return 0;\n    }\n    return state.length;\n}\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    debug(\"read\", n);\n    n = parseInt(n, 10);\n    var state = this._readableState;\n    var nOrig = n;\n    if (n !== 0) state.emittedReadable = false;\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        debug(\"read: emitReadable\", state.length, state.ended);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this);\n        return null;\n    }\n    n = howMuchToRead(n, state);\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        if (state.length === 0) endReadable(this);\n        return null;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    debug(\"need readable\", doRead);\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        debug(\"length less than watermark\", doRead);\n    }\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) {\n        doRead = false;\n        debug(\"reading or ended\", doRead);\n    } else if (doRead) {\n        debug(\"do read\");\n        state.reading = true;\n        state.sync = true;\n        // if the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n        // call internal read method\n        this._read(state.highWaterMark);\n        state.sync = false;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n    }\n    var ret;\n    if (n > 0) ret = fromList(n, state);\n    else ret = null;\n    if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        n = 0;\n    } else {\n        state.length -= n;\n        state.awaitDrain = 0;\n    }\n    if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n    }\n    if (ret !== null) this.emit(\"data\", ret);\n    return ret;\n};\nfunction onEofChunk(stream, state) {\n    debug(\"onEofChunk\");\n    if (state.ended) return;\n    if (state.decoder) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    if (state.sync) {\n        // if we are sync, wait until next tick to emit the data.\n        // Otherwise we risk emitting data in the flow()\n        // the readable code triggers during a read() call\n        emitReadable(stream);\n    } else {\n        // emit 'readable' now to make sure it gets picked up.\n        state.needReadable = false;\n        if (!state.emittedReadable) {\n            state.emittedReadable = true;\n            emitReadable_(stream);\n        }\n    }\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    var state = stream._readableState;\n    debug(\"emitReadable\", state.needReadable, state.emittedReadable);\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        debug(\"emitReadable\", state.flowing);\n        state.emittedReadable = true;\n        process.nextTick(emitReadable_, stream);\n    }\n}\nfunction emitReadable_(stream) {\n    var state = stream._readableState;\n    debug(\"emitReadable_\", state.destroyed, state.length, state.ended);\n    if (!state.destroyed && (state.length || state.ended)) {\n        stream.emit(\"readable\");\n        state.emittedReadable = false;\n    }\n    // The stream needs another readable event if\n    // 1. It is not flowing, as the flow mechanism will take\n    //    care of it.\n    // 2. It is not ended.\n    // 3. It is below the highWaterMark, so we can schedule\n    //    another readable later.\n    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n    flow(stream);\n}\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        state.readingMore = true;\n        process.nextTick(maybeReadMore_, stream, state);\n    }\n}\nfunction maybeReadMore_(stream, state) {\n    // Attempt to read more data if we should.\n    //\n    // The conditions for reading more data are (one of):\n    // - Not enough data buffered (state.length < state.highWaterMark). The loop\n    //   is responsible for filling the buffer with enough data if such data\n    //   is available. If highWaterMark is 0 and we are not in the flowing mode\n    //   we should _not_ attempt to buffer any extra data. We'll get more data\n    //   when the stream consumer calls read() instead.\n    // - No data in the buffer, and the stream is in flowing mode. In this mode\n    //   the loop below is responsible for ensuring read() is called. Failing to\n    //   call read here would abort the flow and there's no other mechanism for\n    //   continuing the flow if the stream consumer has just subscribed to the\n    //   'data' event.\n    //\n    // In addition to the above conditions to keep reading data, the following\n    // conditions prevent the data from being read:\n    // - The stream has ended (state.ended).\n    // - There is already a pending 'read' operation (state.reading). This is a\n    //   case where the the stream has called the implementation defined _read()\n    //   method, but they are processing the call asynchronously and have _not_\n    //   called push() with new data. In this case we skip performing more\n    //   read()s. The execution ends in this method again after the _read() ends\n    //   up calling push() with more data.\n    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){\n        var len = state.length;\n        debug(\"maybeReadMore read 0\");\n        stream.read(0);\n        if (len === state.length) break;\n    }\n    state.readingMore = false;\n}\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\"));\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n    switch(state.pipesCount){\n        case 0:\n            state.pipes = dest;\n            break;\n        case 1:\n            state.pipes = [\n                state.pipes,\n                dest\n            ];\n            break;\n        default:\n            state.pipes.push(dest);\n            break;\n    }\n    state.pipesCount += 1;\n    debug(\"pipe count=%d opts=%j\", state.pipesCount, pipeOpts);\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n    var endFn = doEnd ? onend : unpipe;\n    if (state.endEmitted) process.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable, unpipeInfo) {\n        debug(\"onunpipe\");\n        if (readable === src) {\n            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n            }\n        }\n    }\n    function onend() {\n        debug(\"onend\");\n        dest.end();\n    }\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on(\"drain\", ondrain);\n    var cleanedUp = false;\n    function cleanup() {\n        debug(\"cleanup\");\n        // cleanup event handlers once the pipe is broken\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        dest.removeListener(\"drain\", ondrain);\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n    src.on(\"data\", ondata);\n    function ondata(chunk) {\n        debug(\"ondata\");\n        var ret = dest.write(chunk);\n        debug(\"dest.write\", ret);\n        if (ret === false) {\n            // If the user unpiped during `dest.write()`, it is possible\n            // to get stuck in a permanently paused state if that write\n            // also returned false.\n            // => Check whether `dest` is still a piping destination.\n            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                debug(\"false write response, pause\", state.awaitDrain);\n                state.awaitDrain++;\n            }\n            src.pause();\n        }\n    }\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (EElistenerCount(dest, \"error\") === 0) errorOrDestroy(dest, er);\n    }\n    // Make sure our error handler is attached before userland ones.\n    prependListener(dest, \"error\", onerror);\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n    }\n    // tell the dest that it's being piped to\n    dest.emit(\"pipe\", src);\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n    }\n    return dest;\n};\nfunction pipeOnDrain(src) {\n    return function pipeOnDrainFunctionResult() {\n        var state = src._readableState;\n        debug(\"pipeOnDrain\", state.awaitDrain);\n        if (state.awaitDrain) state.awaitDrain--;\n        if (state.awaitDrain === 0 && EElistenerCount(src, \"data\")) {\n            state.flowing = true;\n            flow(src);\n        }\n    };\n}\nReadable.prototype.unpipe = function(dest) {\n    var state = this._readableState;\n    var unpipeInfo = {\n        hasUnpiped: false\n    };\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0) return this;\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes) return this;\n        if (!dest) dest = state.pipes;\n        // got a match.\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        if (dest) dest.emit(\"unpipe\", this, unpipeInfo);\n        return this;\n    }\n    // slow case. multiple pipe destinations.\n    if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        for(var i = 0; i < len; i++)dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false\n        });\n        return this;\n    }\n    // try to find the right one.\n    var index = indexOf(state.pipes, dest);\n    if (index === -1) return this;\n    state.pipes.splice(index, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1) state.pipes = state.pipes[0];\n    dest.emit(\"unpipe\", this, unpipeInfo);\n    return this;\n};\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n    var state = this._readableState;\n    if (ev === \"data\") {\n        // update readableListening so that resume() may be a no-op\n        // a few lines down. This is needed to support once('readable').\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        // Try start flowing on next tick if stream isn't explicitly paused\n        if (state.flowing !== false) this.resume();\n    } else if (ev === \"readable\") {\n        if (!state.endEmitted && !state.readableListening) {\n            state.readableListening = state.needReadable = true;\n            state.flowing = false;\n            state.emittedReadable = false;\n            debug(\"on readable\", state.length, state.reading);\n            if (state.length) {\n                emitReadable(this);\n            } else if (!state.reading) {\n                process.nextTick(nReadingNextTick, this);\n            }\n        }\n    }\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function(ev, fn) {\n    var res = Stream.prototype.removeListener.call(this, ev, fn);\n    if (ev === \"readable\") {\n        // We need to check if there is someone still listening to\n        // readable and reset the state. However this needs to happen\n        // after readable has been emitted but before I/O (nextTick) to\n        // support once('readable', fn) cycles. This means that calling\n        // resume within the same tick will have no\n        // effect.\n        process.nextTick(updateReadableListening, this);\n    }\n    return res;\n};\nReadable.prototype.removeAllListeners = function(ev) {\n    var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n    if (ev === \"readable\" || ev === undefined) {\n        // We need to check if there is someone still listening to\n        // readable and reset the state. However this needs to happen\n        // after readable has been emitted but before I/O (nextTick) to\n        // support once('readable', fn) cycles. This means that calling\n        // resume within the same tick will have no\n        // effect.\n        process.nextTick(updateReadableListening, this);\n    }\n    return res;\n};\nfunction updateReadableListening(self1) {\n    var state = self1._readableState;\n    state.readableListening = self1.listenerCount(\"readable\") > 0;\n    if (state.resumeScheduled && !state.paused) {\n        // flowing needs to be set to true now, otherwise\n        // the upcoming resume will not flow.\n        state.flowing = true;\n    // crude way to check if we should resume\n    } else if (self1.listenerCount(\"data\") > 0) {\n        self1.resume();\n    }\n}\nfunction nReadingNextTick(self1) {\n    debug(\"readable nexttick read 0\");\n    self1.read(0);\n}\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    var state = this._readableState;\n    if (!state.flowing) {\n        debug(\"resume\");\n        // we flow only if there is no one listening\n        // for readable, but we still have to call\n        // resume()\n        state.flowing = !state.readableListening;\n        resume(this, state);\n    }\n    state.paused = false;\n    return this;\n};\nfunction resume(stream, state) {\n    if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        process.nextTick(resume_, stream, state);\n    }\n}\nfunction resume_(stream, state) {\n    debug(\"resume\", state.reading);\n    if (!state.reading) {\n        stream.read(0);\n    }\n    state.resumeScheduled = false;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function() {\n    debug(\"call pause flowing=%j\", this._readableState.flowing);\n    if (this._readableState.flowing !== false) {\n        debug(\"pause\");\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n    }\n    this._readableState.paused = true;\n    return this;\n};\nfunction flow(stream) {\n    var state = stream._readableState;\n    debug(\"flow\", state.flowing);\n    while(state.flowing && stream.read() !== null);\n}\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    var _this = this;\n    var state = this._readableState;\n    var paused = false;\n    stream.on(\"end\", function() {\n        debug(\"wrapped end\");\n        if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) _this.push(chunk);\n        }\n        _this.push(null);\n    });\n    stream.on(\"data\", function(chunk) {\n        debug(\"wrapped data\");\n        if (state.decoder) chunk = state.decoder.write(chunk);\n        // don't skip over falsy values in objectMode\n        if (state.objectMode && (chunk === null || chunk === undefined)) return;\n        else if (!state.objectMode && (!chunk || !chunk.length)) return;\n        var ret = _this.push(chunk);\n        if (!ret) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for(var i in stream){\n        if (this[i] === undefined && typeof stream[i] === \"function\") {\n            this[i] = function methodWrap(method) {\n                return function methodWrapReturnFunction() {\n                    return stream[method].apply(stream, arguments);\n                };\n            }(i);\n        }\n    }\n    // proxy certain important events.\n    for(var n = 0; n < kProxyEvents.length; n++){\n        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n    }\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    this._read = function(n) {\n        debug(\"wrapped _read\", n);\n        if (paused) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    return this;\n};\nif (typeof Symbol === \"function\") {\n    Readable.prototype[Symbol.asyncIterator] = function() {\n        if (createReadableStreamAsyncIterator === undefined) {\n            createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n        }\n        return createReadableStreamAsyncIterator(this);\n    };\n}\nObject.defineProperty(Readable.prototype, \"readableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._readableState.highWaterMark;\n    }\n});\nObject.defineProperty(Readable.prototype, \"readableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._readableState && this._readableState.buffer;\n    }\n});\nObject.defineProperty(Readable.prototype, \"readableFlowing\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._readableState.flowing;\n    },\n    set: function set(state) {\n        if (this._readableState) {\n            this._readableState.flowing = state;\n        }\n    }\n});\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, \"readableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._readableState.length;\n    }\n});\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n    // nothing buffered\n    if (state.length === 0) return null;\n    var ret;\n    if (state.objectMode) ret = state.buffer.shift();\n    else if (!n || n >= state.length) {\n        // read it all, truncate the list\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else {\n        // read part of list\n        ret = state.buffer.consume(n, state.decoder);\n    }\n    return ret;\n}\nfunction endReadable(stream) {\n    var state = stream._readableState;\n    debug(\"endReadable\", state.endEmitted);\n    if (!state.endEmitted) {\n        state.ended = true;\n        process.nextTick(endReadableNT, state, stream);\n    }\n}\nfunction endReadableNT(state, stream) {\n    debug(\"endReadableNT\", state.endEmitted, state.length);\n    // Check that we didn't get one last unshift.\n    if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit(\"end\");\n        if (state.autoDestroy) {\n            // In case of duplex streams we need a way to detect\n            // if the writable side is ready for autoDestroy as well\n            var wState = stream._writableState;\n            if (!wState || wState.autoDestroy && wState.finished) {\n                stream.destroy();\n            }\n        }\n    }\n}\nif (typeof Symbol === \"function\") {\n    Readable.from = function(iterable, opts) {\n        if (from === undefined) {\n            from = __webpack_require__(/*! ./internal/streams/from */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js\");\n        }\n        return from(Readable, iterable, opts);\n    };\n}\nfunction indexOf(xs, x) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6QztBQUVBQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGVBQWUsR0FDZixJQUFJQztBQUNKLGdCQUFnQixHQUVoQkQsU0FBU0UsYUFBYSxHQUFHQTtBQUV6QixlQUFlLEdBQ2YsSUFBSUMsS0FBS0MsMERBQThCO0FBQ3ZDLElBQUlFLGtCQUFrQixTQUFTQSxnQkFBZ0JDLE9BQU8sRUFBRUMsSUFBSTtJQUMxRCxPQUFPRCxRQUFRRSxTQUFTLENBQUNELE1BQU1FLE1BQU07QUFDdkM7QUFDQSxnQkFBZ0IsR0FFaEIsZUFBZSxHQUNmLElBQUlDLFNBQVNQLG1CQUFPQSxDQUFDO0FBQ3JCLGdCQUFnQixHQUVoQixJQUFJUSxTQUFTUixvREFBd0I7QUFDckMsSUFBSVMsZ0JBQWdCLENBQUMsT0FBT0MsV0FBVyxjQUFjQSxTQUFTLE1BQWtCLEdBQWNDLENBQU1BLEdBQUcsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLENBQUMsR0FBR0MsVUFBVSxJQUFJLFlBQWE7QUFDM0ssU0FBU0Msb0JBQW9CQyxLQUFLO0lBQ2hDLE9BQU9QLE9BQU9RLElBQUksQ0FBQ0Q7QUFDckI7QUFDQSxTQUFTRSxjQUFjQyxHQUFHO0lBQ3hCLE9B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SUFBSyxJQUFJakMsSUFBSSxHQUFHa0MsSUFBSUYsR0FBRzNMLE1BQU0sRUFBRTJKLElBQUlrQyxHQUFHbEMsSUFBSztRQUN6QyxJQUFJZ0MsRUFBRSxDQUFDaEMsRUFBRSxLQUFLaUMsR0FBRyxPQUFPakM7SUFDMUI7SUFDQSxPQUFPLENBQUM7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanM/Nzc2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZztcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7XG5cbi8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyO1xuICAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgICAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG5cbiAgICAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWRhYmxlIiwiRHVwbGV4IiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsIkVFbGlzdGVuZXJDb3VudCIsImVtaXR0ZXIiLCJ0eXBlIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiU3RyZWFtIiwiQnVmZmVyIiwiT3VyVWludDhBcnJheSIsImdsb2JhbCIsIndpbmRvdyIsInNlbGYiLCJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsImNodW5rIiwiZnJvbSIsIl9pc1VpbnQ4QXJyYXkiLCJvYmoiLCJpc0J1ZmZlciIsImRlYnVnVXRpbCIsImRlYnVnIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiZGVzdHJveUltcGwiLCJfcmVxdWlyZSIsImdldEhpZ2hXYXRlck1hcmsiLCJfcmVxdWlyZSRjb2RlcyIsImNvZGVzIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GIiwiRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQiLCJFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UIiwiU3RyaW5nRGVjb2RlciIsImNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImVycm9yT3JEZXN0cm95Iiwia1Byb3h5RXZlbnRzIiwicHJlcGVuZExpc3RlbmVyIiwiZXZlbnQiLCJmbiIsIl9ldmVudHMiLCJvbiIsIkFycmF5IiwiaXNBcnJheSIsInVuc2hpZnQiLCJvcHRpb25zIiwic3RyZWFtIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwicmVhZGFibGVPYmplY3RNb2RlIiwiaGlnaFdhdGVyTWFyayIsImJ1ZmZlciIsInBpcGVzIiwicGlwZXNDb3VudCIsImZsb3dpbmciLCJlbmRlZCIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwicGF1c2VkIiwiZW1pdENsb3NlIiwiYXV0b0Rlc3Ryb3kiLCJkZXN0cm95ZWQiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiZW5jb2RpbmciLCJfcmVhZGFibGVTdGF0ZSIsInJlYWRhYmxlIiwicmVhZCIsIl9yZWFkIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiY2FsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSIsImdldCIsInVuZGVmaW5lZCIsInNldCIsInZhbHVlIiwiX3VuZGVzdHJveSIsInVuZGVzdHJveSIsImVyciIsImNiIiwicHVzaCIsInN0YXRlIiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJlciIsImNodW5rSW52YWxpZCIsImdldFByb3RvdHlwZU9mIiwiYWRkQ2h1bmsiLCJ3cml0ZSIsIm1heWJlUmVhZE1vcmUiLCJlbWl0IiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsImVuYyIsInAiLCJoZWFkIiwiY29udGVudCIsImRhdGEiLCJuZXh0IiwiY2xlYXIiLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJuIiwiaG93TXVjaFRvUmVhZCIsInBhcnNlSW50Iiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsInJldCIsImZyb21MaXN0IiwiZW5kIiwiZW1pdFJlYWRhYmxlXyIsInByb2Nlc3MiLCJuZXh0VGljayIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImxlbiIsInBpcGUiLCJkZXN0IiwicGlwZU9wdHMiLCJzcmMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwib25lbmQiLCJ1bnBpcGUiLCJvbmNlIiwib251bnBpcGUiLCJ1bnBpcGVJbmZvIiwiaGFzVW5waXBlZCIsImNsZWFudXAiLCJvbmRyYWluIiwicGlwZU9uRHJhaW4iLCJjbGVhbmVkVXAiLCJyZW1vdmVMaXN0ZW5lciIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZXJyb3IiLCJvbmRhdGEiLCJfd3JpdGFibGVTdGF0ZSIsIm5lZWREcmFpbiIsImluZGV4T2YiLCJwYXVzZSIsInJlc3VtZSIsInBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQiLCJkZXN0cyIsImkiLCJpbmRleCIsInNwbGljZSIsImV2IiwicmVzIiwibGlzdGVuZXJDb3VudCIsIm5SZWFkaW5nTmV4dFRpY2siLCJhZGRMaXN0ZW5lciIsInVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJyZXN1bWVfIiwid3JhcCIsIl90aGlzIiwibWV0aG9kV3JhcCIsIm1ldGhvZCIsIm1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbiIsImJpbmQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiX2Zyb21MaXN0Iiwic2hpZnQiLCJqb2luIiwiZmlyc3QiLCJjb25jYXQiLCJjb25zdW1lIiwiZW5kUmVhZGFibGVOVCIsIndTdGF0ZSIsImZpbmlzaGVkIiwiaXRlcmFibGUiLCJvcHRzIiwieHMiLCJ4IiwibCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes), ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js\")(Transform, Duplex);\nfunction afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (cb === null) {\n        return this.emit(\"error\", new ERR_MULTIPLE_CALLBACK());\n    }\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        this._read(rs.highWaterMark);\n    }\n}\nfunction Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n        afterTransform: afterTransform.bind(this),\n        needTransform: false,\n        transforming: false,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n    };\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    // When the writable side finishes, then flush out anything remaining.\n    this.on(\"prefinish\", prefinish);\n}\nfunction prefinish() {\n    var _this = this;\n    if (typeof this._flush === \"function\" && !this._readableState.destroyed) {\n        this._flush(function(er, data) {\n            done(_this, er, data);\n        });\n    } else {\n        done(this, null, null);\n    }\n}\nTransform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n};\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n    cb(new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\"));\n};\nTransform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n};\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n    var ts = this._transformState;\n    if (ts.writechunk !== null && !ts.transforming) {\n        ts.transforming = true;\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n    }\n};\nTransform.prototype._destroy = function(err, cb) {\n    Duplex.prototype._destroy.call(this, err, function(err2) {\n        cb(err2);\n    });\n};\nfunction done(stream, er, data) {\n    if (er) return stream.emit(\"error\", er);\n    if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n    // TODO(BridgeAR): Write a test for these two error cases\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n    return stream.push(null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsZ0VBQWdFO0FBQ2hFLDhEQUE4RDtBQUM5RCx1RUFBdUU7QUFDdkUsc0VBQXNFO0FBQ3RFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsZ0VBQWdFO0FBQ2hFLHFFQUFxRTtBQUNyRSxrRUFBa0U7QUFDbEUsMERBQTBEO0FBQzFELEVBQUU7QUFDRix5QkFBeUI7QUFDekIsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUsbUVBQW1FO0FBQ25FLGdFQUFnRTtBQUNoRSxvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEUscUVBQXFFO0FBQ3JFLHVFQUF1RTtBQUN2RSxxRUFBcUU7QUFDckUsc0VBQXNFO0FBQ3RFLEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSxvRUFBb0U7QUFDcEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSx3RUFBd0U7QUFDeEUsc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRSxvRUFBb0U7QUFDcEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix5RUFBeUU7QUFDekUseUVBQXlFO0FBQ3pFLCtEQUEr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QzlDUCxPQUFPa0MsU0FBUyxDQUFDSyxRQUFRLENBQUNuQixJQUFJLENBQUMsSUFBSSxFQUFFb0IsS0FBSyxTQUFVQyxJQUFJO1FBQ3REbEMsR0FBR2tDO0lBQ0w7QUFDRjtBQUNBLFNBQVNSLEtBQUtTLE1BQU0sRUFBRXhDLEVBQUUsRUFBRUMsSUFBSTtJQUM1QixJQUFJRCxJQUFJLE9BQU93QyxPQUFPakMsSUFBSSxDQUFDLFNBQVNQO0lBQ3BDLElBQUlDLFFBQVEsTUFDVixzREFBc0Q7SUFDdER1QyxPQUFPL0IsSUFBSSxDQUFDUjtJQUVkLHlEQUF5RDtJQUN6RCwwREFBMEQ7SUFDMUQsMENBQTBDO0lBQzFDLElBQUl1QyxPQUFPQyxjQUFjLENBQUMzQixNQUFNLEVBQUUsTUFBTSxJQUFJakI7SUFDNUMsSUFBSTJDLE9BQU9yQyxlQUFlLENBQUNDLFlBQVksRUFBRSxNQUFNLElBQUlSO0lBQ25ELE9BQU80QyxPQUFPL0IsSUFBSSxDQUFDO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanM/NzhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbClcbiAgICAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbClcbiAgICAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJUcmFuc2Zvcm0iLCJfcmVxdWlyZSRjb2RlcyIsInJlcXVpcmUiLCJjb2RlcyIsIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwiRVJSX01VTFRJUExFX0NBTExCQUNLIiwiRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyIsIkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCIsIkR1cGxleCIsImFmdGVyVHJhbnNmb3JtIiwiZXIiLCJkYXRhIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJ0cmFuc2Zvcm1pbmciLCJjYiIsIndyaXRlY2IiLCJlbWl0Iiwid3JpdGVjaHVuayIsInB1c2giLCJycyIsIl9yZWFkYWJsZVN0YXRlIiwicmVhZGluZyIsIm5lZWRSZWFkYWJsZSIsImxlbmd0aCIsImhpZ2hXYXRlck1hcmsiLCJfcmVhZCIsIm9wdGlvbnMiLCJjYWxsIiwiYmluZCIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwic3luYyIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsIm9uIiwicHJlZmluaXNoIiwiX3RoaXMiLCJkZXN0cm95ZWQiLCJkb25lIiwicHJvdG90eXBlIiwiY2h1bmsiLCJlbmNvZGluZyIsIl93cml0ZSIsIm4iLCJfZGVzdHJveSIsImVyciIsImVycjIiLCJzdHJlYW0iLCJfd3JpdGFibGVTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n/* <replacement> */ function WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n}\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n    var _this = this;\n    this.next = null;\n    this.entry = null;\n    this.finish = function() {\n        onCorkedFinish(_this, state);\n    };\n}\n/* </replacement> */ /*<replacement>*/ var Duplex;\n/*</replacement>*/ Writable.WritableState = WritableState;\n/*<replacement>*/ var internalUtil = {\n    deprecate: __webpack_require__(/*! util-deprecate */ \"(ssr)/./node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar OurUint8Array = (typeof global !== \"undefined\" ? global :  false ? 0 : typeof self !== \"undefined\" ? self : {}).Uint8Array || function() {};\nfunction _uint8ArrayToBuffer(chunk) {\n    return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js\"), getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js\")(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n    Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n    options = options || {};\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream,\n    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    this.highWaterMark = getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex);\n    // if _final has been called\n    this.finalCalled = false;\n    // drain event flag.\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n    // has it been destroyed\n    this.destroyed = false;\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n    // when true all writes will be buffered until .uncork() call\n    this.corked = 0;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n    // number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted\n    this.pendingcb = 0;\n    // emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams\n    this.prefinished = false;\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n    // Should close be emitted on destroy. Defaults to true.\n    this.emitClose = options.emitClose !== false;\n    // Should .destroy() be called after 'finish' (and potentially 'end')\n    this.autoDestroy = !!options.autoDestroy;\n    // count buffered requests\n    this.bufferedRequestCount = 0;\n    // allocate the first CorkedRequest, there is always\n    // one allocated and free to use, and we maintain at most two\n    this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n    var current = this.bufferedRequest;\n    var out = [];\n    while(current){\n        out.push(current);\n        current = current.next;\n    }\n    return out;\n};\n(function() {\n    try {\n        Object.defineProperty(WritableState.prototype, \"buffer\", {\n            get: internalUtil.deprecate(function writableStateBufferGetter() {\n                return this.getBuffer();\n            }, \"_writableState.buffer is deprecated. Use _writableState.getBuffer \" + \"instead.\", \"DEP0003\")\n        });\n    } catch (_) {}\n})();\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === \"function\" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === \"function\") {\n    realHasInstance = Function.prototype[Symbol.hasInstance];\n    Object.defineProperty(Writable, Symbol.hasInstance, {\n        value: function value(object) {\n            if (realHasInstance.call(this, object)) return true;\n            if (this !== Writable) return false;\n            return object && object._writableState instanceof WritableState;\n        }\n    });\n} else {\n    realHasInstance = function realHasInstance(object) {\n        return object instanceof this;\n    };\n}\nfunction Writable(options) {\n    Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n    // Writable ctor is applied to Duplexes, too.\n    // `realHasInstance` is necessary because using plain `instanceof`\n    // would return false, as no `_writableState` property is attached.\n    // Trying to use the custom `instanceof` for Writable here will also break the\n    // Node.js LazyTransform implementation, which has a non-trivial getter for\n    // `_writableState` that would lead to infinite recursion.\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the WritableState constructor, at least with V8 6.5\n    var isDuplex = this instanceof Duplex;\n    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n    this._writableState = new WritableState(options, this, isDuplex);\n    // legacy.\n    this.writable = true;\n    if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n    }\n    Stream.call(this);\n}\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n    var er = new ERR_STREAM_WRITE_AFTER_END();\n    // TODO: defer error events consistently everywhere, not just the cb\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n}\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n    var er;\n    if (chunk === null) {\n        er = new ERR_STREAM_NULL_VALUES();\n    } else if (typeof chunk !== \"string\" && !state.objectMode) {\n        er = new ERR_INVALID_ARG_TYPE(\"chunk\", [\n            \"string\",\n            \"Buffer\"\n        ], chunk);\n    }\n    if (er) {\n        errorOrDestroy(stream, er);\n        process.nextTick(cb, er);\n        return false;\n    }\n    return true;\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n    var isBuf = !state.objectMode && _isUint8Array(chunk);\n    if (isBuf && !Buffer.isBuffer(chunk)) {\n        chunk = _uint8ArrayToBuffer(chunk);\n    }\n    if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (isBuf) encoding = \"buffer\";\n    else if (!encoding) encoding = state.defaultEncoding;\n    if (typeof cb !== \"function\") cb = nop;\n    if (state.ending) writeAfterEnd(this, cb);\n    else if (isBuf || validChunk(this, state, chunk, cb)) {\n        state.pendingcb++;\n        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n    }\n    return ret;\n};\nWritable.prototype.cork = function() {\n    this._writableState.corked++;\n};\nWritable.prototype.uncork = function() {\n    var state = this._writableState;\n    if (state.corked) {\n        state.corked--;\n        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n    }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    // node::ParseEncoding() requires lower case.\n    if (typeof encoding === \"string\") encoding = encoding.toLowerCase();\n    if (!([\n        \"hex\",\n        \"utf8\",\n        \"utf-8\",\n        \"ascii\",\n        \"binary\",\n        \"base64\",\n        \"ucs2\",\n        \"ucs-2\",\n        \"utf16le\",\n        \"utf-16le\",\n        \"raw\"\n    ].indexOf((encoding + \"\").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n    this._writableState.defaultEncoding = encoding;\n    return this;\n};\nObject.defineProperty(Writable.prototype, \"writableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState && this._writableState.getBuffer();\n    }\n});\nfunction decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === \"string\") {\n        chunk = Buffer.from(chunk, encoding);\n    }\n    return chunk;\n}\nObject.defineProperty(Writable.prototype, \"writableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState.highWaterMark;\n    }\n});\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n    if (!isBuf) {\n        var newChunk = decodeChunk(state, chunk, encoding);\n        if (chunk !== newChunk) {\n            isBuf = true;\n            encoding = \"buffer\";\n            chunk = newChunk;\n        }\n    }\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = {\n            chunk: chunk,\n            encoding: encoding,\n            isBuf: isBuf,\n            callback: cb,\n            next: null\n        };\n        if (last) {\n            last.next = state.lastBufferedRequest;\n        } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n        }\n        state.bufferedRequestCount += 1;\n    } else {\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n    }\n    return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n    else if (writev) stream._writev(chunk, state.onwrite);\n    else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n    --state.pendingcb;\n    if (sync) {\n        // defer the callback if we are being called synchronously\n        // to avoid piling up things on the stack\n        process.nextTick(cb, er);\n        // this can emit finish, and it will always happen\n        // after error\n        process.nextTick(finishMaybe, stream, state);\n        stream._writableState.errorEmitted = true;\n        errorOrDestroy(stream, er);\n    } else {\n        // the caller expect this to happen before if\n        // it is async\n        cb(er);\n        stream._writableState.errorEmitted = true;\n        errorOrDestroy(stream, er);\n        // this can emit finish, but finish must\n        // always follow error\n        finishMaybe(stream, state);\n    }\n}\nfunction onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    if (typeof cb !== \"function\") throw new ERR_MULTIPLE_CALLBACK();\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb);\n    else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(state) || stream.destroyed;\n        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            process.nextTick(afterWrite, stream, state, finished, cb);\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}\nfunction afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n    }\n}\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n    if (stream._writev && entry && entry.next) {\n        // Fast case, write everything using _writev()\n        var l = state.bufferedRequestCount;\n        var buffer = new Array(l);\n        var holder = state.corkedRequestsFree;\n        holder.entry = entry;\n        var count = 0;\n        var allBuffers = true;\n        while(entry){\n            buffer[count] = entry;\n            if (!entry.isBuf) allBuffers = false;\n            entry = entry.next;\n            count += 1;\n        }\n        buffer.allBuffers = allBuffers;\n        doWrite(stream, state, true, state.length, buffer, \"\", holder.finish);\n        // doWrite is almost always async, defer these to save a bit of time\n        // as the hot path ends with doWrite\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n        if (holder.next) {\n            state.corkedRequestsFree = holder.next;\n            holder.next = null;\n        } else {\n            state.corkedRequestsFree = new CorkedRequest(state);\n        }\n        state.bufferedRequestCount = 0;\n    } else {\n        // Slow case, write chunks one-by-one\n        while(entry){\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            state.bufferedRequestCount--;\n            // if we didn't call the onwrite immediately, then\n            // it means that we need to wait until it does.\n            // also, that means that the chunk and cb are currently\n            // being processed, so move the buffer counter past them.\n            if (state.writing) {\n                break;\n            }\n        }\n        if (entry === null) state.lastBufferedRequest = null;\n    }\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n    cb(new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\"));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n    // .end() fully uncorks\n    if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n    }\n    // ignore unnecessary end() calls.\n    if (!state.ending) endWritable(this, state, cb);\n    return this;\n};\nObject.defineProperty(Writable.prototype, \"writableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        return this._writableState.length;\n    }\n});\nfunction needFinish(state) {\n    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n    stream._final(function(err) {\n        state.pendingcb--;\n        if (err) {\n            errorOrDestroy(stream, err);\n        }\n        state.prefinished = true;\n        stream.emit(\"prefinish\");\n        finishMaybe(stream, state);\n    });\n}\nfunction prefinish(stream, state) {\n    if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n            state.pendingcb++;\n            state.finalCalled = true;\n            process.nextTick(callFinal, stream, state);\n        } else {\n            state.prefinished = true;\n            stream.emit(\"prefinish\");\n        }\n    }\n}\nfunction finishMaybe(stream, state) {\n    var need = needFinish(state);\n    if (need) {\n        prefinish(stream, state);\n        if (state.pendingcb === 0) {\n            state.finished = true;\n            stream.emit(\"finish\");\n            if (state.autoDestroy) {\n                // In case of duplex streams we need a way to detect\n                // if the readable side is ready for autoDestroy as well\n                var rState = stream._readableState;\n                if (!rState || rState.autoDestroy && rState.endEmitted) {\n                    stream.destroy();\n                }\n            }\n        }\n    }\n    return need;\n}\nfunction endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) process.nextTick(cb);\n        else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n    stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n    var entry = corkReq.entry;\n    corkReq.entry = null;\n    while(entry){\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n    }\n    // reuse the free corkReq.\n    state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n        if (this._writableState === undefined) {\n            return false;\n        }\n        return this._writableState.destroyed;\n    },\n    set: function set(value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (!this._writableState) {\n            return;\n        }\n        // backward compatibility, the user is explicitly\n        // managing destroyed\n        this._writableState.destroyed = value;\n    }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6Qyx1Q0FBdUM7QUFDdkMsd0VBQXdFO0FBQ3hFLDBDQUEwQztBQUUxQztBQUVBQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGlCQUFpQixHQUNqQixTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsRUFBRTtJQUNuQyxJQUFJLENBQUNGLEtBQUssR0FBR0E7SUFDYixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDRSxRQUFRLEdBQUdEO0lBQ2hCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0FBQ2Q7QUFFQSx1Q0FBdUM7QUFDdkMsZ0RBQWdEO0FBQ2hELFNBQVNDLGNBQWNDLEtBQUs7SUFDMUIsSUFBSUMsUUFBUSxJQUFJO0lBQ2hCLElBQUksQ0FBQ0gsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDSSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNaQyxlQUFlSCxPQUFPRDtJQUN4QjtBQUNGO0FBQ0Esa0JBQWtCLEdBRWxCLGVBQWUsR0FDZixJQUFJSztBQUNKLGdCQUFnQixHQUVoQmIsU0FBU2MsYUFBYSxHQUFHQTtBQUV6QixlQUFlLEdBQ2YsSUFBSUMsZUFB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c291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz9iYjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KS5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuZnVuY3Rpb24gbm9wKCkge31cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTtcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG5cbiAgLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJXcml0YWJsZSIsIldyaXRlUmVxIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwiY2FsbGJhY2siLCJuZXh0IiwiQ29ya2VkUmVxdWVzdCIsInN0YXRlIiwiX3RoaXMiLCJlbnRyeSIsImZpbmlzaCIsIm9uQ29ya2VkRmluaXNoIiwiRHVwbGV4IiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsInJlcXVpcmUiLCJTdHJlYW0iLCJCdWZmZXIiLCJPdXJVaW50OEFycmF5IiwiZ2xvYmFsIiwid2luZG93Iiwic2VsZiIsIlVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiZnJvbSIsIl9pc1VpbnQ4QXJyYXkiLCJvYmoiLCJpc0J1ZmZlciIsImRlc3Ryb3lJbXBsIiwiX3JlcXVpcmUiLCJnZXRIaWdoV2F0ZXJNYXJrIiwiX3JlcXVpcmUkY29kZXMiLCJjb2RlcyIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQiLCJFUlJfTVVMVElQTEVfQ0FMTEJBQ0siLCJFUlJfU1RSRUFNX0NBTk5PVF9QSVBFIiwiRVJSX1NUUkVBTV9ERVNUUk9ZRUQiLCJFUlJfU1RSRUFNX05VTExfVkFMVUVTIiwiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQiLCJFUlJfVU5LTk9XTl9FTkNPRElORyIsImVycm9yT3JEZXN0cm95Iiwibm9wIiwib3B0aW9ucyIsInN0cmVhbSIsImlzRHVwbGV4Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImhpZ2hXYXRlck1hcmsiLCJmaW5hbENhbGxlZCIsIm5lZWREcmFpbiIsImVuZGluZyIsImVuZGVkIiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJsZW5ndGgiLCJ3cml0aW5nIiwiY29ya2VkIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwiZXIiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwicHJlZmluaXNoZWQiLCJlcnJvckVtaXR0ZWQiLCJlbWl0Q2xvc2UiLCJhdXRvRGVzdHJveSIsImJ1ZmZlcmVkUmVxdWVzdENvdW50IiwiY29ya2VkUmVxdWVzdHNGcmVlIiwicHJvdG90eXBlIiwiZ2V0QnVmZmVyIiwiY3VycmVudCIsIm91dCIsInB1c2giLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIndyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiU3ltYm9sIiwiaGFzSW5zdGFuY2UiLCJGdW5jdGlvbiIsInZhbHVlIiwib2JqZWN0IiwiY2FsbCIsIl93cml0YWJsZVN0YXRlIiwid3JpdGFibGUiLCJ3cml0ZSIsIl93cml0ZSIsIndyaXRldiIsIl93cml0ZXYiLCJkZXN0cm95IiwiX2Rlc3Ryb3kiLCJmaW5hbCIsIl9maW5hbCIsInBpcGUiLCJ3cml0ZUFmdGVyRW5kIiwicHJvY2VzcyIsIm5leHRUaWNrIiwidmFsaWRDaHVuayIsInJldCIsImlzQnVmIiwid3JpdGVPckJ1ZmZlciIsImNvcmsiLCJ1bmNvcmsiLCJjbGVhckJ1ZmZlciIsInNldERlZmF1bHRFbmNvZGluZyIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsImVudW1lcmFibGUiLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwibGVuIiwibGFzdCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiZW1pdCIsImwiLCJidWZmZXIiLCJBcnJheSIsImhvbGRlciIsImNvdW50IiwiYWxsQnVmZmVycyIsImVuZCIsInVuZGVmaW5lZCIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwiZXJyIiwicHJlZmluaXNoIiwibmVlZCIsInJTdGF0ZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsIm9uY2UiLCJjb3JrUmVxIiwic2V0IiwiX3VuZGVzdHJveSIsInVuZGVzdHJveSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nvar kLastResolve = Symbol(\"lastResolve\");\nvar kLastReject = Symbol(\"lastReject\");\nvar kError = Symbol(\"error\");\nvar kEnded = Symbol(\"ended\");\nvar kLastPromise = Symbol(\"lastPromise\");\nvar kHandlePromise = Symbol(\"handlePromise\");\nvar kStream = Symbol(\"stream\");\nfunction createIterResult(value, done) {\n    return {\n        value: value,\n        done: done\n    };\n}\nfunction readAndResolve(iter) {\n    var resolve = iter[kLastResolve];\n    if (resolve !== null) {\n        var data = iter[kStream].read();\n        // we defer if data is null\n        // we can be expecting either 'end' or\n        // 'error'\n        if (data !== null) {\n            iter[kLastPromise] = null;\n            iter[kLastResolve] = null;\n            iter[kLastReject] = null;\n            resolve(createIterResult(data, false));\n        }\n    }\n}\nfunction onReadable(iter) {\n    // we wait for the next tick, because it might\n    // emit an error with process.nextTick\n    process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n    return function(resolve, reject) {\n        lastPromise.then(function() {\n            if (iter[kEnded]) {\n                resolve(createIterResult(undefined, true));\n                return;\n            }\n            iter[kHandlePromise](resolve, reject);\n        }, reject);\n    };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function() {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n    get stream () {\n        return this[kStream];\n    },\n    next: function next() {\n        var _this = this;\n        // if we have detected an error in the meanwhile\n        // reject straight away\n        var error = this[kError];\n        if (error !== null) {\n            return Promise.reject(error);\n        }\n        if (this[kEnded]) {\n            return Promise.resolve(createIterResult(undefined, true));\n        }\n        if (this[kStream].destroyed) {\n            // We need to defer via nextTick because if .destroy(err) is\n            // called, the error will be emitted via nextTick, and\n            // we cannot guarantee that there is no error lingering around\n            // waiting to be emitted.\n            return new Promise(function(resolve, reject) {\n                process.nextTick(function() {\n                    if (_this[kError]) {\n                        reject(_this[kError]);\n                    } else {\n                        resolve(createIterResult(undefined, true));\n                    }\n                });\n            });\n        }\n        // if we have multiple next() calls\n        // we will wait for the previous Promise to finish\n        // this logic is optimized to support for await loops,\n        // where next() is only called once at a time\n        var lastPromise = this[kLastPromise];\n        var promise;\n        if (lastPromise) {\n            promise = new Promise(wrapForNext(lastPromise, this));\n        } else {\n            // fast path needed to support multiple this.push()\n            // without triggering the next() queue\n            var data = this[kStream].read();\n            if (data !== null) {\n                return Promise.resolve(createIterResult(data, false));\n            }\n            promise = new Promise(this[kHandlePromise]);\n        }\n        this[kLastPromise] = promise;\n        return promise;\n    }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {\n    return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n    var _this2 = this;\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise(function(resolve, reject) {\n        _this2[kStream].destroy(null, function(err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(createIterResult(undefined, true));\n        });\n    });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n    var _Object$create;\n    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n        value: stream,\n        writable: true\n    }), _defineProperty(_Object$create, kLastResolve, {\n        value: null,\n        writable: true\n    }), _defineProperty(_Object$create, kLastReject, {\n        value: null,\n        writable: true\n    }), _defineProperty(_Object$create, kError, {\n        value: null,\n        writable: true\n    }), _defineProperty(_Object$create, kEnded, {\n        value: stream._readableState.endEmitted,\n        writable: true\n    }), _defineProperty(_Object$create, kHandlePromise, {\n        value: function value(resolve, reject) {\n            var data = iterator[kStream].read();\n            if (data) {\n                iterator[kLastPromise] = null;\n                iterator[kLastResolve] = null;\n                iterator[kLastReject] = null;\n                resolve(createIterResult(data, false));\n            } else {\n                iterator[kLastResolve] = resolve;\n                iterator[kLastReject] = reject;\n            }\n        },\n        writable: true\n    }), _Object$create));\n    iterator[kLastPromise] = null;\n    finished(stream, function(err) {\n        if (err && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n            var reject = iterator[kLastReject];\n            // reject if we are waiting for data in the Promise\n            // returned by next() and store the error\n            if (reject !== null) {\n                iterator[kLastPromise] = null;\n                iterator[kLastResolve] = null;\n                iterator[kLastReject] = null;\n                reject(err);\n            }\n            iterator[kError] = err;\n            return;\n        }\n        var resolve = iterator[kLastResolve];\n        if (resolve !== null) {\n            iterator[kLastPromise] = null;\n            iterator[kLastResolve] = null;\n            iterator[kLastReject] = null;\n            resolve(createIterResult(undefined, true));\n        }\n        iterator[kEnded] = true;\n    });\n    stream.on(\"readable\", onReadable.bind(null, iterator));\n    return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQTtBQUNKLFNBQVNDLGdCQUFnQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFBSUQsTUFBTUUsZUFBZUY7SUFBTSxJQUFJQSxPQUFPRCxLQUFLO1FBQUVJLE9BQU9DLGNBQWMsQ0FBQ0wsS0FBS0MsS0FBSztZQUFFQyxPQUFPQTtZQUFPSSxZQUFZO1lBQU1DLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFUixHQUFHLENBQUNDLElBQUksR0FBR0M7SUFBTztJQUFFLE9BQU9GO0FBQUs7QUFDM08sU0FBU0csZUFBZU0sR0FBRztJQUFJLElBQUlSLE1BQU1TLGFBQWFELEtBQUs7SUFBVyxPQUFPLE9BQU9SLFFBQVEsV0FBV0EsTUFBTVUsT0FBT1Y7QUFBTTtBQUMxSCxTQUFTUyxhQUFhRSxLQUFLLEVBQUVDLElBQUk7SUFBSSxJQUFJLE9BQU9ELFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU9BO0lBQU8sSUFBSUUsT0FBT0YsS0FBSyxDQUFDRyxPQUFPQyxXQUFXLENBQUM7SUFBRSxJQUFJRixTQUFTRyxXQUFXO1FBQUUsSUFBSUMsTUFBTUosS0FBS0ssSUFBSSxDQUFDUCxPQUFPQyxRQUFRO1FBQVksSUFBSSxPQUFPSyxRQUFRLFVBQVUsT0FBT0E7UUFBSyxNQUFNLElBQUlFLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUNQLFNBQVMsV0FBV0YsU0FBU1UsTUFBSyxFQUFHVDtBQUFRO0FBQ3hYLElBQUlVLFdBQVdDLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlDLGVBQWVULE9BQU87QUFDMUIsSUFBSVUsY0FBY1YsT0FBTztBQUN6QixJQUFJVyxTQUFTWCxPQUFPO0FBQ3BCLElBQUlZLFNB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Q0FBQyxZQUFZOUIsV0FBVytCLElBQUksQ0FBQyxNQUFNTjtJQUM1QyxPQUFPQTtBQUNUO0FBQ0FPLE9BQU9DLE9BQU8sR0FBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzP2U3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpO1xuICAgIC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTtcbiAgICAgIC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7Il0sIm5hbWVzIjpbIl9PYmplY3Qkc2V0UHJvdG90eXBlTyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJmaW5pc2hlZCIsInJlcXVpcmUiLCJrTGFzdFJlc29sdmUiLCJrTGFzdFJlamVjdCIsImtFcnJvciIsImtFbmRlZCIsImtMYXN0UHJvbWlzZSIsImtIYW5kbGVQcm9taXNlIiwia1N0cmVhbSIsImNyZWF0ZUl0ZXJSZXN1bHQiLCJkb25lIiwicmVhZEFuZFJlc29sdmUiLCJpdGVyIiwicmVzb2x2ZSIsImRhdGEiLCJyZWFkIiwib25SZWFkYWJsZSIsInByb2Nlc3MiLCJuZXh0VGljayIsIndyYXBGb3JOZXh0IiwibGFzdFByb21pc2UiLCJyZWplY3QiLCJ0aGVuIiwiQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJzdHJlYW0iLCJuZXh0IiwiX3RoaXMiLCJlcnJvciIsIlByb21pc2UiLCJkZXN0cm95ZWQiLCJwcm9taXNlIiwiYXN5bmNJdGVyYXRvciIsIl9yZXR1cm4iLCJfdGhpczIiLCJkZXN0cm95IiwiZXJyIiwiY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yIiwiX09iamVjdCRjcmVhdGUiLCJpdGVyYXRvciIsImNyZWF0ZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsImNvZGUiLCJvbiIsImJpbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nvar _require = __webpack_require__(/*! buffer */ \"buffer\"), Buffer = _require.Buffer;\nvar _require2 = __webpack_require__(/*! util */ \"util\"), inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || \"inspect\";\nfunction copyBuffer(src, target, offset) {\n    Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/ function() {\n    function BufferList() {\n        _classCallCheck(this, BufferList);\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    _createClass(BufferList, [\n        {\n            key: \"push\",\n            value: function push(v) {\n                var entry = {\n                    data: v,\n                    next: null\n                };\n                if (this.length > 0) this.tail.next = entry;\n                else this.head = entry;\n                this.tail = entry;\n                ++this.length;\n            }\n        },\n        {\n            key: \"unshift\",\n            value: function unshift(v) {\n                var entry = {\n                    data: v,\n                    next: this.head\n                };\n                if (this.length === 0) this.tail = entry;\n                this.head = entry;\n                ++this.length;\n            }\n        },\n        {\n            key: \"shift\",\n            value: function shift() {\n                if (this.length === 0) return;\n                var ret = this.head.data;\n                if (this.length === 1) this.head = this.tail = null;\n                else this.head = this.head.next;\n                --this.length;\n                return ret;\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this.head = this.tail = null;\n                this.length = 0;\n            }\n        },\n        {\n            key: \"join\",\n            value: function join(s) {\n                if (this.length === 0) return \"\";\n                var p = this.head;\n                var ret = \"\" + p.data;\n                while(p = p.next)ret += s + p.data;\n                return ret;\n            }\n        },\n        {\n            key: \"concat\",\n            value: function concat(n) {\n                if (this.length === 0) return Buffer.alloc(0);\n                var ret = Buffer.allocUnsafe(n >>> 0);\n                var p = this.head;\n                var i = 0;\n                while(p){\n                    copyBuffer(p.data, ret, i);\n                    i += p.data.length;\n                    p = p.next;\n                }\n                return ret;\n            }\n        },\n        {\n            key: \"consume\",\n            value: function consume(n, hasStrings) {\n                var ret;\n                if (n < this.head.data.length) {\n                    // `slice` is the same for buffers and strings.\n                    ret = this.head.data.slice(0, n);\n                    this.head.data = this.head.data.slice(n);\n                } else if (n === this.head.data.length) {\n                    // First chunk is a perfect match.\n                    ret = this.shift();\n                } else {\n                    // Result spans more than one buffer.\n                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n                }\n                return ret;\n            }\n        },\n        {\n            key: \"first\",\n            value: function first() {\n                return this.head.data;\n            }\n        },\n        {\n            key: \"_getString\",\n            value: function _getString(n) {\n                var p = this.head;\n                var c = 1;\n                var ret = p.data;\n                n -= ret.length;\n                while(p = p.next){\n                    var str = p.data;\n                    var nb = n > str.length ? str.length : n;\n                    if (nb === str.length) ret += str;\n                    else ret += str.slice(0, n);\n                    n -= nb;\n                    if (n === 0) {\n                        if (nb === str.length) {\n                            ++c;\n                            if (p.next) this.head = p.next;\n                            else this.head = this.tail = null;\n                        } else {\n                            this.head = p;\n                            p.data = str.slice(nb);\n                        }\n                        break;\n                    }\n                    ++c;\n                }\n                this.length -= c;\n                return ret;\n            }\n        },\n        {\n            key: \"_getBuffer\",\n            value: function _getBuffer(n) {\n                var ret = Buffer.allocUnsafe(n);\n                var p = this.head;\n                var c = 1;\n                p.data.copy(ret);\n                n -= p.data.length;\n                while(p = p.next){\n                    var buf = p.data;\n                    var nb = n > buf.length ? buf.length : n;\n                    buf.copy(ret, ret.length - n, 0, nb);\n                    n -= nb;\n                    if (n === 0) {\n                        if (nb === buf.length) {\n                            ++c;\n                            if (p.next) this.head = p.next;\n                            else this.head = this.tail = null;\n                        } else {\n                            this.head = p;\n                            p.data = buf.slice(nb);\n                        }\n                        break;\n                    }\n                    ++c;\n                }\n                this.length -= c;\n                return ret;\n            }\n        },\n        {\n            key: custom,\n            value: function value(_, options) {\n                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n                    // Only inspect one level.\n                    depth: 0,\n                    // It should not recurse.\n                    customInspect: false\n                }));\n            }\n        }\n    ]);\n    return BufferList;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxTQUFTQSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBQVMsSUFBSUcsT0FBT0MscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFBU0Msa0JBQW1CSSxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUFJLE9BQU9KLE9BQU9LLHdCQUF3QixDQUFDUixRQUFRTyxLQUFLRSxVQUFVO1FBQUUsRUFBQyxHQUFJUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFBVTtJQUFFLE9BQU9IO0FBQU07QUFDcFYsU0FBU1UsY0FBY0MsTUFBTTtJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJRyxTQUFTLFFBQVFGLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHQyxTQUFTLENBQUNELEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSWYsUUFBUUksT0FBT2MsU0FBUyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1lBQUlDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1FBQUcsS0FBS2hCLE9BQU9rQix5QkFBeUIsR0FBR2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSixXQUFXbEIsUUFBUUksT0FBT2MsU0FBU0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFBSWhCLE9BQU9vQixjQUFjLENBQUNWLFFBQVFNLEtBQUtoQixPQUFPSyx3QkFBd0IsQ0FBQ1MsUUFBUUU7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USxJQUFJLEVBQUU1QyxjQUFjQSxjQUFjLENBQUMsR0FBR2lGLFVBQVUsQ0FBQyxHQUFHO29CQUNqRSwwQkFBMEI7b0JBQzFCQyxPQUFPO29CQUNQLHlCQUF5QjtvQkFDekJDLGVBQWU7Z0JBQ2pCO1lBQ0Y7UUFDRjtLQUFFO0lBQ0YsT0FBTy9CO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzPzM2ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKytjO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKytjO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiXSwibmFtZXMiOlsib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJOdW1iZXIiLCJfcmVxdWlyZSIsInJlcXVpcmUiLCJCdWZmZXIiLCJfcmVxdWlyZTIiLCJpbnNwZWN0IiwiY3VzdG9tIiwiY29weUJ1ZmZlciIsInNyYyIsIm9mZnNldCIsImNvcHkiLCJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyTGlzdCIsImhlYWQiLCJ0YWlsIiwidiIsImVudHJ5IiwiZGF0YSIsIm5leHQiLCJ1bnNoaWZ0Iiwic2hpZnQiLCJyZXQiLCJjbGVhciIsImpvaW4iLCJzIiwicCIsImNvbmNhdCIsIm4iLCJhbGxvYyIsImFsbG9jVW5zYWZlIiwiY29uc3VtZSIsImhhc1N0cmluZ3MiLCJzbGljZSIsIl9nZXRTdHJpbmciLCJfZ2V0QnVmZmVyIiwiZmlyc3QiLCJjIiwic3RyIiwibmIiLCJidWYiLCJfIiwib3B0aW9ucyIsImRlcHRoIiwiY3VzdG9tSW5zcGVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

eval("\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n    var _this = this;\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n    if (readableDestroyed || writableDestroyed) {\n        if (cb) {\n            cb(err);\n        } else if (err) {\n            if (!this._writableState) {\n                process.nextTick(emitErrorNT, this, err);\n            } else if (!this._writableState.errorEmitted) {\n                this._writableState.errorEmitted = true;\n                process.nextTick(emitErrorNT, this, err);\n            }\n        }\n        return this;\n    }\n    // we set destroyed to true before firing error callbacks in order\n    // to make it re-entrance safe in case destroy() is called within callbacks\n    if (this._readableState) {\n        this._readableState.destroyed = true;\n    }\n    // if this is a duplex stream mark the writable part as destroyed as well\n    if (this._writableState) {\n        this._writableState.destroyed = true;\n    }\n    this._destroy(err || null, function(err) {\n        if (!cb && err) {\n            if (!_this._writableState) {\n                process.nextTick(emitErrorAndCloseNT, _this, err);\n            } else if (!_this._writableState.errorEmitted) {\n                _this._writableState.errorEmitted = true;\n                process.nextTick(emitErrorAndCloseNT, _this, err);\n            } else {\n                process.nextTick(emitCloseNT, _this);\n            }\n        } else if (cb) {\n            process.nextTick(emitCloseNT, _this);\n            cb(err);\n        } else {\n            process.nextTick(emitCloseNT, _this);\n        }\n    });\n    return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n    emitErrorNT(self, err);\n    emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n    if (self._writableState && !self._writableState.emitClose) return;\n    if (self._readableState && !self._readableState.emitClose) return;\n    self.emit(\"close\");\n}\nfunction undestroy() {\n    if (this._readableState) {\n        this._readableState.destroyed = false;\n        this._readableState.reading = false;\n        this._readableState.ended = false;\n        this._readableState.endEmitted = false;\n    }\n    if (this._writableState) {\n        this._writableState.destroyed = false;\n        this._writableState.ended = false;\n        this._writableState.ending = false;\n        this._writableState.finalCalled = false;\n        this._writableState.prefinished = false;\n        this._writableState.finished = false;\n        this._writableState.errorEmitted = false;\n    }\n}\nfunction emitErrorNT(self, err) {\n    self.emit(\"error\", err);\n}\nfunction errorOrDestroy(stream, err) {\n    // We have tests that rely on errors being emitted\n    // in the same tick, so changing this is semver major.\n    // For now when you opt-in to autoDestroy we allow\n    // the error to be emitted nextTick. In a future\n    // semver major update we should change the default to this.\n    var rState = stream._readableState;\n    var wState = stream._writableState;\n    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);\n    else stream.emit(\"error\", err);\n}\nmodule.exports = {\n    destroy: destroy,\n    undestroy: undestroy,\n    errorOrDestroy: errorOrDestroy\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDZEQUE2RDtBQUM3RCxTQUFTQSxRQUFRQyxHQUFHLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUMsUUFBUSxJQUFJO0lBQ2hCLElBQUlDLG9CQUFvQixJQUFJLENBQUNDLGNBQWMsSUFBSSxJQUFJLENBQUNBLGNBQWMsQ0FBQ0MsU0FBUztJQUM1RSxJQUFJQyxvQkFBb0IsSUFBSSxDQUFDQyxjQUFjLElBQUksSUFBSSxDQUFDQSxjQUFjLENBQUNGLFNBQVM7SUFDNUUsSUFBSUYscUJBQXFCRyxtQkFBbUI7UUFDMUMsSUFBSUwsSUFBSTtZQUNOQSxHQUFHRDtRQUNMLE9BQU8sSUFBSUEsS0FBSztZQUNkLElBQUksQ0FBQyxJQUFJLENBQUNPLGNBQWMsRUFBRTtnQkFDeEJDLFFBQVFDLFFBQVEsQ0FBQ0MsYUFBYSxJQUFJLEVBQUVWO1lBQ3RDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ08sY0FBYyxDQUFDSSxZQUFZLEVBQUU7Z0JBQzVDLElBQUksQ0FBQ0osY0FBYyxDQUFDSSxZQUFZLEdBQUc7Z0JBQ25DSCxRQUFRQyxRQUFRLENBQUNDLGFBQWEsSUFBSSxFQUFFVjtZQUN0QztRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFFQSxrRUFBa0U7SUFDbEUsMkVBQTJFO0lBRTNFLElBQUksSUFBSSxDQUFDSSxjQUFjLEVBQUU7UUFDdkIsSUFBSSxDQUFDQSxjQUFjLENBQUNDLFNBQVMsR0FBRztJQUNsQztJQUVBLHlFQUF5RTtJQUN6RSxJQUFJLElBQUksQ0FBQ0UsY0FBYyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxDQUFDRixTQUFTLEdBQUc7SUFDbEM7SUFDQSxJQUFJLENBQUNPLFFBQVEsQ0FBQ1osT0FBTyxNQUFNLFNBQVVBLEdBQUc7UUFDdEMsSUFBSSxDQUFDQyxNQUFNRCxLQUFLO1lBQ2QsSUFBSSxDQUFDRSxNQUFNSyxjQUFjLEVBQUU7Z0JBQ3pCQyxRQUFRQyxRQUFRLENBQUNJLHFCQUFxQlgsT0FBT0Y7WUFDL0MsT0FBTyxJQUFJLENBQUNFLE1BQU1LLGNBQWMsQ0FBQ0ksWUFBWSxFQUFFO2dCQUM3Q1QsTUFBTUssY0FBYyxDQUFDSSxZQUFZLEdBQUc7Z0JBQ3BDSCxRQUFRQyxRQUFRLENBQUNJLHFCQUFxQlgsT0FBT0Y7WUFDL0MsT0FBTztnQkFDTFEsUUFBUUMsUUFBUSxDQUFDSyxhQUFhWjtZQUNoQztRQUNGLE9BQU8sSUFBSUQsSUFBSTtZQUNiTyxRQUFRQyxRQUFRLENBQUNLLGFBQWFaO1lBQzlCRCxHQUFHRDtRQUNMLE9BQU87WUFDTFEsUUFBUUMsUUFBUSxDQUFDSyxhQUFhWjtRQUNoQztJQUNGO0lBQ0EsT0FBTyxJQUFJO0FBQ2I7QUFDQSxTQUFTVyxvQkFBb0JFLElBQUksRUFBRWYsR0FBRztJQUNwQ1UsWUFBWUssTUFBTWY7SUFDbEJjLFlBQVlDO0FBQ2Q7QUFDQSxTQUFTRCxZQUFZQyxJQUFJO0lBQ3ZCLElBQUlBLEtBQUtSLGNBQWMsSUFBSSxDQUFDUSxLQUFLUixjQUFjLENBQUNTLFNBQVMsRUFBRTtJQUMzRCxJQUFJRCxLQUFLWCxjQUFjLElBQUksQ0FBQ1csS0FBS1gsY0FBYyxDQUFDWSxTQUFTLEVBQUU7SUFDM0RELEtBQUtFLElBQUksQ0FBQztBQUNaO0FBQ0EsU0FBU0M7SUFDUCxJQUFJLElBQUksQ0FBQ2QsY0FBYyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxDQUFDQyxTQUFTLEdBQUc7UUFDaEMsSUFBSSxDQUFDRCxjQUFjLENBQUNlLE9BQU8sR0FBRztRQUM5QixJQUFJLENBQUNmLGNBQWMsQ0FBQ2dCLEtBQUssR0FBRztRQUM1QixJQUFJLENBQUNoQixjQUFjLENBQUNpQixVQUFVLEdBQUc7SUFDbkM7SUFDQSxJQUFJLElBQUksQ0FBQ2QsY0FBYyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxDQUFDRixTQUFTLEdBQUc7UUFDaEMsSUFBSSxDQUFDRSxjQUFjLENBQUNhLEtBQUssR0FBRztRQUM1QixJQUFJLENBQUNiLGNBQWMsQ0FBQ2UsTUFBTSxHQUFHO1FBQzdCLElBQUksQ0FBQ2YsY0FBYyxDQUFDZ0IsV0FBVyxHQUFHO1FBQ2xDLElBQUksQ0FBQ2hCLGNBQWMsQ0FBQ2lCLFdBQVcsR0FBRztRQUNsQyxJQUFJLENBQUNqQixjQUFjLENBQUNrQixRQUFRLEdBQUc7UUFDL0IsSUFBSSxDQUFDbEIsY0FBYyxDQUFDSSxZQUFZLEdBQUc7SUFDckM7QUFDRjtBQUNBLFNBQVNELFlBQVlLLElBQUksRUFBRWYsR0FBRztJQUM1QmUsS0FBS0UsSUFBSSxDQUFDLFNBQVNqQjtBQUNyQjtBQUNBLFNBQVMwQixlQUFlQyxNQUFNLEVBQUUzQixHQUFHO0lBQ2pDLGtEQUFrRDtJQUNsRCxzREFBc0Q7SUFDdEQsa0RBQWtEO0lBQ2xELGdEQUFnRDtJQUNoRCw0REFBNEQ7SUFFNUQsSUFBSTRCLFNBQVNELE9BQU92QixjQUFjO0lBQ2xDLElBQUl5QixTQUFTRixPQUFPcEIsY0FBYztJQUNsQyxJQUFJcUIsVUFBVUEsT0FBT0UsV0FBVyxJQUFJRCxVQUFVQSxPQUFPQyxXQUFXLEVBQUVILE9BQU81QixPQUFPLENBQUNDO1NBQVUyQixPQUFPVixJQUFJLENBQUMsU0FBU2pCO0FBQ2xIO0FBQ0ErQixPQUFPQyxPQUFPLEdBQUc7SUFDZmpDLFNBQVNBO0lBQ1RtQixXQUFXQTtJQUNYUSxnQkFBZ0JBO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzPzZmNTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07Il0sIm5hbWVzIjpbImRlc3Ryb3kiLCJlcnIiLCJjYiIsIl90aGlzIiwicmVhZGFibGVEZXN0cm95ZWQiLCJfcmVhZGFibGVTdGF0ZSIsImRlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiX3dyaXRhYmxlU3RhdGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0RXJyb3JOVCIsImVycm9yRW1pdHRlZCIsIl9kZXN0cm95IiwiZW1pdEVycm9yQW5kQ2xvc2VOVCIsImVtaXRDbG9zZU5UIiwic2VsZiIsImVtaXRDbG9zZSIsImVtaXQiLCJ1bmRlc3Ryb3kiLCJyZWFkaW5nIiwiZW5kZWQiLCJlbmRFbWl0dGVkIiwiZW5kaW5nIiwiZmluYWxDYWxsZWQiLCJwcmVmaW5pc2hlZCIsImZpbmlzaGVkIiwiZXJyb3JPckRlc3Ryb3kiLCJzdHJlYW0iLCJyU3RhdGUiLCJ3U3RhdGUiLCJhdXRvRGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes.ERR_STREAM_PREMATURE_CLOSE);\nfunction once(callback) {\n    var called = false;\n    return function() {\n        if (called) return;\n        called = true;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        callback.apply(this, args);\n    };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === \"function\";\n}\nfunction eos(stream, opts, callback) {\n    if (typeof opts === \"function\") return eos(stream, null, opts);\n    if (!opts) opts = {};\n    callback = once(callback || noop);\n    var readable = opts.readable || opts.readable !== false && stream.readable;\n    var writable = opts.writable || opts.writable !== false && stream.writable;\n    var onlegacyfinish = function onlegacyfinish() {\n        if (!stream.writable) onfinish();\n    };\n    var writableEnded = stream._writableState && stream._writableState.finished;\n    var onfinish = function onfinish() {\n        writable = false;\n        writableEnded = true;\n        if (!readable) callback.call(stream);\n    };\n    var readableEnded = stream._readableState && stream._readableState.endEmitted;\n    var onend = function onend() {\n        readable = false;\n        readableEnded = true;\n        if (!writable) callback.call(stream);\n    };\n    var onerror = function onerror(err) {\n        callback.call(stream, err);\n    };\n    var onclose = function onclose() {\n        var err;\n        if (readable && !readableEnded) {\n            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n        }\n        if (writable && !writableEnded) {\n            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n        }\n    };\n    var onrequest = function onrequest() {\n        stream.req.on(\"finish\", onfinish);\n    };\n    if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        stream.on(\"abort\", onclose);\n        if (stream.req) onrequest();\n        else stream.on(\"request\", onrequest);\n    } else if (writable && !stream._writableState) {\n        // legacy streams\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n    }\n    stream.on(\"end\", onend);\n    stream.on(\"finish\", onfinish);\n    if (opts.error !== false) stream.on(\"error\", onerror);\n    stream.on(\"close\", onclose);\n    return function() {\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n    };\n}\nmodule.exports = eos;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4REFBOEQ7QUFDOUQseURBQXlEO0FBRXpEO0FBRUEsSUFBSUEsNkJBQTZCQyx3S0FBMkQ7QUFDNUYsU0FBU0UsS0FBS0MsUUFBUTtJQUNwQixJQUFJQyxTQUFTO0lBQ2IsT0FBTztRQUNMLElBQUlBLFFBQVE7UUFDWkEsU0FBUztRQUNULElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU9LLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTtZQUN2RkYsSUFBSSxDQUFDRSxLQUFLLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztRQUM5QjtRQUNBUCxTQUFTUSxLQUFLLENBQUMsSUFBSSxFQUFFSDtJQUN2QjtBQUNGO0FBQ0EsU0FBU0ksUUFBUTtBQUNqQixTQUFTQyxVQUFVQyxNQUFNO0lBQ3ZCLE9BQU9BLE9BQU9DLFNBQVMsSUFBSSxPQUFPRCxPQUFPRSxLQUFLLEtBQUs7QUFDckQ7QUFDQSxTQUFTQyxJQUFJSCxNQUFNLEVBQUVJLElBQUksRUFBRWYsUUFBUTtJQUNqQyxJQUFJLE9BQU9lLFNBQVMsWUFBWSxPQUFPRCxJQUFJSCxRQUFRLE1BQU1JO0lBQ3pELElBQUksQ0FBQ0EsTUFBTUEsT0FBTyxDQUFDO0lBQ25CZixXQUFXRCxLQUFLQyxZQUFZUztJQUM1QixJQUFJTyxXQUFXRCxLQUFLQyxRQUFRLElBQUlELEtBQUtDLFFBQVEsS0FBSyxTQUFTTCxPQUFPSyxRQUFRO0lBQzFFLElBQUlDLFdBQVdGLEtBQUtFLFFBQVEsSUFBSUYsS0FBS0UsUUFBUSxLQUFLLFNBQVNOLE9BQU9NLFFBQVE7SUFDMUUsSUFBSUMsaUJBQWlCLFNBQVNBO1FBQzVCLElBQUksQ0FBQ1AsT0FBT00sUUFBUSxFQUFFRTtJQUN4QjtJQUNBLElBQUlDLGdCQUFnQlQsT0FBT1UsY0FBYyxJQUFJVixPQUFPVSxjQUFjLENBQUNDLFFBQVE7SUFDM0UsSUFBSUgsV0FBVyxTQUFTQTtRQUN0QkYsV0FBVztRQUNYRyxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDSixVQUFVaEIsU0FBU3VCLElBQUksQ0FBQ1o7SUFDL0I7SUFDQSxJQUFJYSxnQkFBZ0JiLE9BQU9jLGNBQWMsSUFBSWQsT0FBT2MsY0FBYyxDQUFDQyxVQUFVO0lBQzdFLElBQUlDLFFBQVEsU0FBU0E7UUFDbkJYLFdBQVc7UUFDWFEsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQ1AsVUFBVWpCLFNBQVN1QixJQUFJLENBQUNaO0lBQy9CO0lBQ0EsSUFBSWlCLFVBQVUsU0FBU0EsUUFBUUMsR0FBRztRQUNoQzdCLFNBQVN1QixJQUFJLENBQUNaLFFBQVFrQjtJQUN4QjtJQUNBLElBQUlDLFVBQVUsU0FBU0E7UUFDckIsSUFBSUQ7UUFDSixJQUFJYixZQUFZLENBQUNRLGVBQWU7WUFDOUIsSUFBSSxDQUFDYixPQUFPYyxjQUFjLElBQUksQ0FBQ2QsT0FBT2MsY0FBYyxDQUFDTSxLQUFLLEVBQUVGLE1BQU0sSUFBSWpDO1lBQ3RFLE9BQU9JLFNBQVN1QixJQUFJLENBQUNaLFFBQVFrQjtRQUMvQjtRQUNBLElBQUlaLFlBQVksQ0FBQ0csZUFBZTtZQUM5QixJQUFJLENBQUNULE9BQU9VLGNBQWMsSUFBSSxDQUFDVixPQUFPVSxjQUFjLENBQUNVLEtBQUssRUFBRUYsTUFBTSxJQUFJakM7WUFDdEUsT0FBT0ksU0FBU3VCLElBQUksQ0FBQ1osUUFBUWtCO1FBQy9CO0lBQ0Y7SUFDQSxJQUFJRyxZQUFZLFNBQVNBO1FBQ3ZCckIsT0FBT3NCLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDLFVBQVVmO0lBQzFCO0lBQ0EsSUFBSVQsVUFBVUMsU0FBUztRQUNyQkEsT0FBT3VCLEVBQUUsQ0FBQyxZQUFZZjtRQUN0QlIsT0FBT3VCLEVBQUUsQ0FBQyxTQUFTSjtRQUNuQixJQUFJbkIsT0FBT3NCLEdBQUcsRUFBRUQ7YUFBaUJyQixPQUFPdUIsRUFBRSxDQUFDLFdBQVdGO0lBQ3hELE9BQU8sSUFBSWYsWUFBWSxDQUFDTixPQUFPVSxjQUFjLEVBQUU7UUFDN0MsaUJBQWlCO1FBQ2pCVixPQUFPdUIsRUFBRSxDQUFDLE9BQU9oQjtRQUNqQlAsT0FBT3VCLEVBQUUsQ0FBQyxTQUFTaEI7SUFDckI7SUFDQVAsT0FBT3VCLEVBQUUsQ0FBQyxPQUFPUDtJQUNqQmhCLE9BQU91QixFQUFFLENBQUMsVUFBVWY7SUFDcEIsSUFBSUosS0FBS29CLEtBQUssS0FBSyxPQUFPeEIsT0FBT3VCLEVBQUUsQ0FBQyxTQUFTTjtJQUM3Q2pCLE9BQU91QixFQUFFLENBQUMsU0FBU0o7SUFDbkIsT0FBTztRQUNMbkIsT0FBT3lCLGNBQWMsQ0FBQyxZQUFZakI7UUFDbENSLE9BQU95QixjQUFjLENBQUMsU0FBU047UUFDL0JuQixPQUFPeUIsY0FBYyxDQUFDLFdBQVdKO1FBQ2pDLElBQUlyQixPQUFPc0IsR0FBRyxFQUFFdEIsT0FBT3NCLEdBQUcsQ0FBQ0csY0FBYyxDQUFDLFVBQVVqQjtRQUNwRFIsT0FBT3lCLGNBQWMsQ0FBQyxPQUFPbEI7UUFDN0JQLE9BQU95QixjQUFjLENBQUMsU0FBU2xCO1FBQy9CUCxPQUFPeUIsY0FBYyxDQUFDLFVBQVVqQjtRQUNoQ1IsT0FBT3lCLGNBQWMsQ0FBQyxPQUFPVDtRQUM3QmhCLE9BQU95QixjQUFjLENBQUMsU0FBU1I7UUFDL0JqQixPQUFPeUIsY0FBYyxDQUFDLFNBQVNOO0lBQ2pDO0FBQ0Y7QUFDQU8sT0FBT0MsT0FBTyxHQUFHeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanM/YWI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBlb3M7Il0sIm5hbWVzIjpbIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFIiwicmVxdWlyZSIsImNvZGVzIiwib25jZSIsImNhbGxiYWNrIiwiY2FsbGVkIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsIm5vb3AiLCJpc1JlcXVlc3QiLCJzdHJlYW0iLCJzZXRIZWFkZXIiLCJhYm9ydCIsImVvcyIsIm9wdHMiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwib25sZWdhY3lmaW5pc2giLCJvbmZpbmlzaCIsIndyaXRhYmxlRW5kZWQiLCJfd3JpdGFibGVTdGF0ZSIsImZpbmlzaGVkIiwiY2FsbCIsInJlYWRhYmxlRW5kZWQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJvbmVuZCIsIm9uZXJyb3IiLCJlcnIiLCJvbmNsb3NlIiwiZW5kZWQiLCJvbnJlcXVlc3QiLCJyZXEiLCJvbiIsImVycm9yIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nvar ERR_INVALID_ARG_TYPE = (__webpack_require__(/*! ../../../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes.ERR_INVALID_ARG_TYPE);\nfunction from(Readable, iterable, opts) {\n    var iterator;\n    if (iterable && typeof iterable.next === \"function\") {\n        iterator = iterable;\n    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();\n    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();\n    else throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\n        \"Iterable\"\n    ], iterable);\n    var readable = new Readable(_objectSpread({\n        objectMode: true\n    }, opts));\n    // Reading boolean to protect against _read\n    // being called before last iteration completion.\n    var reading = false;\n    readable._read = function() {\n        if (!reading) {\n            reading = true;\n            next();\n        }\n    };\n    function next() {\n        return _next2.apply(this, arguments);\n    }\n    function _next2() {\n        _next2 = _asyncToGenerator(function*() {\n            try {\n                var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;\n                if (done) {\n                    readable.push(null);\n                } else if (readable.push((yield value))) {\n                    next();\n                } else {\n                    reading = false;\n                }\n            } catch (err) {\n                readable.destroy(err);\n            }\n        });\n        return _next2.apply(this, arguments);\n    }\n    return readable;\n}\nmodule.exports = from;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLFNBQVNBLG1CQUFtQkMsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUFJLElBQUk7UUFBRSxJQUFJQyxPQUFPUCxHQUFHLENBQUNLLElBQUksQ0FBQ0M7UUFBTSxJQUFJRSxRQUFRRCxLQUFLQyxLQUFLO0lBQUUsRUFBRSxPQUFPQyxPQUFPO1FBQUVQLE9BQU9PO1FBQVE7SUFBUTtJQUFFLElBQUlGLEtBQUtHLElBQUksRUFBRTtRQUFFVCxRQUFRTztJQUFRLE9BQU87UUFBRUcsUUFBUVYsT0FBTyxDQUFDTyxPQUFPSSxJQUFJLENBQUNULE9BQU9DO0lBQVM7QUFBRTtBQUN4USxTQUFTUyxrQkFBa0JDLEVBQUU7SUFBSSxPQUFPO1FBQWMsSUFBSUMsT0FBTyxJQUFJLEVBQUVDLE9BQU9DO1FBQVcsT0FBTyxJQUFJTixRQUFRLFNBQVVWLE9BQU8sRUFBRUMsTUFBTTtZQUFJLElBQUlGLE1BQU1jLEdBQUdJLEtBQUssQ0FBQ0gsTUFBTUM7WUFBTyxTQUFTYixNQUFNSyxLQUFLO2dCQUFJVCxtQkFBbUJDLEtBQUtDLFNBQVNDLFFBQVFDLE9BQU9DLFFBQVEsUUFBUUk7WUFBUTtZQUFFLFNBQVNKLE9BQU9lLEdBQUc7Z0JBQUlwQixtQkFBbUJDLEtBQUtDLFNBQVNDLFFBQVFDLE9BQU9DLFFBQVEsU0FBU2U7WUFBTTtZQUFFaEIsTUFBTWlCO1FBQVk7SUFBSTtBQUFHO0FBQ3BZLFNBQVNDLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0Y7SUFBUyxJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUFFLElB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QUNmLElBQUksQ0FBQ0QsU0FBUztZQUNaQSxVQUFVO1lBQ1ZKO1FBQ0Y7SUFDRjtJQUNBLFNBQVNBO1FBQ1AsT0FBT00sT0FBT3RELEtBQUssQ0FBQyxJQUFJLEVBQUVEO0lBQzVCO0lBQ0EsU0FBU3VEO1FBQ1BBLFNBQVMzRCxrQkFBa0I7WUFDekIsSUFBSTtnQkFDRixJQUFJNEQsdUJBQXVCLE1BQU1SLFNBQVNDLElBQUksSUFDNUMxRCxRQUFRaUUscUJBQXFCakUsS0FBSyxFQUNsQ0UsT0FBTytELHFCQUFxQi9ELElBQUk7Z0JBQ2xDLElBQUlBLE1BQU07b0JBQ1IwRCxTQUFTcEMsSUFBSSxDQUFDO2dCQUNoQixPQUFPLElBQUlvQyxTQUFTcEMsSUFBSSxDQUFDLE9BQU14QixLQUFJLElBQUk7b0JBQ3JDMEQ7Z0JBQ0YsT0FBTztvQkFDTEksVUFBVTtnQkFDWjtZQUNGLEVBQUUsT0FBT25ELEtBQUs7Z0JBQ1ppRCxTQUFTTSxPQUFPLENBQUN2RDtZQUNuQjtRQUNGO1FBQ0EsT0FBT3FELE9BQU90RCxLQUFLLENBQUMsSUFBSSxFQUFFRDtJQUM1QjtJQUNBLE9BQU9tRDtBQUNUO0FBQ0FPLE9BQU9DLE9BQU8sR0FBR2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20uanM/MDAxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTtcbmZ1bmN0aW9uIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKSB7XG4gIHZhciBpdGVyYXRvcjtcbiAgaWYgKGl0ZXJhYmxlICYmIHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7ZWxzZSBpZiAoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSkgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7ZWxzZSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2l0ZXJhYmxlJywgWydJdGVyYWJsZSddLCBpdGVyYWJsZSk7XG4gIHZhciByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZShfb2JqZWN0U3ByZWFkKHtcbiAgICBvYmplY3RNb2RlOiB0cnVlXG4gIH0sIG9wdHMpKTtcbiAgLy8gUmVhZGluZyBib29sZWFuIHRvIHByb3RlY3QgYWdhaW5zdCBfcmVhZFxuICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIGxhc3QgaXRlcmF0aW9uIGNvbXBsZXRpb24uXG4gIHZhciByZWFkaW5nID0gZmFsc2U7XG4gIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVhZGluZykge1xuICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHJldHVybiBfbmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBfbmV4dDIoKSB7XG4gICAgX25leHQyID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfeWllbGQkaXRlcmF0b3IkbmV4dCA9IHlpZWxkIGl0ZXJhdG9yLm5leHQoKSxcbiAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LnZhbHVlLFxuICAgICAgICAgIGRvbmUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC5kb25lO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJlYWRhYmxlLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZGFibGUucHVzaCh5aWVsZCB2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVhZGFibGUuZGVzdHJveShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfbmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gcmVhZGFibGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZyb207XG4iXSwibmFtZXMiOlsiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsInZhbHVlIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsInJlcXVpcmUiLCJjb2RlcyIsImZyb20iLCJSZWFkYWJsZSIsIml0ZXJhYmxlIiwib3B0cyIsIml0ZXJhdG9yIiwibmV4dCIsImFzeW5jSXRlcmF0b3IiLCJyZWFkYWJsZSIsIm9iamVjdE1vZGUiLCJyZWFkaW5nIiwiX3JlYWQiLCJfbmV4dDIiLCJfeWllbGQkaXRlcmF0b3IkbmV4dCIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\nvar eos;\nfunction once(callback) {\n    var called = false;\n    return function() {\n        if (called) return;\n        called = true;\n        callback.apply(void 0, arguments);\n    };\n}\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes), ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n    // Rethrow the error if it exists to avoid swallowing it\n    if (err) throw err;\n}\nfunction isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === \"function\";\n}\nfunction destroyer(stream, reading, writing, callback) {\n    callback = once(callback);\n    var closed = false;\n    stream.on(\"close\", function() {\n        closed = true;\n    });\n    if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n    eos(stream, {\n        readable: reading,\n        writable: writing\n    }, function(err) {\n        if (err) return callback(err);\n        closed = true;\n        callback();\n    });\n    var destroyed = false;\n    return function(err) {\n        if (closed) return;\n        if (destroyed) return;\n        destroyed = true;\n        // request.destroy just do .end - .abort is what we want\n        if (isRequest(stream)) return stream.abort();\n        if (typeof stream.destroy === \"function\") return stream.destroy();\n        callback(err || new ERR_STREAM_DESTROYED(\"pipe\"));\n    };\n}\nfunction call(fn) {\n    fn();\n}\nfunction pipe(from, to) {\n    return from.pipe(to);\n}\nfunction popCallback(streams) {\n    if (!streams.length) return noop;\n    if (typeof streams[streams.length - 1] !== \"function\") return noop;\n    return streams.pop();\n}\nfunction pipeline() {\n    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++){\n        streams[_key] = arguments[_key];\n    }\n    var callback = popCallback(streams);\n    if (Array.isArray(streams[0])) streams = streams[0];\n    if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n    }\n    var error;\n    var destroys = streams.map(function(stream, i) {\n        var reading = i < streams.length - 1;\n        var writing = i > 0;\n        return destroyer(stream, reading, writing, function(err) {\n            if (!error) error = err;\n            if (err) destroys.forEach(call);\n            if (reading) return;\n            destroys.forEach(call);\n            callback(error);\n        });\n    });\n    return streams.reduce(pipe);\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFEO0FBQ3JELHlEQUF5RDtBQUV6RDtBQUVBLElBQUlBO0FBQ0osU0FBU0MsS0FBS0MsUUFBUTtJQUNwQixJQUFJQyxTQUFTO0lBQ2IsT0FBTztRQUNMLElBQUlBLFFBQVE7UUFDWkEsU0FBUztRQUNURCxTQUFTRSxLQUFLLENBQUMsS0FBSyxHQUFHQztJQUN6QjtBQUNGO0FBQ0EsSUFBSUMsaUJBQWlCQyw2SUFBZ0MsRUFDbkRFLG1CQUFtQkgsZUFBZUcsZ0JBQWdCLEVBQ2xEQyx1QkFBdUJKLGVBQWVJLG9CQUFvQjtBQUM1RCxTQUFTQyxLQUFLQyxHQUFHO0lBQ2Ysd0RBQXdEO0lBQ3hELElBQUlBLEtBQUssTUFBTUE7QUFDakI7QUFDQSxTQUFTQyxVQUFVQyxNQUFNO0lBQ3ZCLE9BQU9BLE9BQU9DLFNBQVMsSUFBSSxPQUFPRCxPQUFPRSxLQUFLLEtBQUs7QUFDckQ7QUFDQSxTQUFTQyxVQUFVSCxNQUFNLEVBQUVJLE9BQU8sRUFBRUMsT0FBTyxFQUFFakIsUUFBUTtJQUNuREEsV0FBV0QsS0FBS0M7SUFDaEIsSUFBSWtCLFNBQVM7SUFDYk4sT0FBT08sRUFBRSxDQUFDLFNBQVM7UUFDakJELFNBQVM7SUFDWDtJQUNBLElBQUlwQixRQUFRc0IsV0FBV3RCLE1BQU1PLG1CQUFPQSxDQUFDO0lBQ3JDUCxJQUFJYyxRQUFRO1FBQ1ZTLFVBQVVMO1FBQ1ZNLFVBQVVMO0lBQ1osR0FBRyxTQUFVUCxHQUFHO1FBQ2QsSUFBSUEsS0FBSyxPQUFPVixTQUFTVTtRQUN6QlEsU0FBUztRQUNUbEI7SUFDRjtJQUNBLElBQUl1QixZQUFZO0lBQ2hCLE9BQU8sU0FBVWIsR0FBRztRQUNsQixJQUFJUSxRQUFRO1FBQ1osSUFBSUssV0FBVztRQUNmQSxZQUFZO1FBRVosd0RBQXdEO1FBQ3hELElBQUlaLFVBQVVDLFNBQVMsT0FBT0EsT0FBT0UsS0FBSztRQUMxQyxJQUFJLE9BQU9GLE9BQU9ZLE9BQU8sS0FBSyxZQUFZLE9BQU9aLE9BQU9ZLE9BQU87UUFDL0R4QixTQUFTVSxPQUFPLElBQUlGLHFCQUFxQjtJQUMzQztBQUNGO0FBQ0EsU0FBU2lCLEtBQUtDLEVBQUU7SUFDZEE7QUFDRjtBQUNBLFNBQVNDLEtBQUtDLElBQUksRUFBRUMsRUFBRTtJQUNwQixPQUFPRCxLQUFLRCxJQUFJLENBQUNFO0FBQ25CO0FBQ0EsU0FBU0MsWUFBWUMsT0FBTztJQUMxQixJQUFJLENBQUNBLFFBQVFDLE1BQU0sRUFBRSxPQUFPdkI7SUFDNUIsSUFBSSxPQUFPc0IsT0FBTyxDQUFDQSxRQUFRQyxNQUFNLEdBQUcsRUFBRSxLQUFLLFlBQVksT0FBT3ZCO0lBQzlELE9BQU9zQixRQUFRRSxHQUFHO0FBQ3BCO0FBQ0EsU0FBU0M7SUFDUCxJQUFLLElBQUlDLE9BQU9oQyxVQUFVNkIsTUFBTSxFQUFFRCxVQUFVLElBQUlLLE1BQU1ELE9BQU9FLE9BQU8sR0FBR0EsT0FBT0YsTUFBTUUsT0FBUTtRQUMxRk4sT0FBTyxDQUFDTSxLQUFLLEdBQUdsQyxTQUFTLENBQUNrQyxLQUFLO0lBQ2pDO0lBQ0EsSUFBSXJDLFdBQVc4QixZQUFZQztJQUMzQixJQUFJSyxNQUFNRSxPQUFPLENBQUNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLFVBQVVBLE9BQU8sQ0FBQyxFQUFFO0lBQ25ELElBQUlBLFFBQVFDLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLE1BQU0sSUFBSXpCLGlCQUFpQjtJQUM3QjtJQUNBLElBQUlnQztJQUNKLElBQUlDLFdBQVdULFFBQVFVLEdBQUcsQ0FBQyxTQUFVN0IsTUFBTSxFQUFFOEIsQ0FBQztRQUM1QyxJQUFJMUIsVUFBVTBCLElBQUlYLFFBQVFDLE1BQU0sR0FBRztRQUNuQyxJQUFJZixVQUFVeUIsSUFBSTtRQUNsQixPQUFPM0IsVUFBVUgsUUFBUUksU0FBU0MsU0FBUyxTQUFVUCxHQUFHO1lBQ3RELElBQUksQ0FBQzZCLE9BQU9BLFFBQVE3QjtZQUNwQixJQUFJQSxLQUFLOEIsU0FBU0csT0FBTyxDQUFDbEI7WUFDMUIsSUFBSVQsU0FBUztZQUNid0IsU0FBU0csT0FBTyxDQUFDbEI7WUFDakJ6QixTQUFTdUM7UUFDWDtJQUNGO0lBQ0EsT0FBT1IsUUFBUWEsTUFBTSxDQUFDakI7QUFDeEI7QUFDQWtCLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzPzU1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiXSwibmFtZXMiOlsiZW9zIiwib25jZSIsImNhbGxiYWNrIiwiY2FsbGVkIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJfcmVxdWlyZSRjb2RlcyIsInJlcXVpcmUiLCJjb2RlcyIsIkVSUl9NSVNTSU5HX0FSR1MiLCJFUlJfU1RSRUFNX0RFU1RST1lFRCIsIm5vb3AiLCJlcnIiLCJpc1JlcXVlc3QiLCJzdHJlYW0iLCJzZXRIZWFkZXIiLCJhYm9ydCIsImRlc3Ryb3llciIsInJlYWRpbmciLCJ3cml0aW5nIiwiY2xvc2VkIiwib24iLCJ1bmRlZmluZWQiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiZGVzdHJveWVkIiwiZGVzdHJveSIsImNhbGwiLCJmbiIsInBpcGUiLCJmcm9tIiwidG8iLCJwb3BDYWxsYmFjayIsInN0cmVhbXMiLCJsZW5ndGgiLCJwb3AiLCJwaXBlbGluZSIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJpc0FycmF5IiwiZXJyb3IiLCJkZXN0cm95cyIsIm1hcCIsImkiLCJmb3JFYWNoIiwicmVkdWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js\").codes.ERR_INVALID_OPT_VALUE);\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n    if (hwm != null) {\n        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n            var name = isDuplex ? duplexKey : \"highWaterMark\";\n            throw new ERR_INVALID_OPT_VALUE(name, hwm);\n        }\n        return Math.floor(hwm);\n    }\n    // Default value\n    return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n    getHighWaterMark: getHighWaterMark\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSx3QkFBd0JDLG1LQUFzRDtBQUNsRixTQUFTRSxrQkFBa0JDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxTQUFTO0lBQ3JELE9BQU9GLFFBQVFHLGFBQWEsSUFBSSxPQUFPSCxRQUFRRyxhQUFhLEdBQUdGLFdBQVdELE9BQU8sQ0FBQ0UsVUFBVSxHQUFHO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCQyxLQUFLLEVBQUVMLE9BQU8sRUFBRUUsU0FBUyxFQUFFRCxRQUFRO0lBQzNELElBQUlLLE1BQU1QLGtCQUFrQkMsU0FBU0MsVUFBVUM7SUFDL0MsSUFBSUksT0FBTyxNQUFNO1FBQ2YsSUFBSSxDQUFFQyxDQUFBQSxTQUFTRCxRQUFRRSxLQUFLQyxLQUFLLENBQUNILFNBQVNBLEdBQUUsS0FBTUEsTUFBTSxHQUFHO1lBQzFELElBQUlJLE9BQU9ULFdBQVdDLFlBQVk7WUFDbEMsTUFBTSxJQUFJTixzQkFBc0JjLE1BQU1KO1FBQ3hDO1FBQ0EsT0FBT0UsS0FBS0MsS0FBSyxDQUFDSDtJQUNwQjtJQUVBLGdCQUFnQjtJQUNoQixPQUFPRCxNQUFNTSxVQUFVLEdBQUcsS0FBSyxLQUFLO0FBQ3RDO0FBQ0FDLE9BQU9DLE9BQU8sR0FBRztJQUNmVCxrQkFBa0JBO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcz80OGU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IHZhbHVlXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiXSwibmFtZXMiOlsiRVJSX0lOVkFMSURfT1BUX1ZBTFVFIiwicmVxdWlyZSIsImNvZGVzIiwiaGlnaFdhdGVyTWFya0Zyb20iLCJvcHRpb25zIiwiaXNEdXBsZXgiLCJkdXBsZXhLZXkiLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0SGlnaFdhdGVyTWFyayIsInN0YXRlIiwiaHdtIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJuYW1lIiwib2JqZWN0TW9kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! stream */ \"stream\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsNERBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0uanM/MTY1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === \"disable\" && Stream) {\n    module.exports = Stream.Readable;\n    Object.assign(module.exports, Stream);\n    module.exports.Stream = Stream;\n} else {\n    exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js\");\n    exports.Stream = Stream || exports;\n    exports.Readable = exports;\n    exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js\");\n    exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js\");\n    exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js\");\n    exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js\");\n    exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n    exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsZUFBZSxLQUFLLGFBQWFKLFFBQVE7SUFDdkRLLE9BQU9DLE9BQU8sR0FBR04sT0FBT08sUUFBUTtJQUNoQ0MsT0FBT0MsTUFBTSxDQUFDSixPQUFPQyxPQUFPLEVBQUVOO0lBQzlCSyxxQkFBcUIsR0FBR0w7QUFDMUIsT0FBTztJQUNMTSxVQUFVRCw4S0FBeUI7SUFDbkNDLGNBQWMsR0FBR04sVUFBVU07SUFDM0JBLGdCQUFnQixHQUFHQTtJQUNuQkEsZ0xBQTJCO0lBQzNCQSwwS0FBeUI7SUFDekJBLG1MQUE0QjtJQUM1QkEseUxBQThCO0lBQzlCQSw0TUFBMkI7SUFDM0JBLGtNQUEyQjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanM/YzA1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5pZiAocHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtLlJlYWRhYmxlO1xuICBPYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCBTdHJlYW0pO1xuICBtb2R1bGUuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG59IGVsc2Uge1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG4gIGV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuICBleHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuICBleHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiAgZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuICBleHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbIlN0cmVhbSIsInJlcXVpcmUiLCJwcm9jZXNzIiwiZW52IiwiUkVBREFCTEVfU1RSRUFNIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWRhYmxlIiwiT2JqZWN0IiwiYXNzaWduIiwiV3JpdGFibGUiLCJEdXBsZXgiLCJUcmFuc2Zvcm0iLCJQYXNzVGhyb3VnaCIsImZpbmlzaGVkIiwicGlwZWxpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js\n");

/***/ })

};
;