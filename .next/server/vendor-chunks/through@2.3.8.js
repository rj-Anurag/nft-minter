"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/through@2.3.8";
exports.ids = ["vendor-chunks/through@2.3.8"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/through@2.3.8/node_modules/through/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/through@2.3.8/node_modules/through/index.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\nexports = module.exports = through;\nthrough.through = through;\n//create a readable writable stream.\nfunction through(write, end, opts) {\n    write = write || function(data) {\n        this.queue(data);\n    };\n    end = end || function() {\n        this.queue(null);\n    };\n    var ended = false, destroyed = false, buffer = [], _ended = false;\n    var stream = new Stream();\n    stream.readable = stream.writable = true;\n    stream.paused = false;\n    //  stream.autoPause   = !(opts && opts.autoPause   === false)\n    stream.autoDestroy = !(opts && opts.autoDestroy === false);\n    stream.write = function(data) {\n        write.call(this, data);\n        return !stream.paused;\n    };\n    function drain() {\n        while(buffer.length && !stream.paused){\n            var data = buffer.shift();\n            if (null === data) return stream.emit(\"end\");\n            else stream.emit(\"data\", data);\n        }\n    }\n    stream.queue = stream.push = function(data) {\n        //    console.error(ended)\n        if (_ended) return stream;\n        if (data === null) _ended = true;\n        buffer.push(data);\n        drain();\n        return stream;\n    };\n    //this will be registered as the first 'end' listener\n    //must call destroy next tick, to make sure we're after any\n    //stream piped from here.\n    //this is only a problem if end is not emitted synchronously.\n    //a nicer way to do this is to make sure this is the last listener for 'end'\n    stream.on(\"end\", function() {\n        stream.readable = false;\n        if (!stream.writable && stream.autoDestroy) process.nextTick(function() {\n            stream.destroy();\n        });\n    });\n    function _end() {\n        stream.writable = false;\n        end.call(stream);\n        if (!stream.readable && stream.autoDestroy) stream.destroy();\n    }\n    stream.end = function(data) {\n        if (ended) return;\n        ended = true;\n        if (arguments.length) stream.write(data);\n        _end() // will emit or queue\n        ;\n        return stream;\n    };\n    stream.destroy = function() {\n        if (destroyed) return;\n        destroyed = true;\n        ended = true;\n        buffer.length = 0;\n        stream.writable = stream.readable = false;\n        stream.emit(\"close\");\n        return stream;\n    };\n    stream.pause = function() {\n        if (stream.paused) return;\n        stream.paused = true;\n        return stream;\n    };\n    stream.resume = function() {\n        if (stream.paused) {\n            stream.paused = false;\n            stream.emit(\"resume\");\n        }\n        drain();\n        //may have become paused again,\n        //as drain emits 'data'.\n        if (!stream.paused) stream.emit(\"drain\");\n        return stream;\n    };\n    return stream;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyb3VnaEAyLjMuOC9ub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFckIsVUFBVTtBQUNWLEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsc0ZBQXNGO0FBRXRGQyxVQUFVQyxPQUFPRCxPQUFPLEdBQUdFO0FBQzNCQSxRQUFRQSxPQUFPLEdBQUdBO0FBRWxCLG9DQUFvQztBQUVwQyxTQUFTQSxRQUFTQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUNoQ0YsUUFBUUEsU0FBUyxTQUFVRyxJQUFJO1FBQUksSUFBSSxDQUFDQyxLQUFLLENBQUNEO0lBQU07SUFDcERGLE1BQU1BLE9BQU87UUFBYyxJQUFJLENBQUNHLEtBQUssQ0FBQztJQUFNO0lBRTVDLElBQUlDLFFBQVEsT0FBT0MsWUFBWSxPQUFPQyxTQUFTLEVBQUUsRUFBRUMsU0FBUztJQUM1RCxJQUFJQyxTQUFTLElBQUlkO0lBQ2pCYyxPQUFPQyxRQUFRLEdBQUdELE9BQU9FLFFBQVEsR0FBRztJQUNwQ0YsT0FBT0csTUFBTSxHQUFHO0lBRWxCLDhEQUE4RDtJQUM1REgsT0FBT0ksV0FBVyxHQUFHLENBQUVYLENBQUFBLFFBQVFBLEtBQUtXLFdBQVcsS0FBSyxLQUFJO0lBRXhESixPQUFPVCxLQUFLLEdBQUcsU0FBVUcsSUFBSTtRQUMzQkgsTUFBTWMsSUFBSSxDQUFDLElBQUksRUFBRVg7UUFDakIsT0FBTyxDQUFDTSxPQUFPRyxNQUFNO0lBQ3ZCO0lBRUEsU0FBU0c7UUFDUCxNQUFNUixPQUFPUyxNQUFNLElBQUksQ0FBQ1AsT0FBT0csTUFBTSxDQUFFO1lBQ3JDLElBQUlULE9BQU9JLE9BQU9VLEtBQUs7WUFDdkIsSUFBRyxTQUFTZCxNQUNWLE9BQU9NLE9BQU9TLElBQUksQ0FBQztpQkFFbkJULE9BQU9TLElBQUksQ0FBQyxRQUFRZjtRQUN4QjtJQUNGO0lBRUFNLE9BQU9MLEtBQUssR0FBR0ssT0FBT1UsSUFBSSxHQUFHLFNBQVVoQixJQUFJO1FBQzdDLDBCQUEwQjtRQUN0QixJQUFHSyxRQUFRLE9BQU9DO1FBQ2xCLElBQUdOLFNBQVMsTUFBTUssU0FBUztRQUMzQkQsT0FBT1ksSUFBSSxDQUFDaEI7UUFDWlk7UUFDQSxPQUFPTjtJQUNUO0lBRUEscURBQXFEO0lBQ3JELDJEQUEyRDtJQUMzRCx5QkFBeUI7SUFDekIsNkRBQTZEO0lBQzdELDRFQUE0RTtJQUU1RUEsT0FBT1csRUFBRSxDQUFDLE9BQU87UUFDZlgsT0FBT0MsUUFBUSxHQUFHO1FBQ2xCLElBQUcsQ0FBQ0QsT0FBT0UsUUFBUSxJQUFJRixPQUFPSSxXQUFXLEVBQ3ZDUSxRQUFRQyxRQUFRLENBQUM7WUFDZmIsT0FBT2MsT0FBTztRQUNoQjtJQUNKO0lBRUEsU0FBU0M7UUFDUGYsT0FBT0UsUUFBUSxHQUFHO1FBQ2xCVixJQUFJYSxJQUFJLENBQUNMO1FBQ1QsSUFBRyxDQUFDQSxPQUFPQyxRQUFRLElBQUlELE9BQU9JLFdBQVcsRUFDdkNKLE9BQU9jLE9BQU87SUFDbEI7SUFFQWQsT0FBT1IsR0FBRyxHQUFHLFNBQVVFLElBQUk7UUFDekIsSUFBR0UsT0FBTztRQUNWQSxRQUFRO1FBQ1IsSUFBR29CLFVBQVVULE1BQU0sRUFBRVAsT0FBT1QsS0FBSyxDQUFDRztRQUNsQ3FCLE9BQU8scUJBQXFCOztRQUM1QixPQUFPZjtJQUNUO0lBRUFBLE9BQU9jLE9BQU8sR0FBRztRQUNmLElBQUdqQixXQUFXO1FBQ2RBLFlBQVk7UUFDWkQsUUFBUTtRQUNSRSxPQUFPUyxNQUFNLEdBQUc7UUFDaEJQLE9BQU9FLFFBQVEsR0FBR0YsT0FBT0MsUUFBUSxHQUFHO1FBQ3BDRCxPQUFPUyxJQUFJLENBQUM7UUFDWixPQUFPVDtJQUNUO0lBRUFBLE9BQU9pQixLQUFLLEdBQUc7UUFDYixJQUFHakIsT0FBT0csTUFBTSxFQUFFO1FBQ2xCSCxPQUFPRyxNQUFNLEdBQUc7UUFDaEIsT0FBT0g7SUFDVDtJQUVBQSxPQUFPa0IsTUFBTSxHQUFHO1FBQ2QsSUFBR2xCLE9BQU9HLE1BQU0sRUFBRTtZQUNoQkgsT0FBT0csTUFBTSxHQUFHO1lBQ2hCSCxPQUFPUyxJQUFJLENBQUM7UUFDZDtRQUNBSDtRQUNBLCtCQUErQjtRQUMvQix3QkFBd0I7UUFDeEIsSUFBRyxDQUFDTixPQUFPRyxNQUFNLEVBQ2ZILE9BQU9TLElBQUksQ0FBQztRQUNkLE9BQU9UO0lBQ1Q7SUFDQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS90aHJvdWdoQDIuMy44L25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzPzdhMmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIl0sIm5hbWVzIjpbIlN0cmVhbSIsInJlcXVpcmUiLCJleHBvcnRzIiwibW9kdWxlIiwidGhyb3VnaCIsIndyaXRlIiwiZW5kIiwib3B0cyIsImRhdGEiLCJxdWV1ZSIsImVuZGVkIiwiZGVzdHJveWVkIiwiYnVmZmVyIiwiX2VuZGVkIiwic3RyZWFtIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsInBhdXNlZCIsImF1dG9EZXN0cm95IiwiY2FsbCIsImRyYWluIiwibGVuZ3RoIiwic2hpZnQiLCJlbWl0IiwicHVzaCIsIm9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZGVzdHJveSIsIl9lbmQiLCJhcmd1bWVudHMiLCJwYXVzZSIsInJlc3VtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/through@2.3.8/node_modules/through/index.js\n");

/***/ })

};
;