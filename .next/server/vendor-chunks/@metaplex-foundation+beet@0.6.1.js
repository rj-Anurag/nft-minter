"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metaplex-foundation+beet@0.6.1";
exports.ids = ["vendor-chunks/@metaplex-foundation+beet@0.6.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fixBeetFromValue = exports.fixBeetFromData = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided data.\n *\n * @param beet to convert\n * @param buf containing serialized data that the fixed beet needs to process\n * @param offset at which the data for the beet starts\n *\n * @category beet\n */ function fixBeetFromData(beet, buf, offset) {\n    if ((0, types_1.isFixedSizeBeet)(beet)) {\n        return beet;\n    }\n    if ((0, types_1.isFixableBeet)(beet)) {\n        return beet.toFixedFromData(buf, offset);\n    }\n    throw new utils_1.UnreachableCaseError(beet);\n}\nexports.fixBeetFromData = fixBeetFromData;\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided value.\n *\n * @param beet to convert\n * @param val value that the fixed beet needs to process\n *\n * @category beet\n */ function fixBeetFromValue(beet, val) {\n    if ((0, types_1.isFixedSizeBeet)(beet)) {\n        return beet;\n    }\n    if ((0, types_1.isFixableBeet)(beet)) {\n        return beet.toFixedFromValue(val);\n    }\n    throw new utils_1.UnreachableCaseError(beet);\n}\nexports.fixBeetFromValue = fixBeetFromValue; //# sourceMappingURL=beet.fixable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldC5maXhhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQyx3SUFBUztBQUNqQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyx3SUFBUztBQUNqQzs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRixnQkFBZ0JJLElBQUksRUFBRUMsR0FBRyxFQUFFQyxNQUFNO0lBQ3RDLElBQUksQ0FBQyxHQUFHTCxRQUFRTSxlQUFlLEVBQUVILE9BQU87UUFDcEMsT0FBT0E7SUFDWDtJQUNBLElBQUksQ0FBQyxHQUFHSCxRQUFRTyxhQUFhLEVBQUVKLE9BQU87UUFDbEMsT0FBT0EsS0FBS0ssZUFBZSxDQUFDSixLQUFLQztJQUNyQztJQUNBLE1BQU0sSUFBSUgsUUFBUU8sb0JBQW9CLENBQUNOO0FBQzNDO0FBQ0FQLHVCQUF1QixHQUFHRztBQUMxQjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELGlCQUFpQkssSUFBSSxFQUFFTyxHQUFHO0lBQy9CLElBQUksQ0FBQyxHQUFHVixRQUFRTSxlQUFlLEVBQUVILE9BQU87UUFDcEMsT0FBT0E7SUFDWDtJQUNBLElBQUksQ0FBQyxHQUFHSCxRQUFRTyxhQUFhLEVBQUVKLE9BQU87UUFDbEMsT0FBT0EsS0FBS1EsZ0JBQWdCLENBQUNEO0lBQ2pDO0lBQ0EsTUFBTSxJQUFJUixRQUFRTyxvQkFBb0IsQ0FBQ047QUFDM0M7QUFDQVAsd0JBQXdCLEdBQUdFLGtCQUMzQix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhcGxleC1mb3VuZGF0aW9uK2JlZXRAMC42LjEvbm9kZV9tb2R1bGVzL0BtZXRhcGxleC1mb3VuZGF0aW9uL2JlZXQvZGlzdC9janMvc3JjL2JlZXQuZml4YWJsZS5qcz9kZTYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maXhCZWV0RnJvbVZhbHVlID0gZXhwb3J0cy5maXhCZWV0RnJvbURhdGEgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBiZWV0IGludG8gYSB7QGxpbmsgRml4ZWRCZWV0fSB1bmxlc3MgaXQgYWxyZWFkeSBpcy5cbiAqIFRoZSBzaXplcyBmb3Ige0BsaW5rIEZpeGFibGVCZWV0fXMgYXJlIGRldGVybWluZWQgZnJvbSB0aGUgcHJvdmlkZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gYmVldCB0byBjb252ZXJ0XG4gKiBAcGFyYW0gYnVmIGNvbnRhaW5pbmcgc2VyaWFsaXplZCBkYXRhIHRoYXQgdGhlIGZpeGVkIGJlZXQgbmVlZHMgdG8gcHJvY2Vzc1xuICogQHBhcmFtIG9mZnNldCBhdCB3aGljaCB0aGUgZGF0YSBmb3IgdGhlIGJlZXQgc3RhcnRzXG4gKlxuICogQGNhdGVnb3J5IGJlZXRcbiAqL1xuZnVuY3Rpb24gZml4QmVldEZyb21EYXRhKGJlZXQsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzRml4ZWRTaXplQmVldCkoYmVldCkpIHtcbiAgICAgICAgcmV0dXJuIGJlZXQ7XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc0ZpeGFibGVCZWV0KShiZWV0KSkge1xuICAgICAgICByZXR1cm4gYmVldC50b0ZpeGVkRnJvbURhdGEoYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgdXRpbHNfMS5VbnJlYWNoYWJsZUNhc2VFcnJvcihiZWV0KTtcbn1cbmV4cG9ydHMuZml4QmVldEZyb21EYXRhID0gZml4QmVldEZyb21EYXRhO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYmVldCBpbnRvIGEge0BsaW5rIEZpeGVkQmVldH0gdW5sZXNzIGl0IGFscmVhZHkgaXMuXG4gKiBUaGUgc2l6ZXMgZm9yIHtAbGluayBGaXhhYmxlQmVldH1zIGFyZSBkZXRlcm1pbmVkIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBiZWV0IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB2YWwgdmFsdWUgdGhhdCB0aGUgZml4ZWQgYmVldCBuZWVkcyB0byBwcm9jZXNzXG4gKlxuICogQGNhdGVnb3J5IGJlZXRcbiAqL1xuZnVuY3Rpb24gZml4QmVldEZyb21WYWx1ZShiZWV0LCB2YWwpIHtcbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNGaXhlZFNpemVCZWV0KShiZWV0KSkge1xuICAgICAgICByZXR1cm4gYmVldDtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzRml4YWJsZUJlZXQpKGJlZXQpKSB7XG4gICAgICAgIHJldHVybiBiZWV0LnRvRml4ZWRGcm9tVmFsdWUodmFsKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IHV0aWxzXzEuVW5yZWFjaGFibGVDYXNlRXJyb3IoYmVldCk7XG59XG5leHBvcnRzLmZpeEJlZXRGcm9tVmFsdWUgPSBmaXhCZWV0RnJvbVZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVldC5maXhhYmxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZpeEJlZXRGcm9tVmFsdWUiLCJmaXhCZWV0RnJvbURhdGEiLCJ0eXBlc18xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJiZWV0IiwiYnVmIiwib2Zmc2V0IiwiaXNGaXhlZFNpemVCZWV0IiwiaXNGaXhhYmxlQmVldCIsInRvRml4ZWRGcm9tRGF0YSIsIlVucmVhY2hhYmxlQ2FzZUVycm9yIiwidmFsIiwidG9GaXhlZEZyb21WYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.supportedTypeMap = void 0;\nconst collections_1 = __webpack_require__(/*! ./beets/collections */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js\");\nconst composites_1 = __webpack_require__(/*! ./beets/composites */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js\");\nconst numbers_1 = __webpack_require__(/*! ./beets/numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\");\nconst string_1 = __webpack_require__(/*! ./beets/string */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js\");\nconst enums_1 = __webpack_require__(/*! ./beets/enums */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js\");\nconst aliases_1 = __webpack_require__(/*! ./beets/aliases */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js\");\nconst tuples_1 = __webpack_require__(/*! ./beets/tuples */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js\");\nconst maps_1 = __webpack_require__(/*! ./beets/maps */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js\");\nconst unit_1 = __webpack_require__(/*! ./beets/unit */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js\");\n__exportStar(__webpack_require__(/*! ./beets/aliases */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/collections */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/composites */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/enums */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/maps */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/string */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/tuples */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beets/unit */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js\"), exports);\n__exportStar(__webpack_require__(/*! ./beet.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./read-write */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js\"), exports);\n__exportStar(__webpack_require__(/*! ./struct */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js\"), exports);\n__exportStar(__webpack_require__(/*! ./struct.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\"), exports);\n/**\n * Maps all {@link Beet} de/serializers to metadata which describes in which\n * package it is defined as well as which TypeScript type is used to represent\n * the deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.supportedTypeMap = {\n    ...collections_1.collectionsTypeMap,\n    ...string_1.stringTypeMap,\n    ...composites_1.compositesTypeMap,\n    ...enums_1.enumsTypeMap,\n    ...numbers_1.numbersTypeMap,\n    ...aliases_1.aliasesTypeMap,\n    ...tuples_1.tuplesTypeMap,\n    ...maps_1.mapsTypeMap,\n    ...unit_1.unitTypeMap\n}; //# sourceMappingURL=beet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REwsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNTyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGdLQUFxQjtBQUNuRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4SkFBb0I7QUFDakQsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsd0pBQWlCO0FBQzNDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLHNKQUFnQjtBQUN6QyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyxvSkFBZTtBQUN2QyxNQUFNSyxZQUFZTCxtQkFBT0EsQ0FBQyx3SkFBaUI7QUFDM0MsTUFBTU0sV0FBV04sbUJBQU9BLENBQUMsc0pBQWdCO0FBQ3pDLE1BQU1PLFNBQVNQLG1CQUFPQSxDQUFDLGtKQUFjO0FBQ3JDLE1BQU1RLFNBQVNSLG1CQUFPQSxDQUFDLGtKQUFjO0FBQ3JDVCxhQUFhUyxtQkFBT0EsQ0FBQyx3SkFBaUIsR0FBR1I7QUFDekNELGFBQWFTLG1CQUFPQSxDQUFDLGdLQUFxQixHQUFHUjtBQUM3Q0QsYUFBYVMsbUJBQU9BLENBQUMsOEpBQW9CLEdBQUdSO0FBQzVDRCxhQUFhUyxtQkFBT0EsQ0FBQyxvSkFBZSxHQUFHUjtBQUN2Q0QsYUFBYVMsbUJBQU9BLENBQUMsa0pBQWMsR0FBR1I7QUFDdENELGFBQWFTLG1CQUFPQSxDQUFDLHdKQUFpQixHQUFHUjtBQUN6Q0QsYUFBYVMsbUJBQU9BLENBQUMsc0pBQWdCLEdBQUdSO0FBQ3hDRCxhQUFhUyxtQkFBT0EsQ0FBQyxzSkFBZ0IsR0FBR1I7QUFDeENELGFBQWFTLG1CQUFPQSxDQUFDLGtKQUFjLEdBQUdSO0FBQ3RDRCxhQUFhUyxtQkFBT0EsQ0FBQyxzSkFBZ0IsR0FBR1I7QUFDeENELGFBQWFTLG1CQUFPQSxDQUFDLGtKQUFjLEdBQUdSO0FBQ3RDRCxhQUFhUyxtQkFBT0EsQ0FBQywwSUFBVSxHQUFHUjtBQUNsQ0QsYUFBYVMsbUJBQU9BLENBQUMsMEpBQWtCLEdBQUdSO0FBQzFDRCxhQUFhUyxtQkFBT0EsQ0FBQyx3SUFBUyxHQUFHUjtBQUNqQzs7Ozs7O0NBTUMsR0FDREEsd0JBQXdCLEdBQUc7SUFDdkIsR0FBR08sY0FBY1Usa0JBQWtCO0lBQ25DLEdBQUdOLFNBQVNPLGFBQWE7SUFDekIsR0FBR1QsYUFBYVUsaUJBQWlCO0lBQ2pDLEdBQUdQLFFBQVFRLFlBQVk7SUFDdkIsR0FBR1YsVUFBVVcsY0FBYztJQUMzQixHQUFHUixVQUFVUyxjQUFjO0lBQzNCLEdBQUdSLFNBQVNTLGFBQWE7SUFDekIsR0FBR1IsT0FBT1MsV0FBVztJQUNyQixHQUFHUixPQUFPUyxXQUFXO0FBQ3pCLEdBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YXBsZXgtZm91bmRhdGlvbitiZWV0QDAuNi4xL25vZGVfbW9kdWxlcy9AbWV0YXBsZXgtZm91bmRhdGlvbi9iZWV0L2Rpc3QvY2pzL3NyYy9iZWV0LmpzP2FmZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3VwcG9ydGVkVHlwZU1hcCA9IHZvaWQgMDtcbmNvbnN0IGNvbGxlY3Rpb25zXzEgPSByZXF1aXJlKFwiLi9iZWV0cy9jb2xsZWN0aW9uc1wiKTtcbmNvbnN0IGNvbXBvc2l0ZXNfMSA9IHJlcXVpcmUoXCIuL2JlZXRzL2NvbXBvc2l0ZXNcIik7XG5jb25zdCBudW1iZXJzXzEgPSByZXF1aXJlKFwiLi9iZWV0cy9udW1iZXJzXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9iZWV0cy9zdHJpbmdcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vYmVldHMvZW51bXNcIik7XG5jb25zdCBhbGlhc2VzXzEgPSByZXF1aXJlKFwiLi9iZWV0cy9hbGlhc2VzXCIpO1xuY29uc3QgdHVwbGVzXzEgPSByZXF1aXJlKFwiLi9iZWV0cy90dXBsZXNcIik7XG5jb25zdCBtYXBzXzEgPSByZXF1aXJlKFwiLi9iZWV0cy9tYXBzXCIpO1xuY29uc3QgdW5pdF8xID0gcmVxdWlyZShcIi4vYmVldHMvdW5pdFwiKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iZWV0cy9hbGlhc2VzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iZWV0cy9jb2xsZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmVldHMvY29tcG9zaXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmVldHMvZW51bXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JlZXRzL21hcHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JlZXRzL251bWJlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JlZXRzL3N0cmluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmVldHMvdHVwbGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iZWV0cy91bml0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iZWV0LmZpeGFibGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlYWQtd3JpdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cnVjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0LmZpeGFibGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogTWFwcyBhbGwge0BsaW5rIEJlZXR9IGRlL3NlcmlhbGl6ZXJzIHRvIG1ldGFkYXRhIHdoaWNoIGRlc2NyaWJlcyBpbiB3aGljaFxuICogcGFja2FnZSBpdCBpcyBkZWZpbmVkIGFzIHdlbGwgYXMgd2hpY2ggVHlwZVNjcmlwdCB0eXBlIGlzIHVzZWQgdG8gcmVwcmVzZW50XG4gKiB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIGluIEphdmFTY3JpcHQuXG4gKlxuICogQGNhdGVnb3J5IFR5cGVEZWZpbml0aW9uXG4gKi9cbmV4cG9ydHMuc3VwcG9ydGVkVHlwZU1hcCA9IHtcbiAgICAuLi5jb2xsZWN0aW9uc18xLmNvbGxlY3Rpb25zVHlwZU1hcCxcbiAgICAuLi5zdHJpbmdfMS5zdHJpbmdUeXBlTWFwLFxuICAgIC4uLmNvbXBvc2l0ZXNfMS5jb21wb3NpdGVzVHlwZU1hcCxcbiAgICAuLi5lbnVtc18xLmVudW1zVHlwZU1hcCxcbiAgICAuLi5udW1iZXJzXzEubnVtYmVyc1R5cGVNYXAsXG4gICAgLi4uYWxpYXNlc18xLmFsaWFzZXNUeXBlTWFwLFxuICAgIC4uLnR1cGxlc18xLnR1cGxlc1R5cGVNYXAsXG4gICAgLi4ubWFwc18xLm1hcHNUeXBlTWFwLFxuICAgIC4uLnVuaXRfMS51bml0VHlwZU1hcCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWV0LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwic3VwcG9ydGVkVHlwZU1hcCIsImNvbGxlY3Rpb25zXzEiLCJyZXF1aXJlIiwiY29tcG9zaXRlc18xIiwibnVtYmVyc18xIiwic3RyaW5nXzEiLCJlbnVtc18xIiwiYWxpYXNlc18xIiwidHVwbGVzXzEiLCJtYXBzXzEiLCJ1bml0XzEiLCJjb2xsZWN0aW9uc1R5cGVNYXAiLCJzdHJpbmdUeXBlTWFwIiwiY29tcG9zaXRlc1R5cGVNYXAiLCJlbnVtc1R5cGVNYXAiLCJudW1iZXJzVHlwZU1hcCIsImFsaWFzZXNUeXBlTWFwIiwidHVwbGVzVHlwZU1hcCIsIm1hcHNUeXBlTWFwIiwidW5pdFR5cGVNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.aliasesTypeMap = exports.bytes = void 0;\nconst collections_1 = __webpack_require__(/*! ./collections */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js\");\n/**\n * Alias for {@link uint8Array}.\n * @category TypeDefinition\n */ exports.bytes = collections_1.uint8Array;\nexports.aliasesTypeMap = {\n    // @ts-ignore\n    bytes: collections_1.collectionsTypeMap.Uint8Array\n}; //# sourceMappingURL=aliases.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvYWxpYXNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQzlDLE1BQU1JLGdCQUFnQkMsbUJBQU9BLENBQUMsMEpBQWU7QUFDN0M7OztDQUdDLEdBQ0RMLGFBQWEsR0FBR0ksY0FBY0UsVUFBVTtBQUN4Q04sc0JBQXNCLEdBQUc7SUFDckIsYUFBYTtJQUNiRyxPQUFPQyxjQUFjRyxrQkFBa0IsQ0FBQ0MsVUFBVTtBQUN0RCxHQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvYWxpYXNlcy5qcz9jMTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGlhc2VzVHlwZU1hcCA9IGV4cG9ydHMuYnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBjb2xsZWN0aW9uc18xID0gcmVxdWlyZShcIi4vY29sbGVjdGlvbnNcIik7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdWludDhBcnJheX0uXG4gKiBAY2F0ZWdvcnkgVHlwZURlZmluaXRpb25cbiAqL1xuZXhwb3J0cy5ieXRlcyA9IGNvbGxlY3Rpb25zXzEudWludDhBcnJheTtcbmV4cG9ydHMuYWxpYXNlc1R5cGVNYXAgPSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJ5dGVzOiBjb2xsZWN0aW9uc18xLmNvbGxlY3Rpb25zVHlwZU1hcC5VaW50OEFycmF5LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsaWFzZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWxpYXNlc1R5cGVNYXAiLCJieXRlcyIsImNvbGxlY3Rpb25zXzEiLCJyZXF1aXJlIiwidWludDhBcnJheSIsImNvbGxlY3Rpb25zVHlwZU1hcCIsIlVpbnQ4QXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.collectionsTypeMap = exports.uint8Array = exports.fixedSizeUint8Array = exports.fixedSizeBuffer = exports.array = exports.fixedSizeArray = exports.uniformFixedSizeArray = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst numbers_1 = __webpack_require__(/*! ./numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\");\nconst types_2 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\nconst beet_fixable_1 = __webpack_require__(/*! ../beet.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\");\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element type\n * @param len the number of elements in the array\n * @param lenPrefix if `true` a 4 byte number indicating the size of the array\n * will be included before serialized array data\n *\n * @category beet/collection\n */ function uniformFixedSizeArray(element, len, lenPrefix = false) {\n    const arraySize = element.byteSize * len;\n    const byteSize = lenPrefix ? 4 + arraySize : arraySize;\n    return {\n        write: function(buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            if (lenPrefix) {\n                numbers_1.u32.write(buf, offset, len);\n                offset += 4;\n            }\n            for(let i = 0; i < len; i++){\n                element.write(buf, offset + i * element.byteSize, value[i]);\n            }\n        },\n        read: function(buf, offset) {\n            if (lenPrefix) {\n                const size = numbers_1.u32.read(buf, offset);\n                assert_1.strict.equal(size, len, \"invalid byte size\");\n                offset += 4;\n            }\n            const arr = new Array(len);\n            for(let i = 0; i < len; i++){\n                arr[i] = element.read(buf, offset + i * element.byteSize);\n            }\n            return arr;\n        },\n        byteSize,\n        length: len,\n        elementByteSize: element.byteSize,\n        lenPrefixByteSize: 4,\n        description: `Array<${element.description}>(${len})`\n    };\n}\nexports.uniformFixedSizeArray = uniformFixedSizeArray;\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which do not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param elements the De/Serializers for the element types\n * @param elementsByteSize size of all elements in the array combined\n *\n * @category beet/collection\n */ function fixedSizeArray(elements, elementsByteSize) {\n    const len = elements.length;\n    const firstElement = len === 0 ? \"<EMPTY>\" : elements[0].description;\n    return {\n        write: function(buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            numbers_1.u32.write(buf, offset, len);\n            let cursor = offset + 4;\n            for(let i = 0; i < len; i++){\n                const element = elements[i];\n                element.write(buf, cursor, value[i]);\n                cursor += element.byteSize;\n            }\n        },\n        read: function(buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, len, \"invalid byte size\");\n            let cursor = offset + 4;\n            const arr = new Array(len);\n            for(let i = 0; i < len; i++){\n                const element = elements[i];\n                arr[i] = element.read(buf, cursor);\n                cursor += element.byteSize;\n            }\n            return arr;\n        },\n        byteSize: 4 + elementsByteSize,\n        length: len,\n        description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`\n    };\n}\nexports.fixedSizeArray = fixedSizeArray;\n/**\n * Wraps an array De/Serializer with with elements of type {@link T} which do\n * not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element types\n *\n * @category beet/collection\n */ function array(element) {\n    return {\n        toFixedFromData (buf, offset) {\n            const len = numbers_1.u32.read(buf, offset);\n            (0, utils_1.logTrace)(`${this.description}[${len}]`);\n            const cursorStart = offset + 4;\n            let cursor = cursorStart;\n            const fixedElements = new Array(len);\n            for(let i = 0; i < len; i++){\n                const fixedElement = (0, beet_fixable_1.fixBeetFromData)(element, buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, cursor - cursorStart);\n        },\n        toFixedFromValue (vals) {\n            (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array`);\n            let elementsSize = 0;\n            const fixedElements = new Array(vals.length);\n            for(let i = 0; i < vals.length; i++){\n                const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(element, vals[i]);\n                fixedElements[i] = fixedElement;\n                elementsSize += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, elementsSize);\n        },\n        description: `array`\n    };\n}\nexports.array = array;\n/**\n * A De/Serializer for raw {@link Buffer}s that just copies/reads the buffer bytes\n * to/from the provided buffer.\n *\n * @param bytes the byte size of the buffer to de/serialize\n * @category beet/collection\n */ function fixedSizeBuffer(bytes) {\n    return {\n        write: function(buf, offset, value) {\n            value.copy(buf, offset, 0, bytes);\n        },\n        read: function(buf, offset) {\n            return buf.slice(offset, offset + bytes);\n        },\n        byteSize: bytes,\n        description: `Buffer(${bytes})`\n    };\n}\nexports.fixedSizeBuffer = fixedSizeBuffer;\n/**\n * A De/Serializer for {@link Uint8Array}s of known size that just copies/reads\n * the array bytes to/from the provided buffer.\n *\n * @category beet/collection\n */ function fixedSizeUint8Array(len, lenPrefix = false) {\n    const arrayBufferBeet = fixedSizeBuffer(len);\n    const byteSize = lenPrefix ? len + 4 : len;\n    return {\n        write: function(buf, offset, value) {\n            assert_1.strict.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);\n            if (lenPrefix) {\n                numbers_1.u32.write(buf, offset, len);\n                offset += 4;\n            }\n            const valueBuf = Buffer.from(value);\n            arrayBufferBeet.write(buf, offset, valueBuf);\n        },\n        read: function(buf, offset) {\n            if (lenPrefix) {\n                const size = numbers_1.u32.read(buf, offset);\n                assert_1.strict.equal(size, len, \"invalid byte size\");\n                offset += 4;\n            }\n            const arrayBuffer = arrayBufferBeet.read(buf, offset);\n            return Uint8Array.from(arrayBuffer);\n        },\n        byteSize,\n        description: `Uint8Array(${len})`\n    };\n}\nexports.fixedSizeUint8Array = fixedSizeUint8Array;\n/**\n * A De/Serializer for {@link Uint8Array}s that just copies/reads the array bytes\n * to/from the provided buffer.\n *\n * @category beet/collection\n */ exports.uint8Array = {\n    toFixedFromData (buf, offset) {\n        const len = numbers_1.u32.read(buf, offset);\n        (0, utils_1.logTrace)(`${this.description}[${len}]`);\n        return fixedSizeUint8Array(len, true);\n    },\n    toFixedFromValue (val) {\n        const len = val.byteLength;\n        return fixedSizeUint8Array(len, true);\n    },\n    description: `Uint8Array`\n};\n/**\n * Maps collections beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.collectionsTypeMap = {\n    Array: {\n        beet: \"array\",\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Array\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    FixedSizeArray: {\n        beet: \"fixedSizeArray\",\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Array\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    UniformFixedSizeArray: {\n        beet: \"uniformFixedSizeArray\",\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Array\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    Buffer: {\n        beet: \"fixedSizeBuffer\",\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Buffer\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    FixedSizeUint8Array: {\n        beet: \"fixedSizeUint8Array\",\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Uint8Array\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    Uint8Array: {\n        beet: \"uint8Array\",\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"Uint8Array\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    }\n}; //# sourceMappingURL=collections.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvY29sbGVjdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHQSxrQkFBa0IsR0FBR0EsMkJBQTJCLEdBQUdBLHVCQUF1QixHQUFHQSxhQUFhLEdBQUdBLHNCQUFzQixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ3hMLE1BQU1TLFVBQVVDLG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLGtKQUFXO0FBQ3JDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLE1BQU1LLGlCQUFpQkwsbUJBQU9BLENBQUMsdUpBQWlCO0FBQ2hEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNGLHNCQUFzQlEsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLFlBQVksS0FBSztJQUMxRCxNQUFNQyxZQUFZSCxRQUFRSSxRQUFRLEdBQUdIO0lBQ3JDLE1BQU1HLFdBQVdGLFlBQVksSUFBSUMsWUFBWUE7SUFDN0MsT0FBTztRQUNIRSxPQUFPLFNBQVVDLEdBQUcsRUFBRUMsTUFBTSxFQUFFdEIsS0FBSztZQUMvQlUsU0FBU2EsTUFBTSxDQUFDQyxLQUFLLENBQUN4QixNQUFNeUIsTUFBTSxFQUFFVCxLQUFLLENBQUMsYUFBYSxFQUFFaEIsTUFBTXlCLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRVQsSUFBSSxDQUFDO1lBQy9GLElBQUlDLFdBQVc7Z0JBQ1hOLFVBQVVlLEdBQUcsQ0FBQ04sS0FBSyxDQUFDQyxLQUFL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SUFDQVgsUUFBUTtRQUNKSyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsWUFBWW5ELFFBQVFvRCxZQUFZO1FBQ2hDQyxJQUFJO1FBQ0pDLEtBQUsxRCxRQUFRMkQsaUJBQWlCO0lBQ2xDO0lBQ0FHLHFCQUFxQjtRQUNqQlQsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLFlBQVluRCxRQUFRb0QsWUFBWTtRQUNoQ0MsSUFBSTtRQUNKQyxLQUFLMUQsUUFBUTJELGlCQUFpQjtJQUNsQztJQUNBUixZQUFZO1FBQ1JFLE1BQU07UUFDTkMsV0FBVztRQUNYQyxZQUFZbkQsUUFBUW9ELFlBQVk7UUFDaENDLElBQUk7UUFDSkMsS0FBSzFELFFBQVEyRCxpQkFBaUI7SUFDbEM7QUFDSixHQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvY29sbGVjdGlvbnMuanM/YWYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29sbGVjdGlvbnNUeXBlTWFwID0gZXhwb3J0cy51aW50OEFycmF5ID0gZXhwb3J0cy5maXhlZFNpemVVaW50OEFycmF5ID0gZXhwb3J0cy5maXhlZFNpemVCdWZmZXIgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5maXhlZFNpemVBcnJheSA9IGV4cG9ydHMudW5pZm9ybUZpeGVkU2l6ZUFycmF5ID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IG51bWJlcnNfMSA9IHJlcXVpcmUoXCIuL251bWJlcnNcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGJlZXRfZml4YWJsZV8xID0gcmVxdWlyZShcIi4uL2JlZXQuZml4YWJsZVwiKTtcbi8qKlxuICogRGUvU2VyaWFsaXplcyBhbiBhcnJheSB3aXRoIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHR5cGUge0BsaW5rIFR9XG4gKiB3aGljaCBhbGwgaGF2ZSB0aGUgc2FtZSBzaXplLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIHR5cGUgb2YgZWxlbWVudHMgaGVsZCBpbiB0aGUgYXJyYXlcbiAqXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgRGUvU2VyaWFsaXplciBmb3IgdGhlIGVsZW1lbnQgdHlwZVxuICogQHBhcmFtIGxlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICogQHBhcmFtIGxlblByZWZpeCBpZiBgdHJ1ZWAgYSA0IGJ5dGUgbnVtYmVyIGluZGljYXRpbmcgdGhlIHNpemUgb2YgdGhlIGFycmF5XG4gKiB3aWxsIGJlIGluY2x1ZGVkIGJlZm9yZSBzZXJpYWxpemVkIGFycmF5IGRhdGFcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHVuaWZvcm1GaXhlZFNpemVBcnJheShlbGVtZW50LCBsZW4sIGxlblByZWZpeCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXJyYXlTaXplID0gZWxlbWVudC5ieXRlU2l6ZSAqIGxlbjtcbiAgICBjb25zdCBieXRlU2l6ZSA9IGxlblByZWZpeCA/IDQgKyBhcnJheVNpemUgOiBhcnJheVNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5lcXVhbCh2YWx1ZS5sZW5ndGgsIGxlbiwgYGFycmF5IGxlbmd0aCAke3ZhbHVlLmxlbmd0aH0gc2hvdWxkIG1hdGNoIGxlbiAke2xlbn1gKTtcbiAgICAgICAgICAgIGlmIChsZW5QcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJzXzEudTMyLndyaXRlKGJ1Ziwgb2Zmc2V0LCBsZW4pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQud3JpdGUoYnVmLCBvZmZzZXQgKyBpICogZWxlbWVudC5ieXRlU2l6ZSwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChsZW5QcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhc3NlcnRfMS5zdHJpY3QuZXF1YWwoc2l6ZSwgbGVuLCAnaW52YWxpZCBieXRlIHNpemUnKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGVsZW1lbnQucmVhZChidWYsIG9mZnNldCArIGkgKiBlbGVtZW50LmJ5dGVTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sXG4gICAgICAgIGJ5dGVTaXplLFxuICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgZWxlbWVudEJ5dGVTaXplOiBlbGVtZW50LmJ5dGVTaXplLFxuICAgICAgICBsZW5QcmVmaXhCeXRlU2l6ZTogNCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBBcnJheTwke2VsZW1lbnQuZGVzY3JpcHRpb259Pigke2xlbn0pYCxcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtRml4ZWRTaXplQXJyYXkgPSB1bmlmb3JtRml4ZWRTaXplQXJyYXk7XG4vKipcbiAqIERlL1NlcmlhbGl6ZXMgYW4gYXJyYXkgd2l0aCBhIHNwZWNpZmljIG51bWJlciBvZiBlbGVtZW50cyBvZiB0eXBlIHtAbGluayBUfVxuICogd2hpY2ggZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNpemUuXG4gKlxuICogQHRlbXBsYXRlIFQgdHlwZSBvZiBlbGVtZW50cyBoZWxkIGluIHRoZSBhcnJheVxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyB0aGUgRGUvU2VyaWFsaXplcnMgZm9yIHRoZSBlbGVtZW50IHR5cGVzXG4gKiBAcGFyYW0gZWxlbWVudHNCeXRlU2l6ZSBzaXplIG9mIGFsbCBlbGVtZW50cyBpbiB0aGUgYXJyYXkgY29tYmluZWRcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpeGVkU2l6ZUFycmF5KGVsZW1lbnRzLCBlbGVtZW50c0J5dGVTaXplKSB7XG4gICAgY29uc3QgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGxlbiA9PT0gMCA/ICc8RU1QVFk+JyA6IGVsZW1lbnRzWzBdLmRlc2NyaXB0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnRfMS5zdHJpY3QuZXF1YWwodmFsdWUubGVuZ3RoLCBsZW4sIGBhcnJheSBsZW5ndGggJHt2YWx1ZS5sZW5ndGh9IHNob3VsZCBtYXRjaCBsZW4gJHtsZW59YCk7XG4gICAgICAgICAgICBudW1iZXJzXzEudTMyLndyaXRlKGJ1Ziwgb2Zmc2V0LCBsZW4pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQud3JpdGUoYnVmLCBjdXJzb3IsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gZWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5lcXVhbChzaXplLCBsZW4sICdpbnZhbGlkIGJ5dGUgc2l6ZScpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gZWxlbWVudC5yZWFkKGJ1ZiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gZWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sXG4gICAgICAgIGJ5dGVTaXplOiA0ICsgZWxlbWVudHNCeXRlU2l6ZSxcbiAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQXJyYXk8JHtmaXJzdEVsZW1lbnR9Pigke2xlbn0pWyA0ICsgJHtlbGVtZW50c0J5dGVTaXplfSBdYCxcbiAgICB9O1xufVxuZXhwb3J0cy5maXhlZFNpemVBcnJheSA9IGZpeGVkU2l6ZUFycmF5O1xuLyoqXG4gKiBXcmFwcyBhbiBhcnJheSBEZS9TZXJpYWxpemVyIHdpdGggd2l0aCBlbGVtZW50cyBvZiB0eXBlIHtAbGluayBUfSB3aGljaCBkb1xuICogbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNpemUuXG4gKlxuICogQHRlbXBsYXRlIFQgdHlwZSBvZiBlbGVtZW50cyBoZWxkIGluIHRoZSBhcnJheVxuICpcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBEZS9TZXJpYWxpemVyIGZvciB0aGUgZWxlbWVudCB0eXBlc1xuICpcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gYXJyYXkoZWxlbWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmxvZ1RyYWNlKShgJHt0aGlzLmRlc2NyaXB0aW9ufVske2xlbn1dYCk7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JTdGFydCA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gY3Vyc29yU3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBmaXhlZEVsZW1lbnRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZml4ZWRFbGVtZW50ID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tRGF0YSkoZWxlbWVudCwgYnVmLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGZpeGVkRWxlbWVudHNbaV0gPSBmaXhlZEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGZpeGVkRWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXhlZFNpemVBcnJheShmaXhlZEVsZW1lbnRzLCBjdXJzb3IgLSBjdXJzb3JTdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvRml4ZWRGcm9tVmFsdWUodmFscykge1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLnN0cmljdCkoQXJyYXkuaXNBcnJheSh2YWxzKSwgYCR7dmFsc30gc2hvdWxkIGJlIGFuIGFycmF5YCk7XG4gICAgICAgICAgICBsZXQgZWxlbWVudHNTaXplID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBuZXcgQXJyYXkodmFscy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZml4ZWRFbGVtZW50ID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tVmFsdWUpKGVsZW1lbnQsIHZhbHNbaV0pO1xuICAgICAgICAgICAgICAgIGZpeGVkRWxlbWVudHNbaV0gPSBmaXhlZEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudHNTaXplICs9IGZpeGVkRWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXhlZFNpemVBcnJheShmaXhlZEVsZW1lbnRzLCBlbGVtZW50c1NpemUpO1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogYGFycmF5YCxcbiAgICB9O1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuLyoqXG4gKiBBIERlL1NlcmlhbGl6ZXIgZm9yIHJhdyB7QGxpbmsgQnVmZmVyfXMgdGhhdCBqdXN0IGNvcGllcy9yZWFkcyB0aGUgYnVmZmVyIGJ5dGVzXG4gKiB0by9mcm9tIHRoZSBwcm92aWRlZCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIHNpemUgb2YgdGhlIGJ1ZmZlciB0byBkZS9zZXJpYWxpemVcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZml4ZWRTaXplQnVmZmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLmNvcHkoYnVmLCBvZmZzZXQsIDAsIGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBieXRlU2l6ZTogYnl0ZXMsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQnVmZmVyKCR7Ynl0ZXN9KWAsXG4gICAgfTtcbn1cbmV4cG9ydHMuZml4ZWRTaXplQnVmZmVyID0gZml4ZWRTaXplQnVmZmVyO1xuLyoqXG4gKiBBIERlL1NlcmlhbGl6ZXIgZm9yIHtAbGluayBVaW50OEFycmF5fXMgb2Yga25vd24gc2l6ZSB0aGF0IGp1c3QgY29waWVzL3JlYWRzXG4gKiB0aGUgYXJyYXkgYnl0ZXMgdG8vZnJvbSB0aGUgcHJvdmlkZWQgYnVmZmVyLlxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZml4ZWRTaXplVWludDhBcnJheShsZW4sIGxlblByZWZpeCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXJyYXlCdWZmZXJCZWV0ID0gZml4ZWRTaXplQnVmZmVyKGxlbik7XG4gICAgY29uc3QgYnl0ZVNpemUgPSBsZW5QcmVmaXggPyBsZW4gKyA0IDogbGVuO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnRfMS5zdHJpY3QuZXF1YWwodmFsdWUuYnl0ZUxlbmd0aCwgbGVuLCBgVWludDhBcnJheSBsZW5ndGggJHt2YWx1ZS5ieXRlTGVuZ3RofSBzaG91bGQgbWF0Y2ggbGVuICR7bGVufWApO1xuICAgICAgICAgICAgaWYgKGxlblByZWZpeCkge1xuICAgICAgICAgICAgICAgIG51bWJlcnNfMS51MzIud3JpdGUoYnVmLCBvZmZzZXQsIGxlbik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJ1ZiA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgIGFycmF5QnVmZmVyQmVldC53cml0ZShidWYsIG9mZnNldCwgdmFsdWVCdWYpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChsZW5QcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhc3NlcnRfMS5zdHJpY3QuZXF1YWwoc2l6ZSwgbGVuLCAnaW52YWxpZCBieXRlIHNpemUnKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXJCZWV0LnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnJheUJ1ZmZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGJ5dGVTaXplLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFVpbnQ4QXJyYXkoJHtsZW59KWAsXG4gICAgfTtcbn1cbmV4cG9ydHMuZml4ZWRTaXplVWludDhBcnJheSA9IGZpeGVkU2l6ZVVpbnQ4QXJyYXk7XG4vKipcbiAqIEEgRGUvU2VyaWFsaXplciBmb3Ige0BsaW5rIFVpbnQ4QXJyYXl9cyB0aGF0IGp1c3QgY29waWVzL3JlYWRzIHRoZSBhcnJheSBieXRlc1xuICogdG8vZnJvbSB0aGUgcHJvdmlkZWQgYnVmZmVyLlxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbGxlY3Rpb25cbiAqL1xuZXhwb3J0cy51aW50OEFycmF5ID0ge1xuICAgIHRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBsZW4gPSBudW1iZXJzXzEudTMyLnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAoMCwgdXRpbHNfMS5sb2dUcmFjZSkoYCR7dGhpcy5kZXNjcmlwdGlvbn1bJHtsZW59XWApO1xuICAgICAgICByZXR1cm4gZml4ZWRTaXplVWludDhBcnJheShsZW4sIHRydWUpO1xuICAgIH0sXG4gICAgdG9GaXhlZEZyb21WYWx1ZSh2YWwpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdmFsLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiBmaXhlZFNpemVVaW50OEFycmF5KGxlbiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjogYFVpbnQ4QXJyYXlgLFxufTtcbi8qKlxuICogTWFwcyBjb2xsZWN0aW9ucyBiZWV0IGV4cG9ydHMgdG8gbWV0YWRhdGEgd2hpY2ggZGVzY3JpYmVzIGluIHdoaWNoIHBhY2thZ2UgaXRcbiAqIGlzIGRlZmluZWQgYXMgd2VsbCBhcyB3aGljaCBUeXBlU2NyaXB0IHR5cGUgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlXG4gKiBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHlwZURlZmluaXRpb25cbiAqL1xuZXhwb3J0cy5jb2xsZWN0aW9uc1R5cGVNYXAgPSB7XG4gICAgQXJyYXk6IHtcbiAgICAgICAgYmVldDogJ2FycmF5JyxcbiAgICAgICAgaXNGaXhhYmxlOiB0cnVlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18yLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdBcnJheScsXG4gICAgICAgIGFyZzogdHlwZXNfMS5CRUVUX1RZUEVfQVJHX0xFTixcbiAgICB9LFxuICAgIEZpeGVkU2l6ZUFycmF5OiB7XG4gICAgICAgIGJlZXQ6ICdmaXhlZFNpemVBcnJheScsXG4gICAgICAgIGlzRml4YWJsZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVBhY2s6IHR5cGVzXzIuQkVFVF9QQUNLQUdFLFxuICAgICAgICB0czogJ0FycmF5JyxcbiAgICAgICAgYXJnOiB0eXBlc18xLkJFRVRfVFlQRV9BUkdfTEVOLFxuICAgIH0sXG4gICAgVW5pZm9ybUZpeGVkU2l6ZUFycmF5OiB7XG4gICAgICAgIGJlZXQ6ICd1bmlmb3JtRml4ZWRTaXplQXJyYXknLFxuICAgICAgICBpc0ZpeGFibGU6IGZhbHNlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18yLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdBcnJheScsXG4gICAgICAgIGFyZzogdHlwZXNfMS5CRUVUX1RZUEVfQVJHX0xFTixcbiAgICB9LFxuICAgIEJ1ZmZlcjoge1xuICAgICAgICBiZWV0OiAnZml4ZWRTaXplQnVmZmVyJyxcbiAgICAgICAgaXNGaXhhYmxlOiBmYWxzZSxcbiAgICAgICAgc291cmNlUGFjazogdHlwZXNfMi5CRUVUX1BBQ0tBR0UsXG4gICAgICAgIHRzOiAnQnVmZmVyJyxcbiAgICAgICAgYXJnOiB0eXBlc18xLkJFRVRfVFlQRV9BUkdfTEVOLFxuICAgIH0sXG4gICAgRml4ZWRTaXplVWludDhBcnJheToge1xuICAgICAgICBiZWV0OiAnZml4ZWRTaXplVWludDhBcnJheScsXG4gICAgICAgIGlzRml4YWJsZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVBhY2s6IHR5cGVzXzIuQkVFVF9QQUNLQUdFLFxuICAgICAgICB0czogJ1VpbnQ4QXJyYXknLFxuICAgICAgICBhcmc6IHR5cGVzXzEuQkVFVF9UWVBFX0FSR19MRU4sXG4gICAgfSxcbiAgICBVaW50OEFycmF5OiB7XG4gICAgICAgIGJlZXQ6ICd1aW50OEFycmF5JyxcbiAgICAgICAgaXNGaXhhYmxlOiB0cnVlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18yLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdVaW50OEFycmF5JyxcbiAgICAgICAgYXJnOiB0eXBlc18xLkJFRVRfVFlQRV9BUkdfTEVOLFxuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29sbGVjdGlvbnNUeXBlTWFwIiwidWludDhBcnJheSIsImZpeGVkU2l6ZVVpbnQ4QXJyYXkiLCJmaXhlZFNpemVCdWZmZXIiLCJhcnJheSIsImZpeGVkU2l6ZUFycmF5IiwidW5pZm9ybUZpeGVkU2l6ZUFycmF5IiwidHlwZXNfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsIm51bWJlcnNfMSIsInR5cGVzXzIiLCJ1dGlsc18xIiwiYmVldF9maXhhYmxlXzEiLCJlbGVtZW50IiwibGVuIiwibGVuUHJlZml4IiwiYXJyYXlTaXplIiwiYnl0ZVNpemUiLCJ3cml0ZSIsImJ1ZiIsIm9mZnNldCIsInN0cmljdCIsImVxdWFsIiwibGVuZ3RoIiwidTMyIiwiaSIsInJlYWQiLCJzaXplIiwiYXJyIiwiQXJyYXkiLCJlbGVtZW50Qnl0ZVNpemUiLCJsZW5QcmVmaXhCeXRlU2l6ZSIsImRlc2NyaXB0aW9uIiwiZWxlbWVudHMiLCJlbGVtZW50c0J5dGVTaXplIiwiZmlyc3RFbGVtZW50IiwiY3Vyc29yIiwidG9GaXhlZEZyb21EYXRhIiwibG9nVHJhY2UiLCJjdXJzb3JTdGFydCIsImZpeGVkRWxlbWVudHMiLCJmaXhlZEVsZW1lbnQiLCJmaXhCZWV0RnJvbURhdGEiLCJ0b0ZpeGVkRnJvbVZhbHVlIiwidmFscyIsImlzQXJyYXkiLCJlbGVtZW50c1NpemUiLCJmaXhCZWV0RnJvbVZhbHVlIiwiYnl0ZXMiLCJjb3B5Iiwic2xpY2UiLCJhcnJheUJ1ZmZlckJlZXQiLCJieXRlTGVuZ3RoIiwidmFsdWVCdWYiLCJCdWZmZXIiLCJmcm9tIiwiYXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwidmFsIiwiYmVldCIsImlzRml4YWJsZSIsInNvdXJjZVBhY2siLCJCRUVUX1BBQ0tBR0UiLCJ0cyIsImFyZyIsIkJFRVRfVFlQRV9BUkdfTEVOIiwiRml4ZWRTaXplQXJyYXkiLCJVbmlmb3JtRml4ZWRTaXplQXJyYXkiLCJGaXhlZFNpemVVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.compositesTypeMap = exports.coption = exports.coptionSome = exports.coptionNone = exports.isNoneBuffer = exports.isSomeBuffer = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst types_2 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\nconst beet_fixable_1 = __webpack_require__(/*! ../beet.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\");\nconst NONE = 0;\nconst SOME = 1;\n/**\n * @private\n */ function isSomeBuffer(buf, offset) {\n    return buf[offset] === SOME;\n}\nexports.isSomeBuffer = isSomeBuffer;\n/**\n * @private\n */ function isNoneBuffer(buf, offset) {\n    return buf[offset] === NONE;\n}\nexports.isNoneBuffer = isNoneBuffer;\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */ function coptionNone(description) {\n    (0, utils_1.logTrace)(`coptionNone(${description})`);\n    return {\n        write: function(buf, offset, value) {\n            (0, assert_1.strict)(value == null, \"coptionNone can only handle `null` values\");\n            buf[offset] = NONE;\n        },\n        read: function(buf, offset) {\n            (0, assert_1.strict)(isNoneBuffer(buf, offset), \"coptionNone can only handle `NONE` data\");\n            return null;\n        },\n        byteSize: 1,\n        description: `COption<None(${description})>`\n    };\n}\nexports.coptionNone = coptionNone;\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */ function coptionSome(inner) {\n    const byteSize = 1 + inner.byteSize;\n    const beet = {\n        write: function(buf, offset, value) {\n            (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);\n            (0, assert_1.strict)(value != null, \"coptionSome cannot handle `null` values\");\n            buf[offset] = SOME;\n            inner.write(buf, offset + 1, value);\n        },\n        read: function(buf, offset) {\n            (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);\n            (0, assert_1.strict)(isSomeBuffer(buf, offset), \"coptionSome can only handle `SOME` data\");\n            return inner.read(buf, offset + 1);\n        },\n        description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,\n        byteSize,\n        inner\n    };\n    (0, utils_1.logTrace)(beet.description);\n    return beet;\n}\nexports.coptionSome = coptionSome;\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */ function coption(inner) {\n    return {\n        toFixedFromData (buf, offset) {\n            if (isSomeBuffer(buf, offset)) {\n                const innerFixed = (0, beet_fixable_1.fixBeetFromData)(inner, buf, offset + 1);\n                return coptionSome(innerFixed);\n            } else {\n                (0, assert_1.strict)(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);\n                return coptionNone(inner.description);\n            }\n        },\n        toFixedFromValue (val) {\n            return val == null ? coptionNone(inner.description) : coptionSome((0, beet_fixable_1.fixBeetFromValue)(inner, val));\n        },\n        description: `COption<${inner.description}>`\n    };\n}\nexports.coption = coption;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.compositesTypeMap = {\n    option: {\n        beet: \"coption\",\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: \"COption<Inner>\",\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_2.BEET_PACKAGE\n    }\n}; //# sourceMappingURL=composites.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvY29tcG9zaXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLGVBQWUsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUM3SSxNQUFNUSxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyx5SUFBVTtBQUNsQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyx5SUFBVTtBQUNsQyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyx5SUFBVTtBQUNsQyxNQUFNSSxpQkFBaUJKLG1CQUFPQSxDQUFDLHVKQUFpQjtBQUNoRCxNQUFNSyxPQUFPO0FBQ2IsTUFBTUMsT0FBTztBQUNiOztDQUVDLEdBQ0QsU0FBU1IsYUFBYVMsR0FBRyxFQUFFQyxNQUFNO0lBQzdCLE9BQU9ELEdBQUcsQ0FBQ0MsT0FBTyxLQUFLRjtBQUMzQjtBQUNBZixvQkFBb0IsR0FBR087QUFDdkI7O0NBRUMsR0FDRCxTQUFTRCxhQUFhVSxHQUFHLEVBQUVDLE1BQU07SUFDN0IsT0FBT0QsR0FBRyxDQUFDQyxPQUFPLEtBQUtIO0FBQzNCO0FBQ0FkLG9CQUFvQixHQUFHTTtBQUN2Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNELFlBQVlhLFdBQVc7SUFDM0IsSUFBR04sUUFBUU8sUUFBUSxFQUFFLENBQUMsWUFBWSxFQUFFRCxZQUFZLENBQUMsQ0FBQztJQUNuRCxPQUFPO1FBQ0hFLE9BQU8sU0FBVUosR0FBRyxFQUFFQyxNQUFNLEVBQUVoQixLQUFLO1lBQzlCLElBQUdPLFNBQVNhLE1BQU0sRUFBRXBCLFNBQVMsTUFBTTtZQUNwQ2UsR0FBRyxDQUFDQyxPQUFPLEdBQUdIO1FBQ2xCO1FBQ0FRLE1BQU0sU0FBVU4sR0FBRyxFQUFFQyxNQUFNO1lBQ3RCLElBQUdULFNBQVNhLE1BQU0sRUFBRWYsYUFBYVUsS0FBS0MsU0FBUztZQUNoRCxPQUFPO1FBQ1g7UUFDQU0sVUFBVTtRQUNWTCxhQUFhLENBQUMsYUFBYSxFQUFFQSxZQUFZLEVBQUUsQ0FBQztJQUNoRDtBQUNKO0FBQ0FsQixtQkFBbUIsR0FBR0s7QUFDdEI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRCxZQUFZb0IsS0FBSztJQUN0QixNQUFNRCxXQUFXLElBQUlDLE1BQU1ELFFBQVE7SUFDbkMsTUFBTUUsT0FBTztRQUNUTCxPQUFPLFNBQVVKLEdBQUcsRUFBRUMsTUFBTSxFQUFFaEIsS0FBSztZQUM5QixJQUFHUyxRQUFRZ0IsbUJBQW1CLEVBQUVGLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRUEsTUFBTU4sV0FBVyxDQUFDLHVDQUF1QyxDQUFDO1lBQ3ZILElBQUdWLFNBQVNhLE1BQU0sRUFBRXBCLFNBQVMsTUFBTTtZQUNwQ2UsR0FBRyxDQUFDQyxPQUFPLEdBQUdGO1lBQ2RTLE1BQU1KLEtBQUssQ0FBQ0osS0FBS0MsU0FBUyxHQUFHaEI7UUFDakM7UUFDQXFCLE1BQU0sU0FBVU4sR0FBRyxFQUFFQyxNQUFNO1lBQ3RCLElBQUdQLFFBQVFnQixtQkFBbUIsRUFBRUYsT0FBTyxDQUFDLG1CQUFtQixFQUFFQSxNQUFNTixXQUFXLENBQUMsc0NBQXNDLENBQUM7WUFDdEgsSUFBR1YsU0FBU2EsTUFBTSxFQUFFZCxhQUFhUyxLQUFLQyxTQUFTO1lBQ2hELE9BQU9PLE1BQU1GLElBQUksQ0FBQ04sS0FBS0MsU0FBUztRQUNwQztRQUNBQyxhQUFhLENBQUMsUUFBUSxFQUFFTSxNQUFNTixXQUFXLENBQUMsTUFBTSxFQUFFTSxNQUFNRCxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ25FQTtRQUNBQztJQUNKO0lBQ0MsSUFBR1osUUFBUU8sUUFBUSxFQUFFTSxLQUFLUCxXQUFXO0lBQ3RDLE9BQU9PO0FBQ1g7QUFDQXpCLG1CQUFtQixHQUFHSTtBQUN0Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNELFFBQVFxQixLQUFLO0lBQ2xCLE9BQU87UUFDSEcsaUJBQWdCWCxHQUFHLEVBQUVDLE1BQU07WUFDdkIsSUFBSVYsYUFBYVMsS0FBS0MsU0FBUztnQkFDM0IsTUFBTVcsYUFBYSxDQUFDLEdBQUdmLGVBQWVnQixlQUFlLEVBQUVMLE9BQU9SLEtBQUtDLFNBQVM7Z0JBQzVFLE9BQU9iLFlBQVl3QjtZQUN2QixPQUNLO2dCQUNBLElBQUdwQixTQUFTYSxNQUFNLEVBQUVmLGFBQWFVLEtBQUtDLFNBQVMsQ0FBQyxTQUFTLEVBQUVELElBQUksa0JBQWtCLENBQUM7Z0JBQ25GLE9BQU9YLFlBQVltQixNQUFNTixXQUFXO1lBQ3hDO1FBQ0o7UUFDQVksa0JBQWlCQyxHQUFHO1lBQ2hCLE9BQU9BLE9BQU8sT0FDUjFCLFlBQVltQixNQUFNTixXQUFXLElBQzdCZCxZQUFZLENBQUMsR0FBR1MsZUFBZW1CLGdCQUFnQixFQUFFUixPQUFPTztRQUNsRTtRQUNBYixhQUFhLENBQUMsUUFBUSxFQUFFTSxNQUFNTixXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ2hEO0FBQ0o7QUFDQWxCLGVBQWUsR0FBR0c7QUFDbEI7Ozs7OztDQU1DLEdBQ0RILHlCQUF5QixHQUFHO0lBQ3hCaUMsUUFBUTtRQUNKUixNQUFNO1FBQ05TLFdBQVc7UUFDWEMsWUFBWXhCLFFBQVF5QixZQUFZO1FBQ2hDQyxJQUFJO1FBQ0pDLEtBQUs1QixRQUFRNkIsbUJBQW1CO1FBQ2hDQyxNQUFNN0IsUUFBUXlCLFlBQVk7SUFDOUI7QUFDSixHQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvY29tcG9zaXRlcy5qcz9iMTVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wb3NpdGVzVHlwZU1hcCA9IGV4cG9ydHMuY29wdGlvbiA9IGV4cG9ydHMuY29wdGlvblNvbWUgPSBleHBvcnRzLmNvcHRpb25Ob25lID0gZXhwb3J0cy5pc05vbmVCdWZmZXIgPSBleHBvcnRzLmlzU29tZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGJlZXRfZml4YWJsZV8xID0gcmVxdWlyZShcIi4uL2JlZXQuZml4YWJsZVwiKTtcbmNvbnN0IE5PTkUgPSAwO1xuY29uc3QgU09NRSA9IDE7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU29tZUJ1ZmZlcihidWYsIG9mZnNldCkge1xuICAgIHJldHVybiBidWZbb2Zmc2V0XSA9PT0gU09NRTtcbn1cbmV4cG9ydHMuaXNTb21lQnVmZmVyID0gaXNTb21lQnVmZmVyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc05vbmVCdWZmZXIoYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYnVmW29mZnNldF0gPT09IE5PTkU7XG59XG5leHBvcnRzLmlzTm9uZUJ1ZmZlciA9IGlzTm9uZUJ1ZmZlcjtcbi8qKlxuICogRGUvU2VyaWFsaXplcyBgTm9uZWAgY2FzZSBvZiBhbiBfT3B0aW9uXyBvZiB0eXBlIHtAbGluayBUfSByZXByZXNlbnRlZCBieVxuICoge0BsaW5rIENPcHRpb259LlxuICpcbiAqIFRoZSBkZS9zZXJpYWxpemVkIHR5cGUgaXMgcHJlZml4ZWQgd2l0aCBgMGAuXG4gKiBUaGlzIG1hdGNoZXMgdGhlIGBDT3B0aW9uOjpOb25lYCB0eXBlIGJvcnNoIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIGlubmVyIG9wdGlvbiB0eXBlXG4gKiBAcGFyYW0gZGVzY3JpcHRpb24gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBpbm5lciB0eXBlXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvb3B0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvcHRpb25Ob25lKGRlc2NyaXB0aW9uKSB7XG4gICAgKDAsIHV0aWxzXzEubG9nVHJhY2UpKGBjb3B0aW9uTm9uZSgke2Rlc2NyaXB0aW9ufSlgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLnN0cmljdCkodmFsdWUgPT0gbnVsbCwgJ2NvcHRpb25Ob25lIGNhbiBvbmx5IGhhbmRsZSBgbnVsbGAgdmFsdWVzJyk7XG4gICAgICAgICAgICBidWZbb2Zmc2V0XSA9IE5PTkU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLnN0cmljdCkoaXNOb25lQnVmZmVyKGJ1Ziwgb2Zmc2V0KSwgJ2NvcHRpb25Ob25lIGNhbiBvbmx5IGhhbmRsZSBgTk9ORWAgZGF0YScpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGJ5dGVTaXplOiAxLFxuICAgICAgICBkZXNjcmlwdGlvbjogYENPcHRpb248Tm9uZSgke2Rlc2NyaXB0aW9ufSk+YCxcbiAgICB9O1xufVxuZXhwb3J0cy5jb3B0aW9uTm9uZSA9IGNvcHRpb25Ob25lO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVzIGBTb21lYCBjYXNlIG9mIGFuIF9PcHRpb25fIG9mIHR5cGUge0BsaW5rIFR9IHJlcHJlc2VudGVkIGJ5XG4gKiB7QGxpbmsgQ09wdGlvbn0uXG4gKlxuICogVGhlIGRlL3NlcmlhbGl6ZWQgdHlwZSBpcyBwcmVmaXhlZCB3aXRoIGAxYC5cbiAqIFRoaXMgbWF0Y2hlcyB0aGUgYENPcHRpb246OlNvbWVgIHR5cGUgYm9yc2ggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIFQgaW5uZXIgb3B0aW9uIHR5cGVcbiAqIEBwYXJhbSBpbm5lciB0aGUgRGUvU2VyaWFsaXplciBmb3IgdGhlIGlubmVyIHR5cGVcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb21wb3NpdGVcbiAqL1xuZnVuY3Rpb24gY29wdGlvblNvbWUoaW5uZXIpIHtcbiAgICBjb25zdCBieXRlU2l6ZSA9IDEgKyBpbm5lci5ieXRlU2l6ZTtcbiAgICBjb25zdCBiZWV0ID0ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYXNzZXJ0Rml4ZWRTaXplQmVldCkoaW5uZXIsIGBjb3B0aW9uIGlubmVyIHR5cGUgJHtpbm5lci5kZXNjcmlwdGlvbn0gbmVlZHMgdG8gYmUgZml4ZWQgYmVmb3JlIGNhbGxpbmcgd3JpdGVgKTtcbiAgICAgICAgICAgICgwLCBhc3NlcnRfMS5zdHJpY3QpKHZhbHVlICE9IG51bGwsICdjb3B0aW9uU29tZSBjYW5ub3QgaGFuZGxlIGBudWxsYCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGJ1ZltvZmZzZXRdID0gU09NRTtcbiAgICAgICAgICAgIGlubmVyLndyaXRlKGJ1Ziwgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICgwLCB0eXBlc18xLmFzc2VydEZpeGVkU2l6ZUJlZXQpKGlubmVyLCBgY29wdGlvbiBpbm5lciB0eXBlICR7aW5uZXIuZGVzY3JpcHRpb259IG5lZWRzIHRvIGJlIGZpeGVkIGJlZm9yZSBjYWxsaW5nIHJlYWRgKTtcbiAgICAgICAgICAgICgwLCBhc3NlcnRfMS5zdHJpY3QpKGlzU29tZUJ1ZmZlcihidWYsIG9mZnNldCksICdjb3B0aW9uU29tZSBjYW4gb25seSBoYW5kbGUgYFNPTUVgIGRhdGEnKTtcbiAgICAgICAgICAgIHJldHVybiBpbm5lci5yZWFkKGJ1Ziwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQ09wdGlvbjwke2lubmVyLmRlc2NyaXB0aW9ufT5bMSArICR7aW5uZXIuYnl0ZVNpemV9XWAsXG4gICAgICAgIGJ5dGVTaXplLFxuICAgICAgICBpbm5lcixcbiAgICB9O1xuICAgICgwLCB1dGlsc18xLmxvZ1RyYWNlKShiZWV0LmRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gYmVldDtcbn1cbmV4cG9ydHMuY29wdGlvblNvbWUgPSBjb3B0aW9uU29tZTtcbi8qKlxuICogRGUvU2VyaWFsaXplcyBhbiBfT3B0aW9uXyBvZiB0eXBlIHtAbGluayBUfSByZXByZXNlbnRlZCBieSB7QGxpbmsgQ09wdGlvbn0uXG4gKlxuICogVGhlIGRlL3NlcmlhbGl6ZWQgdHlwZSBpcyBwcmVmaXhlZCB3aXRoIGAxYCBpZiB0aGUgaW5uZXIgdmFsdWUgaXMgcHJlc2VudFxuICogYW5kIHdpdGggYDBgIGlmIG5vdC5cbiAqIFRoaXMgbWF0Y2hlcyB0aGUgYENPcHRpb25gIHR5cGUgYm9yc2ggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIFQgaW5uZXIgb3B0aW9uIHR5cGVcbiAqIEBwYXJhbSBpbm5lciB0aGUgRGUvU2VyaWFsaXplciBmb3IgdGhlIGlubmVyIHR5cGVcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb21wb3NpdGVcbiAqL1xuZnVuY3Rpb24gY29wdGlvbihpbm5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGlzU29tZUJ1ZmZlcihidWYsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lckZpeGVkID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tRGF0YSkoaW5uZXIsIGJ1Ziwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHRpb25Tb21lKGlubmVyRml4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKDAsIGFzc2VydF8xLnN0cmljdCkoaXNOb25lQnVmZmVyKGJ1Ziwgb2Zmc2V0KSwgYEV4cGVjdGVkICR7YnVmfSB0byBob2xkIGEgQ09wdGlvbmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3B0aW9uTm9uZShpbm5lci5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvRml4ZWRGcm9tVmFsdWUodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvcHRpb25Ob25lKGlubmVyLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIDogY29wdGlvblNvbWUoKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tVmFsdWUpKGlubmVyLCB2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBDT3B0aW9uPCR7aW5uZXIuZGVzY3JpcHRpb259PmAsXG4gICAgfTtcbn1cbmV4cG9ydHMuY29wdGlvbiA9IGNvcHRpb247XG4vKipcbiAqIE1hcHMgY29tcG9zaXRlIGJlZXQgZXhwb3J0cyB0byBtZXRhZGF0YSB3aGljaCBkZXNjcmliZXMgaW4gd2hpY2ggcGFja2FnZSBpdFxuICogaXMgZGVmaW5lZCBhcyB3ZWxsIGFzIHdoaWNoIFR5cGVTY3JpcHQgdHlwZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAqIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBjYXRlZ29yeSBUeXBlRGVmaW5pdGlvblxuICovXG5leHBvcnRzLmNvbXBvc2l0ZXNUeXBlTWFwID0ge1xuICAgIG9wdGlvbjoge1xuICAgICAgICBiZWV0OiAnY29wdGlvbicsXG4gICAgICAgIGlzRml4YWJsZTogdHJ1ZSxcbiAgICAgICAgc291cmNlUGFjazogdHlwZXNfMi5CRUVUX1BBQ0tBR0UsXG4gICAgICAgIHRzOiAnQ09wdGlvbjxJbm5lcj4nLFxuICAgICAgICBhcmc6IHR5cGVzXzEuQkVFVF9UWVBFX0FSR19JTk5FUixcbiAgICAgICAgcGFjazogdHlwZXNfMi5CRUVUX1BBQ0tBR0UsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NpdGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbXBvc2l0ZXNUeXBlTWFwIiwiY29wdGlvbiIsImNvcHRpb25Tb21lIiwiY29wdGlvbk5vbmUiLCJpc05vbmVCdWZmZXIiLCJpc1NvbWVCdWZmZXIiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJ0eXBlc18xIiwidHlwZXNfMiIsInV0aWxzXzEiLCJiZWV0X2ZpeGFibGVfMSIsIk5PTkUiLCJTT01FIiwiYnVmIiwib2Zmc2V0IiwiZGVzY3JpcHRpb24iLCJsb2dUcmFjZSIsIndyaXRlIiwic3RyaWN0IiwicmVhZCIsImJ5dGVTaXplIiwiaW5uZXIiLCJiZWV0IiwiYXNzZXJ0Rml4ZWRTaXplQmVldCIsInRvRml4ZWRGcm9tRGF0YSIsImlubmVyRml4ZWQiLCJmaXhCZWV0RnJvbURhdGEiLCJ0b0ZpeGVkRnJvbVZhbHVlIiwidmFsIiwiZml4QmVldEZyb21WYWx1ZSIsIm9wdGlvbiIsImlzRml4YWJsZSIsInNvdXJjZVBhY2siLCJCRUVUX1BBQ0tBR0UiLCJ0cyIsImFyZyIsIkJFRVRfVFlQRV9BUkdfSU5ORVIiLCJwYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst numbers_1 = __webpack_require__(/*! ./numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst struct_1 = __webpack_require__(/*! ../struct */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js\");\nconst struct_fixable_1 = __webpack_require__(/*! ../struct.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js\");\nconst unit_1 = __webpack_require__(/*! ./unit */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js\");\n// -----------------\n// Fixed Scalar Enum\n// -----------------\nfunction resolveEnumVariant(value, isNumVariant) {\n    return isNumVariant ? `${value}` : value;\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */ function fixedScalarEnum(enumType) {\n    const keys = Object.keys(enumType);\n    return {\n        write (buf, offset, value) {\n            const isNumVariant = typeof value === \"number\";\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert_1.strict.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(\", \")} ], but isn't`);\n            }\n            if (isNumVariant) {\n                numbers_1.u8.write(buf, offset, value);\n            } else {\n                const enumValue = enumType[variantKey];\n                numbers_1.u8.write(buf, offset, enumValue);\n            }\n        },\n        read (buf, offset) {\n            const value = numbers_1.u8.read(buf, offset);\n            const isNumVariant = typeof value === \"number\";\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert_1.strict.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(\", \")} ], but isn't`);\n            }\n            return isNumVariant ? value : enumType[variantKey];\n        },\n        byteSize: numbers_1.u8.byteSize,\n        description: \"Enum\"\n    };\n}\nexports.fixedScalarEnum = fixedScalarEnum;\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */ function uniformDataEnum(inner) {\n    return {\n        write: function(buf, offset, value) {\n            numbers_1.u8.write(buf, offset, value.kind);\n            inner.write(buf, offset + 1, value.data);\n        },\n        read: function(buf, offset) {\n            const kind = numbers_1.u8.read(buf, offset);\n            const data = inner.read(buf, offset + 1);\n            return {\n                kind,\n                data\n            };\n        },\n        byteSize: 1 + inner.byteSize,\n        description: `UniformDataEnum<${inner.description}>`\n    };\n}\nexports.uniformDataEnum = uniformDataEnum;\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n    return {\n        write (buf, offset, value) {\n            numbers_1.u8.write(buf, offset, discriminant);\n            inner.write(buf, offset + numbers_1.u8.byteSize, value);\n        },\n        read (buf, offset) {\n            const val = inner.read(buf, offset + numbers_1.u8.byteSize);\n            return {\n                __kind: kind,\n                ...val\n            };\n        },\n        byteSize: inner.byteSize + numbers_1.u8.byteSize,\n        description: `EnumData<${inner.description}>`\n    };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */ function dataEnum(variants) {\n    for (const [_, beet] of variants){\n        (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) || (0, struct_fixable_1.isFixableBeetStruct)(beet) || // scalar variant\n        beet === unit_1.unit, \"dataEnum: variants must be a data beet struct or a scalar unit\");\n    }\n    return {\n        toFixedFromData (buf, offset) {\n            const discriminant = numbers_1.u8.read(buf, offset);\n            const variant = variants[discriminant];\n            (0, assert_1.strict)(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);\n            const [__kind, dataBeet] = variant;\n            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromData(buf, offset + 1);\n            return enumDataVariantBeet(fixed, discriminant, __kind);\n        },\n        toFixedFromValue (val) {\n            if (val.__kind == null) {\n                const keys = Object.keys(val).join(\", \");\n                const validKinds = variants.map(([__kind])=>__kind).join(\", \");\n                assert_1.strict.fail(`Value with fields [ ${keys} ] is missing __kind, ` + `which needs to be set to one of [ ${validKinds} ]`);\n            }\n            const discriminant = variants.findIndex(([__kind])=>__kind === val.__kind);\n            if (discriminant < 0) {\n                const validKinds = variants.map(([__kind])=>__kind).join(\", \");\n                assert_1.strict.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);\n            }\n            const variant = variants[discriminant];\n            const { __kind, ...dataValue } = val;\n            const [__variantKind, dataBeet] = variant;\n            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromValue(dataValue);\n            return enumDataVariantBeet(fixed, discriminant, __variantKind);\n        },\n        description: `DataEnum<${variants.length} variants>`\n    };\n}\nexports.dataEnum = dataEnum;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.enumsTypeMap = {\n    fixedScalarEnum: {\n        beet: \"fixedScalarEnum\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"<TypeName>\",\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_1.BEET_PACKAGE\n    },\n    dataEnum: {\n        beet: \"dataEnum\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"DataEnum<Kind, Inner>\",\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_1.BEET_PACKAGE\n    }\n}; //# sourceMappingURL=enums.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvZW51bXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDbkcsTUFBTU0sVUFBVUMsbUJBQU9BLENBQUMseUlBQVU7QUFDbEMsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsa0pBQVc7QUFDckMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsMklBQVc7QUFDcEMsTUFBTUksbUJBQW1CSixtQkFBT0EsQ0FBQywySkFBbUI7QUFDcEQsTUFBTUssU0FBU0wsbUJBQU9BLENBQUMsNElBQVE7QUFDL0Isb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsU0FBU00sbUJBQW1CWixLQUFLLEVBQUVhLFlBQVk7SUFDM0MsT0FBUUEsZUFBZSxDQUFDLEVBQUViLE1BQU0sQ0FBQyxHQUFHQTtBQUN4QztBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGdCQUFnQlUsUUFBUTtJQUM3QixNQUFNQyxPQUFPbEIsT0FBT2tCLElBQUksQ0FBQ0Q7SUFDekIsT0FBTztRQUNIRSxPQUFNQyxHQUFHLEVBQUVDLE1BQU0sRUFBRWxCLEtBQUs7WUFDcEIsTUFBTWEsZUFBZSxPQUFPYixVQUFVO1lBQ3RDLE1BQU1tQixhQUFhUCxtQkFBbUJaLE9BQU9hO1lBQzdDLElBQUksQ0FBQ0UsS0FBS0ssUUFBUSxDQUFDRCxhQUFhO2dCQUM1QlgsU0FBU2EsTUFBTSxDQUFDQyxJQUFJLENBQUMsQ0FBQyxFQUFFdEIsTUFBTSx1REFBdUQsRUFB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YUFBYWIsU0FBU2MsR0FBRyxDQUFDLENBQUMsQ0FBQ2YsT0FBTyxHQUFLQSxRQUFRWixJQUFJLENBQUM7Z0JBQzNEaEIsU0FBU2EsTUFBTSxDQUFDQyxJQUFJLENBQUMsQ0FBQyxFQUFFYSxJQUFJQyxNQUFNLENBQUMsMkNBQTJDLEVBQUVjLFdBQVcsRUFBRSxDQUFDO1lBQ2xHO1lBQ0EsTUFBTU4sVUFBVVAsUUFBUSxDQUFDSCxhQUFhO1lBQ3RDLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUdpQixXQUFXLEdBQUdsQjtZQUNqQyxNQUFNLENBQUNtQixlQUFlUixTQUFTLEdBQUdGO1lBQ2xDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHMUMsUUFBUTJDLGVBQWUsRUFBRUYsWUFDckNBLFdBQ0FBLFNBQVNHLGdCQUFnQixDQUFDSTtZQUNoQyxPQUFPcEIsb0JBQW9CYyxPQUFPYixjQUFjb0I7UUFDcEQ7UUFDQXpCLGFBQWEsQ0FBQyxTQUFTLEVBQUVRLFNBQVNRLE1BQU0sQ0FBQyxVQUFVLENBQUM7SUFDeEQ7QUFDSjtBQUNBOUMsZ0JBQWdCLEdBQUdHO0FBQ25COzs7Ozs7Q0FNQyxHQUNESCxvQkFBb0IsR0FBRztJQUNuQkssaUJBQWlCO1FBQ2JtQyxNQUFNO1FBQ05nQixXQUFXO1FBQ1hDLFlBQVluRCxRQUFRb0QsWUFBWTtRQUNoQ0MsSUFBSTtRQUNKQyxLQUFLdEQsUUFBUXVELG1CQUFtQjtRQUNoQ0MsTUFBTXhELFFBQVFvRCxZQUFZO0lBQzlCO0lBQ0F2RCxVQUFVO1FBQ05xQyxNQUFNO1FBQ05nQixXQUFXO1FBQ1hDLFlBQVluRCxRQUFRb0QsWUFBWTtRQUNoQ0MsSUFBSTtRQUNKQyxLQUFLdEQsUUFBUXVELG1CQUFtQjtRQUNoQ0MsTUFBTXhELFFBQVFvRCxZQUFZO0lBQzlCO0FBQ0osR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhcGxleC1mb3VuZGF0aW9uK2JlZXRAMC42LjEvbm9kZV9tb2R1bGVzL0BtZXRhcGxleC1mb3VuZGF0aW9uL2JlZXQvZGlzdC9janMvc3JjL2JlZXRzL2VudW1zLmpzPzAxMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudW1zVHlwZU1hcCA9IGV4cG9ydHMuZGF0YUVudW0gPSBleHBvcnRzLnVuaWZvcm1EYXRhRW51bSA9IGV4cG9ydHMuZml4ZWRTY2FsYXJFbnVtID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IG51bWJlcnNfMSA9IHJlcXVpcmUoXCIuL251bWJlcnNcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBzdHJ1Y3RfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3RcIik7XG5jb25zdCBzdHJ1Y3RfZml4YWJsZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdC5maXhhYmxlXCIpO1xuY29uc3QgdW5pdF8xID0gcmVxdWlyZShcIi4vdW5pdFwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGaXhlZCBTY2FsYXIgRW51bVxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHJlc29sdmVFbnVtVmFyaWFudCh2YWx1ZSwgaXNOdW1WYXJpYW50KSB7XG4gICAgcmV0dXJuIChpc051bVZhcmlhbnQgPyBgJHt2YWx1ZX1gIDogdmFsdWUpO1xufVxuLyoqXG4gKiBEZS9zZXJpYWxpemVyIGZvciBlbnVtcyB3aXRoIHVwIHRvIDI1NSBsZXNzIHZhcmlhbnRzIHdoaWNoIGhhdmUgbm8gZGF0YS5cbiAqXG4gKiBAcGFyYW0gZW51bVR5cGUgdHlwZSBvZiBlbnVtIHRvIHByb2Nlc3MsIGkuZS4gQ29sb3Igb3IgRGlyZWN0aW9uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvZW51bVxuICovXG5mdW5jdGlvbiBmaXhlZFNjYWxhckVudW0oZW51bVR5cGUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZW51bVR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlKGJ1Ziwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgaXNOdW1WYXJpYW50ID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRLZXkgPSByZXNvbHZlRW51bVZhcmlhbnQodmFsdWUsIGlzTnVtVmFyaWFudCk7XG4gICAgICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXModmFyaWFudEtleSkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRfMS5zdHJpY3QuZmFpbChgJHt2YWx1ZX0gc2hvdWxkIGJlIGEgdmFyaWFudCBvZiB0aGUgcHJvdmlkZWQgZW51bSB0eXBlLCBpLmUuIFsgJHtPYmplY3QudmFsdWVzKGVudW1UeXBlKS5qb2luKCcsICcpfSBdLCBidXQgaXNuJ3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bVZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJzXzEudTgud3JpdGUoYnVmLCBvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IGVudW1UeXBlW3ZhcmlhbnRLZXldO1xuICAgICAgICAgICAgICAgIG51bWJlcnNfMS51OC53cml0ZShidWYsIG9mZnNldCwgZW51bVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZChidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBudW1iZXJzXzEudTgucmVhZChidWYsIG9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBpc051bVZhcmlhbnQgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudEtleSA9IHJlc29sdmVFbnVtVmFyaWFudCh2YWx1ZSwgaXNOdW1WYXJpYW50KTtcbiAgICAgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyh2YXJpYW50S2V5KSkge1xuICAgICAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5mYWlsKGAke3ZhbHVlfSBzaG91bGQgYmUgYSBvZiBhIHZhcmlhbnQgb2YgdGhlIHByb3ZpZGVkIGVudW0gdHlwZSwgaS5lLiBbICR7T2JqZWN0LnZhbHVlcyhlbnVtVHlwZSkuam9pbignLCAnKX0gXSwgYnV0IGlzbid0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGlzTnVtVmFyaWFudCA/IHZhbHVlIDogZW51bVR5cGVbdmFyaWFudEtleV0pO1xuICAgICAgICB9LFxuICAgICAgICBieXRlU2l6ZTogbnVtYmVyc18xLnU4LmJ5dGVTaXplLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0VudW0nLFxuICAgIH07XG59XG5leHBvcnRzLmZpeGVkU2NhbGFyRW51bSA9IGZpeGVkU2NhbGFyRW51bTtcbi8qKlxuICogRGUvU2VyaWFsaXplcyBhbiB7QGxpbmsgRW51bX0gdGhhdCBjb250YWlucyBhIHR5cGUgb2YgZGF0YSwgaS5lLiBhIHtAbGluayBTdHJ1Y3R9LlxuICogVGhlIG1haW4gZGlmZmVyZW5jZSB0byBhIFJ1c3QgZW51bSBpcyB0aGF0IHRoZSB0eXBlIG9mIGRhdGEgaGFzIHRvIGJlIHRoZVxuICogc2FtZSBmb3IgYWxsIGVudW0gdmFyaWFudHMuXG4gKlxuICogQHRlbXBsYXRlIFQgaW5uZXIgZW51bSBkYXRhIHR5cGVcbiAqXG4gKiBAcGFyYW0gaW5uZXIgdGhlIERlL1NlcmlhbGl6ZXIgZm9yIHRoZSBkYXRhIHR5cGVcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9lbnVtXG4gKi9cbmZ1bmN0aW9uIHVuaWZvcm1EYXRhRW51bShpbm5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBudW1iZXJzXzEudTgud3JpdGUoYnVmLCBvZmZzZXQsIHZhbHVlLmtpbmQpO1xuICAgICAgICAgICAgaW5uZXIud3JpdGUoYnVmLCBvZmZzZXQgKyAxLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gbnVtYmVyc18xLnU4LnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGlubmVyLnJlYWQoYnVmLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGtpbmQsIGRhdGEgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYnl0ZVNpemU6IDEgKyBpbm5lci5ieXRlU2l6ZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBVbmlmb3JtRGF0YUVudW08JHtpbm5lci5kZXNjcmlwdGlvbn0+YCxcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtRGF0YUVudW0gPSB1bmlmb3JtRGF0YUVudW07XG5mdW5jdGlvbiBlbnVtRGF0YVZhcmlhbnRCZWV0KGlubmVyLCBkaXNjcmltaW5hbnQsIGtpbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZShidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG51bWJlcnNfMS51OC53cml0ZShidWYsIG9mZnNldCwgZGlzY3JpbWluYW50KTtcbiAgICAgICAgICAgIGlubmVyLndyaXRlKGJ1Ziwgb2Zmc2V0ICsgbnVtYmVyc18xLnU4LmJ5dGVTaXplLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGlubmVyLnJlYWQoYnVmLCBvZmZzZXQgKyBudW1iZXJzXzEudTguYnl0ZVNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgX19raW5kOiBraW5kLCAuLi52YWwgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYnl0ZVNpemU6IGlubmVyLmJ5dGVTaXplICsgbnVtYmVyc18xLnU4LmJ5dGVTaXplLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEVudW1EYXRhPCR7aW5uZXIuZGVzY3JpcHRpb259PmAsXG4gICAgfTtcbn1cbi8qKlxuICogRGUvc2VyaWFsaXplcyBEYXRhIEVudW1zLlxuICogVGhleSBhcmUgcmVwcmVzZW50ZWQgYXMgYSBkaXNjcmltaW5hdGVkIHVuaW9ucyBpbiBUeXBlU2NyaXB0LlxuICpcbiAqIE5PVEU6IG9ubHkgc3RydWN0cywgaS5lLiB7QGxpbmsgQmVldEFyZ3NTdHJ1Y3R9IGFuZFxuICoge0BsaW5rIEZpeGFibGVCZWV0QXJnc1N0cnVjdH0gYXJlIHN1cHBvcnRlZCBhcyB0aGUgZGF0YSBvZiBlYWNoIGVudW0gdmFyaWFudC5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIHR5cGUgU2ltcGxlID0ge1xuICogICBGaXJzdDogeyBuMTogbnVtYmVyIH1cbiAqICAgU2Vjb25kOiB7IG4yOiBudW1iZXIgfVxuICogfVxuICpcbiAqIGNvbnN0IGJlZXQgPSBkYXRhRW51bTxTaW1wbGU+KFtcbiAqICAgWydGaXJzdCcsIG5ldyBCZWV0QXJnc1N0cnVjdDxTaW1wbGVbJ0ZpcnN0J10+KFtbJ24xJywgdTMyXV0pXSxcbiAqICAgWydTZWNvbmQnLCBuZXcgQmVldEFyZ3NTdHJ1Y3Q8U2ltcGxlWydTZWNvbmQnXT4oW1snbjInLCB1MzJdXSldLFxuICogXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L2VudW1cbiAqIEBwYXJhbSB2YXJpYW50cyBhbiBhcnJheSBvZiB7QGxpbmsgRGF0YUVudW1CZWV0fXMgZWFjaCBhIHR1cGxlIG9mIGBbIGtpbmQsIGRhdGEgXWBcbiAqL1xuZnVuY3Rpb24gZGF0YUVudW0odmFyaWFudHMpIHtcbiAgICBmb3IgKGNvbnN0IFtfLCBiZWV0XSBvZiB2YXJpYW50cykge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuc3RyaWN0KSgoMCwgc3RydWN0XzEuaXNCZWV0U3RydWN0KShiZWV0KSB8fFxuICAgICAgICAgICAgKDAsIHN0cnVjdF9maXhhYmxlXzEuaXNGaXhhYmxlQmVldFN0cnVjdCkoYmVldCkgfHxcbiAgICAgICAgICAgIC8vIHNjYWxhciB2YXJpYW50XG4gICAgICAgICAgICBiZWV0ID09PSB1bml0XzEudW5pdCwgJ2RhdGFFbnVtOiB2YXJpYW50cyBtdXN0IGJlIGEgZGF0YSBiZWV0IHN0cnVjdCBvciBhIHNjYWxhciB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYW50ID0gbnVtYmVyc18xLnU4LnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzW2Rpc2NyaW1pbmFudF07XG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuc3RyaWN0KSh2YXJpYW50ICE9IG51bGwsIGBEaXNjcmltaW5hbnQgJHtkaXNjcmltaW5hbnR9IG91dCBvZiByYW5nZSBmb3IgJHt2YXJpYW50cy5sZW5ndGh9IHZhcmlhbnRzYCk7XG4gICAgICAgICAgICBjb25zdCBbX19raW5kLCBkYXRhQmVldF0gPSB2YXJpYW50O1xuICAgICAgICAgICAgY29uc3QgZml4ZWQgPSAoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKGRhdGFCZWV0KVxuICAgICAgICAgICAgICAgID8gZGF0YUJlZXRcbiAgICAgICAgICAgICAgICA6IGRhdGFCZWV0LnRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGVudW1EYXRhVmFyaWFudEJlZXQoZml4ZWQsIGRpc2NyaW1pbmFudCwgX19raW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9GaXhlZEZyb21WYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwuX19raW5kID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkS2luZHMgPSB2YXJpYW50cy5tYXAoKFtfX2tpbmRdKSA9PiBfX2tpbmQpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmZhaWwoYFZhbHVlIHdpdGggZmllbGRzIFsgJHtrZXlzfSBdIGlzIG1pc3NpbmcgX19raW5kLCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdoaWNoIG5lZWRzIHRvIGJlIHNldCB0byBvbmUgb2YgWyAke3ZhbGlkS2luZHN9IF1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IHZhcmlhbnRzLmZpbmRJbmRleCgoW19fa2luZF0pID0+IF9fa2luZCA9PT0gdmFsLl9fa2luZCk7XG4gICAgICAgICAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkS2luZHMgPSB2YXJpYW50cy5tYXAoKFtfX2tpbmRdKSA9PiBfX2tpbmQpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmZhaWwoYCR7dmFsLl9fa2luZH0gaXMgbm90IGEgdmFsaWQga2luZCwgbmVlZHMgdG8gYmUgb25lIG9mIFsgJHt2YWxpZEtpbmRzfSBdYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50ID0gdmFyaWFudHNbZGlzY3JpbWluYW50XTtcbiAgICAgICAgICAgIGNvbnN0IHsgX19raW5kLCAuLi5kYXRhVmFsdWUgfSA9IHZhbDtcbiAgICAgICAgICAgIGNvbnN0IFtfX3ZhcmlhbnRLaW5kLCBkYXRhQmVldF0gPSB2YXJpYW50O1xuICAgICAgICAgICAgY29uc3QgZml4ZWQgPSAoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKGRhdGFCZWV0KVxuICAgICAgICAgICAgICAgID8gZGF0YUJlZXRcbiAgICAgICAgICAgICAgICA6IGRhdGFCZWV0LnRvRml4ZWRGcm9tVmFsdWUoZGF0YVZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBlbnVtRGF0YVZhcmlhbnRCZWV0KGZpeGVkLCBkaXNjcmltaW5hbnQsIF9fdmFyaWFudEtpbmQpO1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogYERhdGFFbnVtPCR7dmFyaWFudHMubGVuZ3RofSB2YXJpYW50cz5gLFxuICAgIH07XG59XG5leHBvcnRzLmRhdGFFbnVtID0gZGF0YUVudW07XG4vKipcbiAqIE1hcHMgY29tcG9zaXRlIGJlZXQgZXhwb3J0cyB0byBtZXRhZGF0YSB3aGljaCBkZXNjcmliZXMgaW4gd2hpY2ggcGFja2FnZSBpdFxuICogaXMgZGVmaW5lZCBhcyB3ZWxsIGFzIHdoaWNoIFR5cGVTY3JpcHQgdHlwZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAqIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBjYXRlZ29yeSBUeXBlRGVmaW5pdGlvblxuICovXG5leHBvcnRzLmVudW1zVHlwZU1hcCA9IHtcbiAgICBmaXhlZFNjYWxhckVudW06IHtcbiAgICAgICAgYmVldDogJ2ZpeGVkU2NhbGFyRW51bScsXG4gICAgICAgIGlzRml4YWJsZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLFxuICAgICAgICB0czogJzxUeXBlTmFtZT4nLFxuICAgICAgICBhcmc6IHR5cGVzXzEuQkVFVF9UWVBFX0FSR19JTk5FUixcbiAgICAgICAgcGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsXG4gICAgfSxcbiAgICBkYXRhRW51bToge1xuICAgICAgICBiZWV0OiAnZGF0YUVudW0nLFxuICAgICAgICBpc0ZpeGFibGU6IGZhbHNlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdEYXRhRW51bTxLaW5kLCBJbm5lcj4nLFxuICAgICAgICBhcmc6IHR5cGVzXzEuQkVFVF9UWVBFX0FSR19JTk5FUixcbiAgICAgICAgcGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtc1R5cGVNYXAiLCJkYXRhRW51bSIsInVuaWZvcm1EYXRhRW51bSIsImZpeGVkU2NhbGFyRW51bSIsInR5cGVzXzEiLCJyZXF1aXJlIiwibnVtYmVyc18xIiwiYXNzZXJ0XzEiLCJzdHJ1Y3RfMSIsInN0cnVjdF9maXhhYmxlXzEiLCJ1bml0XzEiLCJyZXNvbHZlRW51bVZhcmlhbnQiLCJpc051bVZhcmlhbnQiLCJlbnVtVHlwZSIsImtleXMiLCJ3cml0ZSIsImJ1ZiIsIm9mZnNldCIsInZhcmlhbnRLZXkiLCJpbmNsdWRlcyIsInN0cmljdCIsImZhaWwiLCJ2YWx1ZXMiLCJqb2luIiwidTgiLCJlbnVtVmFsdWUiLCJyZWFkIiwiYnl0ZVNpemUiLCJkZXNjcmlwdGlvbiIsImlubmVyIiwia2luZCIsImRhdGEiLCJlbnVtRGF0YVZhcmlhbnRCZWV0IiwiZGlzY3JpbWluYW50IiwidmFsIiwiX19raW5kIiwidmFyaWFudHMiLCJfIiwiYmVldCIsImlzQmVldFN0cnVjdCIsImlzRml4YWJsZUJlZXRTdHJ1Y3QiLCJ1bml0IiwidG9GaXhlZEZyb21EYXRhIiwidmFyaWFudCIsImxlbmd0aCIsImRhdGFCZWV0IiwiZml4ZWQiLCJpc0ZpeGVkU2l6ZUJlZXQiLCJ0b0ZpeGVkRnJvbVZhbHVlIiwidmFsaWRLaW5kcyIsIm1hcCIsImZpbmRJbmRleCIsImRhdGFWYWx1ZSIsIl9fdmFyaWFudEtpbmQiLCJpc0ZpeGFibGUiLCJzb3VyY2VQYWNrIiwiQkVFVF9QQUNLQUdFIiwidHMiLCJhcmciLCJCRUVUX1RZUEVfQVJHX0lOTkVSIiwicGFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapsTypeMap = exports.map = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst numbers_1 = __webpack_require__(/*! ./numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * NOTE: that it is not exported as no fixed size map exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the De/Serializers for the key element types\n * @param valElement the De/Serializers for the value element types\n * @param len amount of entries in the map\n *\n * @category beet/composite\n * @private\n */ function fixedSizeMap(keyElement, valElement, fixedElements, len) {\n    const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    const valElementFixed = (0, types_1.isFixedSizeBeet)(valElement);\n    function determineSizes() {\n        if (keyElementFixed && valElementFixed) {\n            const elementByteSize = keyElement.byteSize + valElement.byteSize;\n            return {\n                elementByteSize,\n                byteSize: 4 + len * elementByteSize\n            };\n        } else if (keyElementFixed) {\n            let valsByteSize = 0;\n            for (const [_, v] of fixedElements.values()){\n                valsByteSize += v.byteSize;\n            }\n            // If any element has a dynamic size all we can do here is take an average\n            const elementByteSize = keyElement.byteSize + Math.ceil(valsByteSize / len);\n            return {\n                elementByteSize,\n                byteSize: 4 + keyElement.byteSize * len + valsByteSize\n            };\n        } else if (valElementFixed) {\n            let keysByteSize = 0;\n            for (const [k, _] of fixedElements.values()){\n                keysByteSize += k.byteSize;\n            }\n            const elementByteSize = Math.ceil(keysByteSize / len) + valElement.byteSize;\n            return {\n                elementByteSize,\n                byteSize: 4 + keysByteSize + valElement.byteSize * len\n            };\n        } else {\n            let keysByteSize = 0;\n            let valsByteSize = 0;\n            for (const [k, v] of fixedElements.values()){\n                keysByteSize += k.byteSize;\n                valsByteSize += v.byteSize;\n            }\n            const elementByteSize = Math.ceil(keysByteSize / len + valsByteSize / len);\n            return {\n                elementByteSize,\n                byteSize: 4 + keysByteSize + valsByteSize\n            };\n        }\n    }\n    const { elementByteSize, byteSize } = determineSizes();\n    return {\n        write: function(buf, offset, map) {\n            // Write the values first and then the size as it comes clear while we do the former\n            let cursor = offset + 4;\n            let size = 0;\n            for (const [k, v] of map.entries()){\n                let fixedKey = keyElementFixed ? keyElement : null;\n                let fixedVal = valElementFixed ? valElement : null;\n                if (fixedKey == null || fixedVal == null) {\n                    // When we write the value we know the key and an just pull the\n                    // matching fixed beet for key/val from the provided map which is\n                    // faster than fixing it by value\n                    const els = fixedElements.get(k);\n                    (0, assert_1.strict)(els != null, `Should be able to find beet els for ${k.toString()}, but could not`);\n                    fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = els[0];\n                    fixedVal !== null && fixedVal !== void 0 ? fixedVal : fixedVal = els[1];\n                }\n                fixedKey.write(buf, cursor, k);\n                cursor += fixedKey.byteSize;\n                fixedVal.write(buf, cursor, v);\n                cursor += fixedVal.byteSize;\n                size++;\n            }\n            numbers_1.u32.write(buf, offset, size);\n            assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n        },\n        read: function(buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n            let cursor = offset + 4;\n            const map = new Map();\n            for(let i = 0; i < size; i++){\n                // When we read the value from a buffer we don't know the key we're\n                // reading yet and thus cannot use the provided map of fixed\n                // de/serializers.\n                // Therefore we obtain it by fixing it by data instead.\n                const fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n                const k = fixedKey.read(buf, cursor);\n                cursor += fixedKey.byteSize;\n                const fixedVal = valElementFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n                const v = fixedVal.read(buf, cursor);\n                cursor += fixedVal.byteSize;\n                map.set(k, v);\n            }\n            return map;\n        },\n        elementByteSize,\n        byteSize,\n        length: len,\n        lenPrefixByteSize: 4,\n        description: `Map<${keyElement.description}, ${valElement.description}>`\n    };\n}\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n * @param valElement the _fixable_ or _fixed_ de/serializers for the value element types\n *\n * @category beet/composite\n */ function map(keyElement, valElement) {\n    const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    const valIsFixed = (0, types_1.isFixedSizeBeet)(valElement);\n    return {\n        toFixedFromData (buf, offset) {\n            const len = numbers_1.u32.read(buf, offset);\n            let cursor = offset + 4;\n            // Shortcut for the case that both key and value are fixed size beets\n            if (keyIsFixed && valIsFixed) {\n                return fixedSizeMap(keyElement, valElement, new Map(), len);\n            }\n            // If either key or val are not fixed size beets we need to determine the\n            // fixed versions and add them to a map by key\n            const fixedBeets = new Map();\n            for(let i = 0; i < len; i++){\n                const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n                const key = keyFixed.read(buf, cursor);\n                cursor += keyFixed.byteSize;\n                const valFixed = valIsFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n                cursor += valFixed.byteSize;\n                fixedBeets.set(key, [\n                    keyFixed,\n                    valFixed\n                ]);\n            }\n            return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n        },\n        toFixedFromValue (mapVal) {\n            const len = mapVal.size;\n            // As above shortcut for the optimal case and build a map for all others\n            if (keyIsFixed && valIsFixed) {\n                return fixedSizeMap(keyElement, valElement, new Map(), len);\n            }\n            const fixedBeets = new Map();\n            for (const [k, v] of mapVal){\n                const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);\n                const valFixed = valIsFixed ? valElement : valElement.toFixedFromValue(v);\n                fixedBeets.set(k, [\n                    keyFixed,\n                    valFixed\n                ]);\n            }\n            return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n        },\n        description: `FixableMap<${keyElement.description}, ${valElement.description}>`\n    };\n}\nexports.map = map;\n/**\n * Maps maps beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.mapsTypeMap = {\n    Map: {\n        beet: \"map\",\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"Map\"\n    }\n}; //# sourceMappingURL=maps.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvbWFwcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLFdBQVcsR0FBRyxLQUFLO0FBQ3pDLE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLGtKQUFXO0FBQ3JDLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsU0FBU0csYUFBYUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGFBQWEsRUFBRUMsR0FBRztJQUM1RCxNQUFNQyxrQkFBa0IsQ0FBQyxHQUFHVCxRQUFRVSxlQUFlLEVBQUVMO0lBQ3JELE1BQU1NLGtCQUFrQixDQUFDLEdBQUdYLFFBQVFVLGVBQWUsRUFBRUo7SUFDckQsU0FBU007UUFDTCxJQUFJSCxtQkFBbUJFLGlCQUFpQjtZQUNwQyxNQUFNRSxrQkFBa0JSLFdBQVdTLFFBQVEsR0FBR1IsV0FBV1EsUUFBUTtZQUNqRSxPQUFPO2dCQUNIRDtnQkFDQUMsVUFBVSxJQUFJTixNQUFNSztZQUN4QjtRQUNKLE9BQ0ssSUFBSUosaUJBQWlCO1lBQ3RCLElBQUlNLGVBQWU7WUFDbkIsS0FBSyxNQUFNLENBQUNDLEdBQUdDLEVBQUUsSUFBSVYsY0FBY1csTUFBTSxHQUFJO2dCQUN6Q0gsZ0JBQWdCRSxFQUFFSCxRQUFRO1lBQzlCO1lBQ0EsMEVBQTBFO1lBQzFFLE1BQU1ELGtCQUFrQlIsV0FBV1MsUUFBUSxHQUFHSyxLQUFLQyxJQUFJLENBQUNMLGVBQWVQO1lBQ3ZFLE9BQU87Z0JBQ0hLO2dCQUNBQyxVQUFVLElBQUlULFdBQVdTLFFBQVEsR0FBR04sTUFBTU87WUFDOUM7UUFDSixPQUNLLElBQUlKLGlCQUFpQjtZQUN0QixJQUFJVSxlQUFlO1lBQ25CLEtBQUssTUFBTSxDQUFDQyxHQUFHTixFQUFFLElBQUlULGNBQWNXLE1BQU0sR0FBSTtnQkFDekNHLGdCQUFnQkMsRUFBRVIsUUFBUTtZQUM5QjtZQUNBLE1BQU1ELGtCQUFrQk0sS0FBS0MsSUFBSSxDQUFDQyxlQUFlYixPQUFPRixXQUFXUSxRQUFRO1lBQzNFLE9BQU87Z0JBQ0hEO2dCQUNBQyxVQUFVLElBQUlPLGVBQWVmLFdBQVdRLFFBQVEsR0FBR047WUFDdkQ7UUFDSixPQUNLO1lBQ0QsSUFBSWEsZUFBZTtZQUNuQixJQUFJTixlQUFlO1lBQ25CLEtBQUssTUFBTSxDQUFDTyxHQUFHTCxFQUFFLElBQUlWLGNBQWNXLE1BQU0sR0FBSTtnQkFDekNHLGdCQUFnQkMsRUFBRVIsUUFBUTtnQkFDMUJDLGdCQUFnQkUsRUFBRUgsUUFBUTtZQUM5QjtZQUNBLE1BQU1ELGtCQUFrQk0sS0FBS0MsSUFBSSxDQUFDQyxlQUFlYixNQUFNTyxlQUFlUDtZQUN0RSxPQUFPO2dCQUNISztnQkFDQUMsVUFBVSxJQUFJTyxlQUFlTjtZQUNqQztRQUNKO0lBQ0o7SUFDQSxNQUFNLEVBQUVGLGVBQWUsRUFBRUMsUUFBUSxFQUFFLEdBQUdGO0lBQ3RDLE9BQU87UUFDSFcsT0FBTyxTQUFVQyxHQUFHLEVBQUVDLE1BQU0sRUFBRTFCLEdBQUc7WUFDN0Isb0ZBQW9GO1lBQ3BGLElBQUkyQixTQUFTRCxTQUFTO1lBQ3RCLElBQUlFLE9BQU87WUFDWCxLQUFLLE1BQU0sQ0FBQ0wsR0FBR0wsRUFBRSxJQUFJbEIsSUFBSTZCLE9BQU8sR0FBSTtnQkFDaEMsSUFBSUMsV0FBV3BCLGtCQUFrQkosYUFBYTtnQkFDOUMsSUFBSXlCLFdBQVduQixrQkFBa0JMLGFBQWE7Z0JBQzlDLElBQUl1QixZQUFZLFFBQVFDLFlBQVksTUFBTTtvQkFDdEMsK0RBQStEO29CQUMvRCxpRUFBaUU7b0JBQ2pFLGlDQUFpQztvQkFDakMsTUFBTUMsTUFBTXhCLGNBQWN5QixHQUFHLENBQUNWO29CQUM3QixJQUFHbkIsU0FBUzhCLE1BQU0sRUFBRUYsT0FBTyxNQUFNLENBQUMsb0NBQW9DLEVBQUVULEVBQUVZLFFBQVEsR0FBRyxlQUFlLENBQUM7b0JBQ3RHTCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJQSxXQUFZQSxXQUFXRSxHQUFHLENBQUMsRUFBRTtvQkFDeEVELGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVlBLFdBQVdDLEdBQUcsQ0FBQyxFQUFFO2dCQUM1RTtnQkFDQUYsU0FBU04sS0FBSyxDQUFDQyxLQUFLRSxRQUFRSjtnQkFDNUJJLFVBQVVHLFNBQVNmLFFBQVE7Z0JBQzNCZ0IsU0FBU1AsS0FBSyxDQUFDQyxLQUFLRSxRQUFRVDtnQkFDNUJTLFVBQVVJLFNBQVNoQixRQUFRO2dCQUMzQmE7WUFDSjtZQUNBekIsVUFBVWlDLEdBQUcsQ0FBQ1osS0FBSyxDQUFDQyxLQUFLQyxRQUFRRTtZQUNqQ3hCLFNBQVM4QixNQUFNLENBQUNHLEtBQUssQ0FBQ1QsTUFBTW5CLEtBQUssQ0FBQywwQkFBMEIsRUFBRUEsSUFBSSxVQUFVLEVBQUVtQixLQUFLLENBQUMsQ0FBQztRQUN6RjtRQUNBVSxNQUFNLFNBQVViLEdBQUcsRUFBRUMsTUFBTTtZQUN2QixNQUFNRSxPQUFPekIsVUFBVWlDLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDYixLQUFLQztZQUNyQ3RCLFNBQVM4QixNQUFNLENBQUNHLEtBQUssQ0FBQ1QsTUFBTW5CLEtBQUssQ0FBQywwQkFBMEIsRUFBRUEsSUFBSSxVQUFVLEVBQUVtQixLQUFLLENBQUMsQ0FBQztZQUNyRixJQUFJRCxTQUFTRCxTQUFTO1lBQ3RCLE1BQU0xQixNQUFNLElBQUl1QztZQUNoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVosTUFBTVksSUFBSztnQkFDM0IsbUVBQW1FO2dCQUNuRSw0REFBNEQ7Z0JBQzVELGtCQUFrQjtnQkFDbEIsdURBQXVEO2dCQUN2RCxNQUFNVixXQUFXcEIsa0JBQ1hKLGFBQ0FBLFdBQVdtQyxlQUFlLENBQUNoQixLQUFLRTtnQkFDdEMsTUFBTUosSUFBSU8sU0FBU1EsSUFBSSxDQUFDYixLQUFLRTtnQkFDN0JBLFVBQVVHLFNBQVNmLFFBQVE7Z0JBQzNCLE1BQU1nQixXQUFXbkIsa0JBQ1hMLGFBQ0FBLFdBQVdrQyxlQUFlLENBQUNoQixLQUFLRTtnQkFDdEMsTUFBTVQsSUFBSWEsU0FBU08sSUFBSSxDQUFDYixLQUFLRTtnQkFDN0JBLFVBQVVJLFNBQVNoQixRQUFRO2dCQUMzQmYsSUFBSTBDLEdBQUcsQ0FBQ25CLEdBQUdMO1lBQ2Y7WUFDQSxPQUFPbEI7UUFDWDtRQUNBYztRQUNBQztRQUNBNEIsUUFBUWxDO1FBQ1JtQyxtQkFBbUI7UUFDbkJDLGFBQWEsQ0FBQyxJQUFJLEVBQUV2QyxXQUFXdUMsV0FBVyxDQUFDLEVBQUUsRUFBRXRDLFdBQVdzQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzVFO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVM3QyxJQUFJTSxVQUFVLEVBQUVDLFVBQVU7SUFDL0IsTUFBTXVDLGFBQWEsQ0FBQyxHQUFHN0MsUUFBUVUsZUFBZSxFQUFFTDtJQUNoRCxNQUFNeUMsYUFBYSxDQUFDLEdBQUc5QyxRQUFRVSxlQUFlLEVBQUVKO0lBQ2hELE9BQU87UUFDSGtDLGlCQUFnQmhCLEdBQUcsRUFBRUMsTUFBTTtZQUN2QixNQUFNakIsTUFBTU4sVUFBVWlDLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDYixLQUFLQztZQUNwQyxJQUFJQyxTQUFTRCxTQUFTO1lBQ3RCLHFFQUFxRTtZQUNyRSxJQUFJb0IsY0FBY0MsWUFBWTtnQkFDMUIsT0FBTzFDLGFBQWFDLFlBQVlDLFlBQVksSUFBSWdDLE9BQU85QjtZQUMzRDtZQUNBLHlFQUF5RTtZQUN6RSw4Q0FBOEM7WUFDOUMsTUFBTXVDLGFBQWEsSUFBSVQ7WUFDdkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUkvQixLQUFLK0IsSUFBSztnQkFDMUIsTUFBTVMsV0FBV0gsYUFDWHhDLGFBQ0FBLFdBQVdtQyxlQUFlLENBQUNoQixLQUFLRTtnQkFDdEMsTUFBTXVCLE1BQU1ELFNBQVNYLElBQUksQ0FBQ2IsS0FBS0U7Z0JBQy9CQSxVQUFVc0IsU0FBU2xDLFFBQVE7Z0JBQzNCLE1BQU1vQyxXQUFXSixhQUNYeEMsYUFDQUEsV0FBV2tDLGVBQWUsQ0FBQ2hCLEtBQUtFO2dCQUN0Q0EsVUFBVXdCLFNBQVNwQyxRQUFRO2dCQUMzQmlDLFdBQVdOLEdBQUcsQ0FBQ1EsS0FBSztvQkFBQ0Q7b0JBQVVFO2lCQUFTO1lBQzVDO1lBQ0EsT0FBTzlDLGFBQWFDLFlBQVlDLFlBQVl5QyxZQUFZdkM7UUFDNUQ7UUFDQTJDLGtCQUFpQkMsTUFBTTtZQUNuQixNQUFNNUMsTUFBTTRDLE9BQU96QixJQUFJO1lBQ3ZCLHdFQUF3RTtZQUN4RSxJQUFJa0IsY0FBY0MsWUFBWTtnQkFDMUIsT0FBTzFDLGFBQWFDLFlBQVlDLFlBQVksSUFBSWdDLE9BQU85QjtZQUMzRDtZQUNBLE1BQU11QyxhQUFhLElBQUlUO1lBQ3ZCLEtBQUssTUFBTSxDQUFDaEIsR0FBR0wsRUFBRSxJQUFJbUMsT0FBUTtnQkFDekIsTUFBTUosV0FBV0gsYUFDWHhDLGFBQ0FBLFdBQVc4QyxnQkFBZ0IsQ0FBQzdCO2dCQUNsQyxNQUFNNEIsV0FBV0osYUFDWHhDLGFBQ0FBLFdBQVc2QyxnQkFBZ0IsQ0FBQ2xDO2dCQUNsQzhCLFdBQVdOLEdBQUcsQ0FBQ25CLEdBQUc7b0JBQUMwQjtvQkFBVUU7aUJBQVM7WUFDMUM7WUFDQSxPQUFPOUMsYUFBYUMsWUFBWUMsWUFBWXlDLFlBQVl2QztRQUM1RDtRQUNBb0MsYUFBYSxDQUFDLFdBQVcsRUFBRXZDLFdBQVd1QyxXQUFXLENBQUMsRUFBRSxFQUFFdEMsV0FBV3NDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDbkY7QUFDSjtBQUNBaEQsV0FBVyxHQUFHRztBQUNkOzs7Ozs7Q0FNQyxHQUNESCxtQkFBbUIsR0FBRztJQUNsQjBDLEtBQUs7UUFDRGUsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLFlBQVl2RCxRQUFRd0QsWUFBWTtRQUNoQ0MsSUFBSTtJQUNSO0FBQ0osR0FDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhcGxleC1mb3VuZGF0aW9uK2JlZXRAMC42LjEvbm9kZV9tb2R1bGVzL0BtZXRhcGxleC1mb3VuZGF0aW9uL2JlZXQvZGlzdC9janMvc3JjL2JlZXRzL21hcHMuanM/NTA1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwc1R5cGVNYXAgPSBleHBvcnRzLm1hcCA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCBudW1iZXJzXzEgPSByZXF1aXJlKFwiLi9udW1iZXJzXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVzIGEgbWFwIHdpdGggYSBzcGVjaWZpYyBudW1iZXIgb2Yga2V5L3ZhbHVlcyBvZiB0eXBlIHtAbGluayBLfVxuICogYW5kIHtAbGluayBWfSByZXNwZWN0aXZlbHkuXG4gKlxuICogTk9URTogdGhhdCBpdCBpcyBub3QgZXhwb3J0ZWQgYXMgbm8gZml4ZWQgc2l6ZSBtYXAgZXhpc3RzIGJ1dCB3aWxsIGhhdmUgdG9cbiAqIGJlIGRlcml2ZWQgZnJvbSBkYXRhIG9yIHZhbHVlIGluc3RlYWQuXG4gKlxuICogQHRlbXBsYXRlIEsgdHlwZSBvZiBrZXkgZWxlbWVudHMgaGVsZCBpbiB0aGUgbWFwXG4gKiBAdGVtcGxhdGUgViB0eXBlIG9mIHZhbHVlIGVsZW1lbnRzIGhlbGQgaW4gdGhlIG1hcFxuICpcbiAqIEBwYXJhbSBrZXlFbGVtZW50IHRoZSBEZS9TZXJpYWxpemVycyBmb3IgdGhlIGtleSBlbGVtZW50IHR5cGVzXG4gKiBAcGFyYW0gdmFsRWxlbWVudCB0aGUgRGUvU2VyaWFsaXplcnMgZm9yIHRoZSB2YWx1ZSBlbGVtZW50IHR5cGVzXG4gKiBAcGFyYW0gbGVuIGFtb3VudCBvZiBlbnRyaWVzIGluIHRoZSBtYXBcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb21wb3NpdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZpeGVkU2l6ZU1hcChrZXlFbGVtZW50LCB2YWxFbGVtZW50LCBmaXhlZEVsZW1lbnRzLCBsZW4pIHtcbiAgICBjb25zdCBrZXlFbGVtZW50Rml4ZWQgPSAoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKGtleUVsZW1lbnQpO1xuICAgIGNvbnN0IHZhbEVsZW1lbnRGaXhlZCA9ICgwLCB0eXBlc18xLmlzRml4ZWRTaXplQmVldCkodmFsRWxlbWVudCk7XG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lU2l6ZXMoKSB7XG4gICAgICAgIGlmIChrZXlFbGVtZW50Rml4ZWQgJiYgdmFsRWxlbWVudEZpeGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Qnl0ZVNpemUgPSBrZXlFbGVtZW50LmJ5dGVTaXplICsgdmFsRWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudEJ5dGVTaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVTaXplOiA0ICsgbGVuICogZWxlbWVudEJ5dGVTaXplLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlFbGVtZW50Rml4ZWQpIHtcbiAgICAgICAgICAgIGxldCB2YWxzQnl0ZVNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbXywgdl0gb2YgZml4ZWRFbGVtZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHZhbHNCeXRlU2l6ZSArPSB2LmJ5dGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYW55IGVsZW1lbnQgaGFzIGEgZHluYW1pYyBzaXplIGFsbCB3ZSBjYW4gZG8gaGVyZSBpcyB0YWtlIGFuIGF2ZXJhZ2VcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRCeXRlU2l6ZSA9IGtleUVsZW1lbnQuYnl0ZVNpemUgKyBNYXRoLmNlaWwodmFsc0J5dGVTaXplIC8gbGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudEJ5dGVTaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVTaXplOiA0ICsga2V5RWxlbWVudC5ieXRlU2l6ZSAqIGxlbiArIHZhbHNCeXRlU2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsRWxlbWVudEZpeGVkKSB7XG4gICAgICAgICAgICBsZXQga2V5c0J5dGVTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIF9dIG9mIGZpeGVkRWxlbWVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBrZXlzQnl0ZVNpemUgKz0gay5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRCeXRlU2l6ZSA9IE1hdGguY2VpbChrZXlzQnl0ZVNpemUgLyBsZW4pICsgdmFsRWxlbWVudC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudEJ5dGVTaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVTaXplOiA0ICsga2V5c0J5dGVTaXplICsgdmFsRWxlbWVudC5ieXRlU2l6ZSAqIGxlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQga2V5c0J5dGVTaXplID0gMDtcbiAgICAgICAgICAgIGxldCB2YWxzQnl0ZVNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZml4ZWRFbGVtZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGtleXNCeXRlU2l6ZSArPSBrLmJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIHZhbHNCeXRlU2l6ZSArPSB2LmJ5dGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudEJ5dGVTaXplID0gTWF0aC5jZWlsKGtleXNCeXRlU2l6ZSAvIGxlbiArIHZhbHNCeXRlU2l6ZSAvIGxlbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRCeXRlU2l6ZSxcbiAgICAgICAgICAgICAgICBieXRlU2l6ZTogNCArIGtleXNCeXRlU2l6ZSArIHZhbHNCeXRlU2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBlbGVtZW50Qnl0ZVNpemUsIGJ5dGVTaXplIH0gPSBkZXRlcm1pbmVTaXplcygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIG1hcCkge1xuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIHZhbHVlcyBmaXJzdCBhbmQgdGhlbiB0aGUgc2l6ZSBhcyBpdCBjb21lcyBjbGVhciB3aGlsZSB3ZSBkbyB0aGUgZm9ybWVyXG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gb2Zmc2V0ICsgNDtcbiAgICAgICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZml4ZWRLZXkgPSBrZXlFbGVtZW50Rml4ZWQgPyBrZXlFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZml4ZWRWYWwgPSB2YWxFbGVtZW50Rml4ZWQgPyB2YWxFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWRLZXkgPT0gbnVsbCB8fCBmaXhlZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2Ugd3JpdGUgdGhlIHZhbHVlIHdlIGtub3cgdGhlIGtleSBhbmQgYW4ganVzdCBwdWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGluZyBmaXhlZCBiZWV0IGZvciBrZXkvdmFsIGZyb20gdGhlIHByb3ZpZGVkIG1hcCB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgdGhhbiBmaXhpbmcgaXQgYnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxzID0gZml4ZWRFbGVtZW50cy5nZXQoayk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfMS5zdHJpY3QpKGVscyAhPSBudWxsLCBgU2hvdWxkIGJlIGFibGUgdG8gZmluZCBiZWV0IGVscyBmb3IgJHtrLnRvU3RyaW5nKCl9LCBidXQgY291bGQgbm90YCk7XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkS2V5ICE9PSBudWxsICYmIGZpeGVkS2V5ICE9PSB2b2lkIDAgPyBmaXhlZEtleSA6IChmaXhlZEtleSA9IGVsc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkVmFsICE9PSBudWxsICYmIGZpeGVkVmFsICE9PSB2b2lkIDAgPyBmaXhlZFZhbCA6IChmaXhlZFZhbCA9IGVsc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkS2V5LndyaXRlKGJ1ZiwgY3Vyc29yLCBrKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gZml4ZWRLZXkuYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgZml4ZWRWYWwud3JpdGUoYnVmLCBjdXJzb3IsIHYpO1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBmaXhlZFZhbC5ieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXJzXzEudTMyLndyaXRlKGJ1Ziwgb2Zmc2V0LCBzaXplKTtcbiAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5lcXVhbChzaXplLCBsZW4sIGBFeHBlY3RlZCBtYXAgdG8gaGF2ZSBzaXplICR7bGVufSwgYnV0IGhhcyAke3NpemV9LmApO1xuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBudW1iZXJzXzEudTMyLnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmVxdWFsKHNpemUsIGxlbiwgYEV4cGVjdGVkIG1hcCB0byBoYXZlIHNpemUgJHtsZW59LCBidXQgaGFzICR7c2l6ZX0uYCk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gb2Zmc2V0ICsgNDtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSByZWFkIHRoZSB2YWx1ZSBmcm9tIGEgYnVmZmVyIHdlIGRvbid0IGtub3cgdGhlIGtleSB3ZSdyZVxuICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgeWV0IGFuZCB0aHVzIGNhbm5vdCB1c2UgdGhlIHByb3ZpZGVkIG1hcCBvZiBmaXhlZFxuICAgICAgICAgICAgICAgIC8vIGRlL3NlcmlhbGl6ZXJzLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBvYnRhaW4gaXQgYnkgZml4aW5nIGl0IGJ5IGRhdGEgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICBjb25zdCBmaXhlZEtleSA9IGtleUVsZW1lbnRGaXhlZFxuICAgICAgICAgICAgICAgICAgICA/IGtleUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiBrZXlFbGVtZW50LnRvRml4ZWRGcm9tRGF0YShidWYsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IGZpeGVkS2V5LnJlYWQoYnVmLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBmaXhlZEtleS5ieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXhlZFZhbCA9IHZhbEVsZW1lbnRGaXhlZFxuICAgICAgICAgICAgICAgICAgICA/IHZhbEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiB2YWxFbGVtZW50LnRvRml4ZWRGcm9tRGF0YShidWYsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGZpeGVkVmFsLnJlYWQoYnVmLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBmaXhlZFZhbC5ieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGssIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudEJ5dGVTaXplLFxuICAgICAgICBieXRlU2l6ZSxcbiAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgIGxlblByZWZpeEJ5dGVTaXplOiA0LFxuICAgICAgICBkZXNjcmlwdGlvbjogYE1hcDwke2tleUVsZW1lbnQuZGVzY3JpcHRpb259LCAke3ZhbEVsZW1lbnQuZGVzY3JpcHRpb259PmAsXG4gICAgfTtcbn1cbi8qKlxuICogRGUvU2VyaWFsaXplcyBhIG1hcCB3aXRoIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGtleS92YWx1ZXMgb2YgdHlwZSB7QGxpbmsgS31cbiAqIGFuZCB7QGxpbmsgVn0gcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEB0ZW1wbGF0ZSBLIHR5cGUgb2Yga2V5IGVsZW1lbnRzIGhlbGQgaW4gdGhlIG1hcFxuICogQHRlbXBsYXRlIFYgdHlwZSBvZiB2YWx1ZSBlbGVtZW50cyBoZWxkIGluIHRoZSBtYXBcbiAqXG4gKiBAcGFyYW0ga2V5RWxlbWVudCB0aGUgX2ZpeGFibGVfIG9yIF9maXhlZF8gZGUvc2VyaWFsaXplcnMgZm9yIHRoZSBrZXkgZWxlbWVudCB0eXBlc1xuICogQHBhcmFtIHZhbEVsZW1lbnQgdGhlIF9maXhhYmxlXyBvciBfZml4ZWRfIGRlL3NlcmlhbGl6ZXJzIGZvciB0aGUgdmFsdWUgZWxlbWVudCB0eXBlc1xuICpcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbXBvc2l0ZVxuICovXG5mdW5jdGlvbiBtYXAoa2V5RWxlbWVudCwgdmFsRWxlbWVudCkge1xuICAgIGNvbnN0IGtleUlzRml4ZWQgPSAoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKGtleUVsZW1lbnQpO1xuICAgIGNvbnN0IHZhbElzRml4ZWQgPSAoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKHZhbEVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvRml4ZWRGcm9tRGF0YShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBvZmZzZXQgKyA0O1xuICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIHRoZSBjYXNlIHRoYXQgYm90aCBrZXkgYW5kIHZhbHVlIGFyZSBmaXhlZCBzaXplIGJlZXRzXG4gICAgICAgICAgICBpZiAoa2V5SXNGaXhlZCAmJiB2YWxJc0ZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkU2l6ZU1hcChrZXlFbGVtZW50LCB2YWxFbGVtZW50LCBuZXcgTWFwKCksIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBlaXRoZXIga2V5IG9yIHZhbCBhcmUgbm90IGZpeGVkIHNpemUgYmVldHMgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlXG4gICAgICAgICAgICAvLyBmaXhlZCB2ZXJzaW9ucyBhbmQgYWRkIHRoZW0gdG8gYSBtYXAgYnkga2V5XG4gICAgICAgICAgICBjb25zdCBmaXhlZEJlZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUZpeGVkID0ga2V5SXNGaXhlZFxuICAgICAgICAgICAgICAgICAgICA/IGtleUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiBrZXlFbGVtZW50LnRvRml4ZWRGcm9tRGF0YShidWYsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5Rml4ZWQucmVhZChidWYsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGtleUZpeGVkLmJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbEZpeGVkID0gdmFsSXNGaXhlZFxuICAgICAgICAgICAgICAgICAgICA/IHZhbEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiB2YWxFbGVtZW50LnRvRml4ZWRGcm9tRGF0YShidWYsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IHZhbEZpeGVkLmJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIGZpeGVkQmVldHMuc2V0KGtleSwgW2tleUZpeGVkLCB2YWxGaXhlZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeGVkU2l6ZU1hcChrZXlFbGVtZW50LCB2YWxFbGVtZW50LCBmaXhlZEJlZXRzLCBsZW4pO1xuICAgICAgICB9LFxuICAgICAgICB0b0ZpeGVkRnJvbVZhbHVlKG1hcFZhbCkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbWFwVmFsLnNpemU7XG4gICAgICAgICAgICAvLyBBcyBhYm92ZSBzaG9ydGN1dCBmb3IgdGhlIG9wdGltYWwgY2FzZSBhbmQgYnVpbGQgYSBtYXAgZm9yIGFsbCBvdGhlcnNcbiAgICAgICAgICAgIGlmIChrZXlJc0ZpeGVkICYmIHZhbElzRml4ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRTaXplTWFwKGtleUVsZW1lbnQsIHZhbEVsZW1lbnQsIG5ldyBNYXAoKSwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpeGVkQmVldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBtYXBWYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlGaXhlZCA9IGtleUlzRml4ZWRcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIDoga2V5RWxlbWVudC50b0ZpeGVkRnJvbVZhbHVlKGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbEZpeGVkID0gdmFsSXNGaXhlZFxuICAgICAgICAgICAgICAgICAgICA/IHZhbEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiB2YWxFbGVtZW50LnRvRml4ZWRGcm9tVmFsdWUodik7XG4gICAgICAgICAgICAgICAgZml4ZWRCZWV0cy5zZXQoaywgW2tleUZpeGVkLCB2YWxGaXhlZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeGVkU2l6ZU1hcChrZXlFbGVtZW50LCB2YWxFbGVtZW50LCBmaXhlZEJlZXRzLCBsZW4pO1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogYEZpeGFibGVNYXA8JHtrZXlFbGVtZW50LmRlc2NyaXB0aW9ufSwgJHt2YWxFbGVtZW50LmRlc2NyaXB0aW9ufT5gLFxuICAgIH07XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogTWFwcyBtYXBzIGJlZXQgZXhwb3J0cyB0byBtZXRhZGF0YSB3aGljaCBkZXNjcmliZXMgaW4gd2hpY2ggcGFja2FnZSBpdFxuICogaXMgZGVmaW5lZCBhcyB3ZWxsIGFzIHdoaWNoIFR5cGVTY3JpcHQgdHlwZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAqIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBjYXRlZ29yeSBUeXBlRGVmaW5pdGlvblxuICovXG5leHBvcnRzLm1hcHNUeXBlTWFwID0ge1xuICAgIE1hcDoge1xuICAgICAgICBiZWV0OiAnbWFwJyxcbiAgICAgICAgaXNGaXhhYmxlOiB0cnVlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdNYXAnLFxuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXBzVHlwZU1hcCIsIm1hcCIsInR5cGVzXzEiLCJyZXF1aXJlIiwibnVtYmVyc18xIiwiYXNzZXJ0XzEiLCJmaXhlZFNpemVNYXAiLCJrZXlFbGVtZW50IiwidmFsRWxlbWVudCIsImZpeGVkRWxlbWVudHMiLCJsZW4iLCJrZXlFbGVtZW50Rml4ZWQiLCJpc0ZpeGVkU2l6ZUJlZXQiLCJ2YWxFbGVtZW50Rml4ZWQiLCJkZXRlcm1pbmVTaXplcyIsImVsZW1lbnRCeXRlU2l6ZSIsImJ5dGVTaXplIiwidmFsc0J5dGVTaXplIiwiXyIsInYiLCJ2YWx1ZXMiLCJNYXRoIiwiY2VpbCIsImtleXNCeXRlU2l6ZSIsImsiLCJ3cml0ZSIsImJ1ZiIsIm9mZnNldCIsImN1cnNvciIsInNpemUiLCJlbnRyaWVzIiwiZml4ZWRLZXkiLCJmaXhlZFZhbCIsImVscyIsImdldCIsInN0cmljdCIsInRvU3RyaW5nIiwidTMyIiwiZXF1YWwiLCJyZWFkIiwiTWFwIiwiaSIsInRvRml4ZWRGcm9tRGF0YSIsInNldCIsImxlbmd0aCIsImxlblByZWZpeEJ5dGVTaXplIiwiZGVzY3JpcHRpb24iLCJrZXlJc0ZpeGVkIiwidmFsSXNGaXhlZCIsImZpeGVkQmVldHMiLCJrZXlGaXhlZCIsImtleSIsInZhbEZpeGVkIiwidG9GaXhlZEZyb21WYWx1ZSIsIm1hcFZhbCIsImJlZXQiLCJpc0ZpeGFibGUiLCJzb3VyY2VQYWNrIiwiQkVFVF9QQUNLQUdFIiwidHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.numbersTypeMap = exports.bool = exports.i512 = exports.i256 = exports.i128 = exports.i64 = exports.i32 = exports.i16 = exports.i8 = exports.u512 = exports.u256 = exports.u128 = exports.u64 = exports.u32 = exports.u16 = exports.u8 = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\n// -----------------\n// Unsigned\n// -----------------\n/**\n * De/Serializer for 8-bit unsigned integers aka `u8`.\n *\n * @category beet/primitive\n */ exports.u8 = {\n    write: function(buf, offset, value) {\n        buf.writeUInt8(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readUInt8(offset);\n    },\n    byteSize: 1,\n    description: \"u8\"\n};\n/**\n * De/Serializer 16-bit unsigned integers aka `u16`.\n *\n * @category beet/primitive\n */ exports.u16 = {\n    write: function(buf, offset, value) {\n        buf.writeUInt16LE(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readUInt16LE(offset);\n    },\n    byteSize: 2,\n    description: \"u16\"\n};\n/**\n * De/Serializer for 32-bit unsigned integers aka `u32`.\n *\n * @category beet/primitive\n */ exports.u32 = {\n    write: function(buf, offset, value) {\n        buf.writeUInt32LE(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readUInt32LE(offset);\n    },\n    byteSize: 4,\n    description: \"u32\"\n};\nfunction unsignedLargeBeet(byteSize, description) {\n    return {\n        write: function(buf, offset, value) {\n            const bn = bn_js_1.default.isBN(value) ? value : new bn_js_1.default(value);\n            const bytesArray = bn.toArray(\"le\", this.byteSize);\n            const bytesArrayBuf = Buffer.from(bytesArray);\n            bytesArrayBuf.copy(buf, offset, 0, this.byteSize);\n        },\n        read: function(buf, offset) {\n            const slice = buf.slice(offset, offset + this.byteSize);\n            return new bn_js_1.default(slice, \"le\");\n        },\n        byteSize,\n        description\n    };\n}\n/**\n * De/Serializer for 64-bit unsigned integers aka `u64` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.u64 = unsignedLargeBeet(8, \"u64\");\n/**\n * De/Serializer for 128-bit unsigned integers aka `u128` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.u128 = unsignedLargeBeet(16, \"u128\");\n/**\n * De/Serializer for 256-bit unsigned integers aka `u256` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.u256 = unsignedLargeBeet(32, \"u256\");\n/**\n * De/Serializer for 512-bit unsigned integers aka `u512` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.u512 = unsignedLargeBeet(64, \"u512\");\n// -----------------\n// Signed\n// -----------------\n/**\n * De/Serializer 8-bit signed integers aka `i8`.\n *\n * @category beet/primitive\n */ exports.i8 = {\n    write: function(buf, offset, value) {\n        buf.writeInt8(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readInt8(offset);\n    },\n    byteSize: 1,\n    description: \"i8\"\n};\n/**\n * De/Serializer 16-bit signed integers aka `i16`.\n *\n * @category beet/primitive\n */ exports.i16 = {\n    write: function(buf, offset, value) {\n        buf.writeInt16LE(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readInt16LE(offset);\n    },\n    byteSize: 2,\n    description: \"i16\"\n};\n/**\n * De/Serializer 32-bit signed integers aka `i32`.\n *\n * @category beet/primitive\n */ exports.i32 = {\n    write: function(buf, offset, value) {\n        buf.writeInt32LE(value, offset);\n    },\n    read: function(buf, offset) {\n        return buf.readInt32LE(offset);\n    },\n    byteSize: 4,\n    description: \"i32\"\n};\nfunction signedLargeBeet(byteSize, description) {\n    const bitSize = byteSize * 8;\n    return {\n        write: function(buf, offset, value) {\n            const bn = (bn_js_1.default.isBN(value) ? value : new bn_js_1.default(value)).toTwos(bitSize);\n            const bytesArray = bn.toArray(\"le\", this.byteSize);\n            const bytesArrayBuf = Buffer.from(bytesArray);\n            bytesArrayBuf.copy(buf, offset, 0, this.byteSize);\n        },\n        read: function(buf, offset) {\n            const slice = buf.slice(offset, offset + this.byteSize);\n            const x = new bn_js_1.default(slice, \"le\");\n            return x.fromTwos(bitSize);\n        },\n        byteSize,\n        description\n    };\n}\n/**\n * De/Serializer for 64-bit signed integers aka `i64` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.i64 = signedLargeBeet(8, \"i64\");\n/**\n * De/Serializer for 128-bit signed integers aka `i128` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.i128 = signedLargeBeet(16, \"i128\");\n/**\n * De/Serializer for 256-bit signed integers aka `i256` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.i256 = signedLargeBeet(32, \"i256\");\n/**\n * De/Serializer for 512-bit signed integers aka `i512` which serializes to a JavaScript\n * _BigNum_ via {@link https://github.com/indutny/bn.js | BN}.\n *\n * @category beet/primitive\n */ exports.i512 = signedLargeBeet(64, \"i512\");\n// -----------------\n// Boolean\n// -----------------\n/**\n * De/Serializer booleans aka `bool`.\n *\n * @category beet/primitive\n */ exports.bool = {\n    write: function(buf, offset, value) {\n        const n = value ? 1 : 0;\n        exports.u8.write(buf, offset, n);\n    },\n    read: function(buf, offset) {\n        return exports.u8.read(buf, offset) === 1;\n    },\n    byteSize: 1,\n    description: \"bool\"\n};\n/**\n * Maps primitive beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ // prettier-ignore\nexports.numbersTypeMap = {\n    // <= 32-bit numbers and boolean\n    u8: {\n        beet: \"u8\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    u16: {\n        beet: \"u16\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    u32: {\n        beet: \"u32\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    i8: {\n        beet: \"i8\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    i16: {\n        beet: \"i16\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    i32: {\n        beet: \"i32\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"number\"\n    },\n    bool: {\n        beet: \"bool\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"boolean\"\n    },\n    // Big Number, they use, the 'bignum' type which is defined in this package\n    u64: {\n        beet: \"u64\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    u128: {\n        beet: \"u128\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    u256: {\n        beet: \"u256\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    u512: {\n        beet: \"u512\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    i64: {\n        beet: \"i64\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    i128: {\n        beet: \"i128\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    i256: {\n        beet: \"i256\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    },\n    i512: {\n        beet: \"i512\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"bignum\",\n        pack: types_1.BEET_PACKAGE\n    }\n}; //# sourceMappingURL=numbers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxVQUFVLEdBQUcsS0FBSztBQUNyUCxNQUFNa0IsVUFBVXZCLGdCQUFnQndCLG1CQUFPQSxDQUFDLGtGQUFPO0FBQy9DLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCOzs7O0NBSUMsR0FDRG5CLFVBQVUsR0FBRztJQUNUcUIsT0FBTyxTQUFVQyxHQUFHLEVBQUVDLE1BQU0sRUFBRXRCLEtBQUs7UUFDL0JxQixJQUFJRSxVQUFVLENBQUN2QixPQUFPc0I7SUFDMUI7SUFDQUUsTUFBTSxTQUFVSCxHQUFHLEVBQUVDLE1BQU07UUFDdkIsT0FBT0QsSUFBSUksU0FBUyxDQUFDSDtJQUN6QjtJQUNBSSxVQUFVO0lBQ1ZDLGFBQWE7QUFDakI7QUFDQTs7OztDQUlDLEdBQ0Q1QixXQUFXLEdBQUc7SUFDVnFCLE9BQU8sU0FBVUMs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dUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ25IL0MsTUFBTTtRQUFFNEMsTUFBTTtRQUFRQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ25IaEQsTUFBTTtRQUFFNkMsTUFBTTtRQUFRQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ25IcEQsS0FBSztRQUFFaUQsTUFBTTtRQUFPQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ2pIckQsTUFBTTtRQUFFa0QsTUFBTTtRQUFRQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ25IdEQsTUFBTTtRQUFFbUQsTUFBTTtRQUFRQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0lBQ25IdkQsTUFBTTtRQUFFb0QsTUFBTTtRQUFRQyxXQUFXO1FBQU9DLFlBQVl0QyxRQUFRdUMsWUFBWTtRQUFFQyxJQUFJO1FBQVVDLE1BQU16QyxRQUFRdUMsWUFBWTtJQUFDO0FBQ3ZILEdBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YXBsZXgtZm91bmRhdGlvbitiZWV0QDAuNi4xL25vZGVfbW9kdWxlcy9AbWV0YXBsZXgtZm91bmRhdGlvbi9iZWV0L2Rpc3QvY2pzL3NyYy9iZWV0cy9udW1iZXJzLmpzPzc1ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51bWJlcnNUeXBlTWFwID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5pNTEyID0gZXhwb3J0cy5pMjU2ID0gZXhwb3J0cy5pMTI4ID0gZXhwb3J0cy5pNjQgPSBleHBvcnRzLmkzMiA9IGV4cG9ydHMuaTE2ID0gZXhwb3J0cy5pOCA9IGV4cG9ydHMudTUxMiA9IGV4cG9ydHMudTI1NiA9IGV4cG9ydHMudTEyOCA9IGV4cG9ydHMudTY0ID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnUxNiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuc2lnbmVkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBha2EgYHU4YC5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9wcmltaXRpdmVcbiAqL1xuZXhwb3J0cy51OCA9IHtcbiAgICB3cml0ZTogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBidWYud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIH0sXG4gICAgYnl0ZVNpemU6IDEsXG4gICAgZGVzY3JpcHRpb246ICd1OCcsXG59O1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBha2EgYHUxNmAuXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMudTE2ID0ge1xuICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkxFKG9mZnNldCk7XG4gICAgfSxcbiAgICBieXRlU2l6ZTogMixcbiAgICBkZXNjcmlwdGlvbjogJ3UxNicsXG59O1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMgYWthIGB1MzJgLlxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L3ByaW1pdGl2ZVxuICovXG5leHBvcnRzLnUzMiA9IHtcbiAgICB3cml0ZTogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBidWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgIH0sXG4gICAgYnl0ZVNpemU6IDQsXG4gICAgZGVzY3JpcHRpb246ICd1MzInLFxufTtcbmZ1bmN0aW9uIHVuc2lnbmVkTGFyZ2VCZWV0KGJ5dGVTaXplLCBkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBibiA9IGJuX2pzXzEuZGVmYXVsdC5pc0JOKHZhbHVlKSA/IHZhbHVlIDogbmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBieXRlc0FycmF5ID0gYm4udG9BcnJheSgnbGUnLCB0aGlzLmJ5dGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzQXJyYXlCdWYgPSBCdWZmZXIuZnJvbShieXRlc0FycmF5KTtcbiAgICAgICAgICAgIGJ5dGVzQXJyYXlCdWYuY29weShidWYsIG9mZnNldCwgMCwgdGhpcy5ieXRlU2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBidWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmJ5dGVTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KHNsaWNlLCAnbGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYnl0ZVNpemUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgIH07XG59XG4vKipcbiAqIERlL1NlcmlhbGl6ZXIgZm9yIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBha2EgYHU2NGAgd2hpY2ggc2VyaWFsaXplcyB0byBhIEphdmFTY3JpcHRcbiAqIF9CaWdOdW1fIHZpYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMgfCBCTn0uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMudTY0ID0gdW5zaWduZWRMYXJnZUJlZXQoOCwgJ3U2NCcpO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciAxMjgtYml0IHVuc2lnbmVkIGludGVnZXJzIGFrYSBgdTEyOGAgd2hpY2ggc2VyaWFsaXplcyB0byBhIEphdmFTY3JpcHRcbiAqIF9CaWdOdW1fIHZpYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMgfCBCTn0uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMudTEyOCA9IHVuc2lnbmVkTGFyZ2VCZWV0KDE2LCAndTEyOCcpO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciAyNTYtYml0IHVuc2lnbmVkIGludGVnZXJzIGFrYSBgdTI1NmAgd2hpY2ggc2VyaWFsaXplcyB0byBhIEphdmFTY3JpcHRcbiAqIF9CaWdOdW1fIHZpYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMgfCBCTn0uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMudTI1NiA9IHVuc2lnbmVkTGFyZ2VCZWV0KDMyLCAndTI1NicpO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciA1MTItYml0IHVuc2lnbmVkIGludGVnZXJzIGFrYSBgdTUxMmAgd2hpY2ggc2VyaWFsaXplcyB0byBhIEphdmFTY3JpcHRcbiAqIF9CaWdOdW1fIHZpYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMgfCBCTn0uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMudTUxMiA9IHVuc2lnbmVkTGFyZ2VCZWV0KDY0LCAndTUxMicpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNpZ25lZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogRGUvU2VyaWFsaXplciA4LWJpdCBzaWduZWQgaW50ZWdlcnMgYWthIGBpOGAuXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMuaTggPSB7XG4gICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgYnVmLndyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRJbnQ4KG9mZnNldCk7XG4gICAgfSxcbiAgICBieXRlU2l6ZTogMSxcbiAgICBkZXNjcmlwdGlvbjogJ2k4Jyxcbn07XG4vKipcbiAqIERlL1NlcmlhbGl6ZXIgMTYtYml0IHNpZ25lZCBpbnRlZ2VycyBha2EgYGkxNmAuXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMuaTE2ID0ge1xuICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCk7XG4gICAgfSxcbiAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkSW50MTZMRShvZmZzZXQpO1xuICAgIH0sXG4gICAgYnl0ZVNpemU6IDIsXG4gICAgZGVzY3JpcHRpb246ICdpMTYnLFxufTtcbi8qKlxuICogRGUvU2VyaWFsaXplciAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGFrYSBgaTMyYC5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9wcmltaXRpdmVcbiAqL1xuZXhwb3J0cy5pMzIgPSB7XG4gICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRJbnQzMkxFKG9mZnNldCk7XG4gICAgfSxcbiAgICBieXRlU2l6ZTogNCxcbiAgICBkZXNjcmlwdGlvbjogJ2kzMicsXG59O1xuZnVuY3Rpb24gc2lnbmVkTGFyZ2VCZWV0KGJ5dGVTaXplLCBkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IGJpdFNpemUgPSBieXRlU2l6ZSAqIDg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJuID0gKGJuX2pzXzEuZGVmYXVsdC5pc0JOKHZhbHVlKSA/IHZhbHVlIDogbmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkpLnRvVHdvcyhiaXRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzQXJyYXkgPSBibi50b0FycmF5KCdsZScsIHRoaXMuYnl0ZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNBcnJheUJ1ZiA9IEJ1ZmZlci5mcm9tKGJ5dGVzQXJyYXkpO1xuICAgICAgICAgICAgYnl0ZXNBcnJheUJ1Zi5jb3B5KGJ1Ziwgb2Zmc2V0LCAwLCB0aGlzLmJ5dGVTaXplKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuYnl0ZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgeCA9IG5ldyBibl9qc18xLmRlZmF1bHQoc2xpY2UsICdsZScpO1xuICAgICAgICAgICAgcmV0dXJuIHguZnJvbVR3b3MoYml0U2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJ5dGVTaXplLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICB9O1xufVxuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciA2NC1iaXQgc2lnbmVkIGludGVnZXJzIGFrYSBgaTY0YCB3aGljaCBzZXJpYWxpemVzIHRvIGEgSmF2YVNjcmlwdFxuICogX0JpZ051bV8gdmlhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcyB8IEJOfS5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9wcmltaXRpdmVcbiAqL1xuZXhwb3J0cy5pNjQgPSBzaWduZWRMYXJnZUJlZXQoOCwgJ2k2NCcpO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVyIGZvciAxMjgtYml0IHNpZ25lZCBpbnRlZ2VycyBha2EgYGkxMjhgIHdoaWNoIHNlcmlhbGl6ZXMgdG8gYSBKYXZhU2NyaXB0XG4gKiBfQmlnTnVtXyB2aWEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzIHwgQk59LlxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L3ByaW1pdGl2ZVxuICovXG5leHBvcnRzLmkxMjggPSBzaWduZWRMYXJnZUJlZXQoMTYsICdpMTI4Jyk7XG4vKipcbiAqIERlL1NlcmlhbGl6ZXIgZm9yIDI1Ni1iaXQgc2lnbmVkIGludGVnZXJzIGFrYSBgaTI1NmAgd2hpY2ggc2VyaWFsaXplcyB0byBhIEphdmFTY3JpcHRcbiAqIF9CaWdOdW1fIHZpYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMgfCBCTn0uXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvcHJpbWl0aXZlXG4gKi9cbmV4cG9ydHMuaTI1NiA9IHNpZ25lZExhcmdlQmVldCgzMiwgJ2kyNTYnKTtcbi8qKlxuICogRGUvU2VyaWFsaXplciBmb3IgNTEyLWJpdCBzaWduZWQgaW50ZWdlcnMgYWthIGBpNTEyYCB3aGljaCBzZXJpYWxpemVzIHRvIGEgSmF2YVNjcmlwdFxuICogX0JpZ051bV8gdmlhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcyB8IEJOfS5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9wcmltaXRpdmVcbiAqL1xuZXhwb3J0cy5pNTEyID0gc2lnbmVkTGFyZ2VCZWV0KDY0LCAnaTUxMicpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJvb2xlYW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIERlL1NlcmlhbGl6ZXIgYm9vbGVhbnMgYWthIGBib29sYC5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9wcmltaXRpdmVcbiAqL1xuZXhwb3J0cy5ib29sID0ge1xuICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICBleHBvcnRzLnU4LndyaXRlKGJ1Ziwgb2Zmc2V0LCBuKTtcbiAgICB9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy51OC5yZWFkKGJ1Ziwgb2Zmc2V0KSA9PT0gMTtcbiAgICB9LFxuICAgIGJ5dGVTaXplOiAxLFxuICAgIGRlc2NyaXB0aW9uOiAnYm9vbCcsXG59O1xuLyoqXG4gKiBNYXBzIHByaW1pdGl2ZSBiZWV0IGV4cG9ydHMgdG8gbWV0YWRhdGEgd2hpY2ggZGVzY3JpYmVzIGluIHdoaWNoIHBhY2thZ2UgaXRcbiAqIGlzIGRlZmluZWQgYXMgd2VsbCBhcyB3aGljaCBUeXBlU2NyaXB0IHR5cGUgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlXG4gKiBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHlwZURlZmluaXRpb25cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnRzLm51bWJlcnNUeXBlTWFwID0ge1xuICAgIC8vIDw9IDMyLWJpdCBudW1iZXJzIGFuZCBib29sZWFuXG4gICAgdTg6IHsgYmVldDogJ3U4JywgaXNGaXhhYmxlOiBmYWxzZSwgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsIHRzOiAnbnVtYmVyJyB9LFxuICAgIHUxNjogeyBiZWV0OiAndTE2JywgaXNGaXhhYmxlOiBmYWxzZSwgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsIHRzOiAnbnVtYmVyJyB9LFxuICAgIHUzMjogeyBiZWV0OiAndTMyJywgaXNGaXhhYmxlOiBmYWxzZSwgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsIHRzOiAnbnVtYmVyJyB9LFxuICAgIGk4OiB7IGJlZXQ6ICdpOCcsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ251bWJlcicgfSxcbiAgICBpMTY6IHsgYmVldDogJ2kxNicsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ251bWJlcicgfSxcbiAgICBpMzI6IHsgYmVldDogJ2kzMicsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ251bWJlcicgfSxcbiAgICBib29sOiB7IGJlZXQ6ICdib29sJywgaXNGaXhhYmxlOiBmYWxzZSwgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsIHRzOiAnYm9vbGVhbicgfSxcbiAgICAvLyBCaWcgTnVtYmVyLCB0aGV5IHVzZSwgdGhlICdiaWdudW0nIHR5cGUgd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGlzIHBhY2thZ2VcbiAgICB1NjQ6IHsgYmVldDogJ3U2NCcsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ2JpZ251bScsIHBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFIH0sXG4gICAgdTEyODogeyBiZWV0OiAndTEyOCcsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ2JpZ251bScsIHBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFIH0sXG4gICAgdTI1NjogeyBiZWV0OiAndTI1NicsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ2JpZ251bScsIHBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFIH0sXG4gICAgdTUxMjogeyBiZWV0OiAndTUxMicsIGlzRml4YWJsZTogZmFsc2UsIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLCB0czogJ2JpZ251bScsIHBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFIH0sXG4gICAgaTY0OiB7IGJlZXQ6ICdpNjQnLCBpc0ZpeGFibGU6IGZhbHNlLCBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSwgdHM6ICdiaWdudW0nLCBwYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSB9LFxuICAgIGkxMjg6IHsgYmVldDogJ2kxMjgnLCBpc0ZpeGFibGU6IGZhbHNlLCBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSwgdHM6ICdiaWdudW0nLCBwYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSB9LFxuICAgIGkyNTY6IHsgYmVldDogJ2kyNTYnLCBpc0ZpeGFibGU6IGZhbHNlLCBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSwgdHM6ICdiaWdudW0nLCBwYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSB9LFxuICAgIGk1MTI6IHsgYmVldDogJ2k1MTInLCBpc0ZpeGFibGU6IGZhbHNlLCBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSwgdHM6ICdiaWdudW0nLCBwYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlcnMuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm51bWJlcnNUeXBlTWFwIiwiYm9vbCIsImk1MTIiLCJpMjU2IiwiaTEyOCIsImk2NCIsImkzMiIsImkxNiIsImk4IiwidTUxMiIsInUyNTYiLCJ1MTI4IiwidTY0IiwidTMyIiwidTE2IiwidTgiLCJibl9qc18xIiwicmVxdWlyZSIsInR5cGVzXzEiLCJ3cml0ZSIsImJ1ZiIsIm9mZnNldCIsIndyaXRlVUludDgiLCJyZWFkIiwicmVhZFVJbnQ4IiwiYnl0ZVNpemUiLCJkZXNjcmlwdGlvbiIsIndyaXRlVUludDE2TEUiLCJyZWFkVUludDE2TEUiLCJ3cml0ZVVJbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwidW5zaWduZWRMYXJnZUJlZXQiLCJibiIsImRlZmF1bHQiLCJpc0JOIiwiYnl0ZXNBcnJheSIsInRvQXJyYXkiLCJieXRlc0FycmF5QnVmIiwiQnVmZmVyIiwiZnJvbSIsImNvcHkiLCJzbGljZSIsIndyaXRlSW50OCIsInJlYWRJbnQ4Iiwid3JpdGVJbnQxNkxFIiwicmVhZEludDE2TEUiLCJ3cml0ZUludDMyTEUiLCJyZWFkSW50MzJMRSIsInNpZ25lZExhcmdlQmVldCIsImJpdFNpemUiLCJ0b1R3b3MiLCJ4IiwiZnJvbVR3b3MiLCJuIiwiYmVldCIsImlzRml4YWJsZSIsInNvdXJjZVBhY2siLCJCRUVUX1BBQ0tBR0UiLCJ0cyIsInBhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringTypeMap = exports.utf8String = exports.fixedSizeUtf8String = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst numbers_1 = __webpack_require__(/*! ./numbers */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\n/**\n * De/Serializes a UTF8 string of a particular size.\n *\n * @param stringByteLength the number of bytes of the string\n *\n * @category beet/collection\n */ const fixedSizeUtf8String = (stringByteLength)=>{\n    return {\n        write: function(buf, offset, value) {\n            const stringBuf = Buffer.from(value, \"utf8\");\n            assert_1.strict.equal(stringBuf.byteLength, stringByteLength, `${value} has invalid byte size`);\n            numbers_1.u32.write(buf, offset, stringByteLength);\n            stringBuf.copy(buf, offset + 4, 0, stringByteLength);\n        },\n        read: function(buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, stringByteLength, `invalid byte size`);\n            const stringSlice = buf.slice(offset + 4, offset + 4 + stringByteLength);\n            return stringSlice.toString(\"utf8\");\n        },\n        elementByteSize: 1,\n        length: stringByteLength,\n        lenPrefixByteSize: 4,\n        byteSize: 4 + stringByteLength,\n        description: `Utf8String(4 + ${stringByteLength})`\n    };\n};\nexports.fixedSizeUtf8String = fixedSizeUtf8String;\n/**\n * De/Serializes a UTF8 string of any size.\n *\n * @category beet/collection\n */ exports.utf8String = {\n    toFixedFromData (buf, offset) {\n        const len = numbers_1.u32.read(buf, offset);\n        (0, utils_1.logTrace)(`${this.description}[${len}]`);\n        return (0, exports.fixedSizeUtf8String)(len);\n    },\n    toFixedFromValue (val) {\n        const len = Buffer.from(val).byteLength;\n        return (0, exports.fixedSizeUtf8String)(len);\n    },\n    description: `Utf8String`\n};\n/**\n * Maps string beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.stringTypeMap = {\n    fixedSizeString: {\n        beet: \"fixedSizeUtf8String\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"string\",\n        arg: types_1.BEET_TYPE_ARG_LEN\n    },\n    string: {\n        beet: \"utf8String\",\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"string\"\n    }\n}; //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0Esa0JBQWtCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDaEYsTUFBTUssVUFBVUMsbUJBQU9BLENBQUMseUlBQVU7QUFDbEMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsa0pBQVc7QUFDckMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMseUlBQVU7QUFDbEM7Ozs7OztDQU1DLEdBQ0QsTUFBTUYsc0JBQXNCLENBQUNNO0lBQ3pCLE9BQU87UUFDSEMsT0FBTyxTQUFVQyxHQUFHLEVBQUVDLE1BQU0sRUFBRVosS0FBSztZQUMvQixNQUFNYSxZQUFZQyxPQUFPQyxJQUFJLENBQUNmLE9BQU87WUFDckNNLFNBQVNVLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDSixVQUFVSyxVQUFVLEVBQUVULGtCQUFrQixDQUFDLEVBQUVULE1BQU0sc0JBQXNCLENBQUM7WUFDOUZPLFVBQVVZLEdBQUcsQ0FBQ1QsS0FBSyxDQUFDQyxLQUFLQyxRQUFRSDtZQUNqQ0ksVUFBVU8sSUFBSSxDQUFDVCxLQUFLQyxTQUFTLEdBQUcsR0FBR0g7UUFDdkM7UUFDQVksTUFBTSxTQUFVVixHQUFHLEVBQUVDLE1BQU07WUFDdkIsTUFBTVUsT0FBT2YsVUFBVVksR0FBRyxDQUFDRSxJQUFJLENBQUNWLEtBQUtDO1lBQ3JDTixTQUFTVSxNQUFNLENBQUNDLEtBQUssQ0FBQ0ssTUFBTWIsa0JBQWtCLENBQUMsaUJBQWlCLENBQUM7WUFDakUsTUFBTWMsY0FBY1osSUFBSWEsS0FBSyxDQUFDWixTQUFTLEdBQUdBLFNBQVMsSUFBSUg7WUFDdkQsT0FBT2MsWUFBWUUsUUFBUSxDQUFDO1FBQ2hDO1FBQ0FDLGlCQUFpQjtRQUNqQkMsUUFBUWxCO1FBQ1JtQixtQkFBbUI7UUFDbkJDLFVBQVUsSUFBSXBCO1FBQ2RxQixhQUFhLENBQUMsZUFBZSxFQUFFckIsaUJBQWlCLENBQUMsQ0FBQztJQUN0RDtBQUNKO0FBQ0FWLDJCQUEyQixHQUFHSTtBQUM5Qjs7OztDQUlDLEdBQ0RKLGtCQUFrQixHQUFHO0lBQ2pCZ0MsaUJBQWdCcEIsR0FBRyxFQUFFQyxNQUFNO1FBQ3ZCLE1BQU1vQixNQUFNekIsVUFBVVksR0FBRyxDQUFDRSxJQUFJLENBQUNWLEtBQUtDO1FBQ25DLElBQUdKLFFBQVF5QixRQUFRLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQ0gsV0FBVyxDQUFDLENBQUMsRUFBRUUsSUFBSSxDQUFDLENBQUM7UUFDbkQsT0FBTyxDQUFDLEdBQUdqQyxRQUFRSSxtQkFBbUIsRUFBRTZCO0lBQzVDO0lBQ0FFLGtCQUFpQkMsR0FBRztRQUNoQixNQUFNSCxNQUFNbEIsT0FBT0MsSUFBSSxDQUFDb0IsS0FBS2pCLFVBQVU7UUFDdkMsT0FBTyxDQUFDLEdBQUduQixRQUFRSSxtQkFBbUIsRUFBRTZCO0lBQzVDO0lBQ0FGLGFBQWEsQ0FBQyxVQUFVLENBQUM7QUFDN0I7QUFDQTs7Ozs7O0NBTUMsR0FDRC9CLHFCQUFxQixHQUFHO0lBQ3BCcUMsaUJBQWlCO1FBQ2JDLE1BQU07UUFDTkMsV0FBVztRQUNYQyxZQUFZbkMsUUFBUW9DLFlBQVk7UUFDaENDLElBQUk7UUFDSkMsS0FBS3RDLFFBQVF1QyxpQkFBaUI7SUFDbEM7SUFDQUMsUUFBUTtRQUNKUCxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsWUFBWW5DLFFBQVFvQyxZQUFZO1FBQ2hDQyxJQUFJO0lBQ1I7QUFDSixHQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvc3RyaW5nLmpzP2NlMTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZ1R5cGVNYXAgPSBleHBvcnRzLnV0ZjhTdHJpbmcgPSBleHBvcnRzLmZpeGVkU2l6ZVV0ZjhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgbnVtYmVyc18xID0gcmVxdWlyZShcIi4vbnVtYmVyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIERlL1NlcmlhbGl6ZXMgYSBVVEY4IHN0cmluZyBvZiBhIHBhcnRpY3VsYXIgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nQnl0ZUxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb2xsZWN0aW9uXG4gKi9cbmNvbnN0IGZpeGVkU2l6ZVV0ZjhTdHJpbmcgPSAoc3RyaW5nQnl0ZUxlbmd0aCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdCdWYgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5lcXVhbChzdHJpbmdCdWYuYnl0ZUxlbmd0aCwgc3RyaW5nQnl0ZUxlbmd0aCwgYCR7dmFsdWV9IGhhcyBpbnZhbGlkIGJ5dGUgc2l6ZWApO1xuICAgICAgICAgICAgbnVtYmVyc18xLnUzMi53cml0ZShidWYsIG9mZnNldCwgc3RyaW5nQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICBzdHJpbmdCdWYuY29weShidWYsIG9mZnNldCArIDQsIDAsIHN0cmluZ0J5dGVMZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBudW1iZXJzXzEudTMyLnJlYWQoYnVmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmVxdWFsKHNpemUsIHN0cmluZ0J5dGVMZW5ndGgsIGBpbnZhbGlkIGJ5dGUgc2l6ZWApO1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2xpY2UgPSBidWYuc2xpY2Uob2Zmc2V0ICsgNCwgb2Zmc2V0ICsgNCArIHN0cmluZ0J5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NsaWNlLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVsZW1lbnRCeXRlU2l6ZTogMSxcbiAgICAgICAgbGVuZ3RoOiBzdHJpbmdCeXRlTGVuZ3RoLFxuICAgICAgICBsZW5QcmVmaXhCeXRlU2l6ZTogNCxcbiAgICAgICAgYnl0ZVNpemU6IDQgKyBzdHJpbmdCeXRlTGVuZ3RoLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFV0ZjhTdHJpbmcoNCArICR7c3RyaW5nQnl0ZUxlbmd0aH0pYCxcbiAgICB9O1xufTtcbmV4cG9ydHMuZml4ZWRTaXplVXRmOFN0cmluZyA9IGZpeGVkU2l6ZVV0ZjhTdHJpbmc7XG4vKipcbiAqIERlL1NlcmlhbGl6ZXMgYSBVVEY4IHN0cmluZyBvZiBhbnkgc2l6ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb2xsZWN0aW9uXG4gKi9cbmV4cG9ydHMudXRmOFN0cmluZyA9IHtcbiAgICB0b0ZpeGVkRnJvbURhdGEoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyc18xLnUzMi5yZWFkKGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgKDAsIHV0aWxzXzEubG9nVHJhY2UpKGAke3RoaXMuZGVzY3JpcHRpb259WyR7bGVufV1gKTtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmZpeGVkU2l6ZVV0ZjhTdHJpbmcpKGxlbik7XG4gICAgfSxcbiAgICB0b0ZpeGVkRnJvbVZhbHVlKHZhbCkge1xuICAgICAgICBjb25zdCBsZW4gPSBCdWZmZXIuZnJvbSh2YWwpLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5maXhlZFNpemVVdGY4U3RyaW5nKShsZW4pO1xuICAgIH0sXG4gICAgZGVzY3JpcHRpb246IGBVdGY4U3RyaW5nYCxcbn07XG4vKipcbiAqIE1hcHMgc3RyaW5nIGJlZXQgZXhwb3J0cyB0byBtZXRhZGF0YSB3aGljaCBkZXNjcmliZXMgaW4gd2hpY2ggcGFja2FnZSBpdFxuICogaXMgZGVmaW5lZCBhcyB3ZWxsIGFzIHdoaWNoIFR5cGVTY3JpcHQgdHlwZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAqIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBjYXRlZ29yeSBUeXBlRGVmaW5pdGlvblxuICovXG5leHBvcnRzLnN0cmluZ1R5cGVNYXAgPSB7XG4gICAgZml4ZWRTaXplU3RyaW5nOiB7XG4gICAgICAgIGJlZXQ6ICdmaXhlZFNpemVVdGY4U3RyaW5nJyxcbiAgICAgICAgaXNGaXhhYmxlOiBmYWxzZSxcbiAgICAgICAgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsXG4gICAgICAgIHRzOiAnc3RyaW5nJyxcbiAgICAgICAgYXJnOiB0eXBlc18xLkJFRVRfVFlQRV9BUkdfTEVOLFxuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICAgIGJlZXQ6ICd1dGY4U3RyaW5nJyxcbiAgICAgICAgaXNGaXhhYmxlOiB0cnVlLFxuICAgICAgICBzb3VyY2VQYWNrOiB0eXBlc18xLkJFRVRfUEFDS0FHRSxcbiAgICAgICAgdHM6ICdzdHJpbmcnLFxuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN0cmluZ1R5cGVNYXAiLCJ1dGY4U3RyaW5nIiwiZml4ZWRTaXplVXRmOFN0cmluZyIsInR5cGVzXzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJudW1iZXJzXzEiLCJ1dGlsc18xIiwic3RyaW5nQnl0ZUxlbmd0aCIsIndyaXRlIiwiYnVmIiwib2Zmc2V0Iiwic3RyaW5nQnVmIiwiQnVmZmVyIiwiZnJvbSIsInN0cmljdCIsImVxdWFsIiwiYnl0ZUxlbmd0aCIsInUzMiIsImNvcHkiLCJyZWFkIiwic2l6ZSIsInN0cmluZ1NsaWNlIiwic2xpY2UiLCJ0b1N0cmluZyIsImVsZW1lbnRCeXRlU2l6ZSIsImxlbmd0aCIsImxlblByZWZpeEJ5dGVTaXplIiwiYnl0ZVNpemUiLCJkZXNjcmlwdGlvbiIsInRvRml4ZWRGcm9tRGF0YSIsImxlbiIsImxvZ1RyYWNlIiwidG9GaXhlZEZyb21WYWx1ZSIsInZhbCIsImZpeGVkU2l6ZVN0cmluZyIsImJlZXQiLCJpc0ZpeGFibGUiLCJzb3VyY2VQYWNrIiwiQkVFVF9QQUNLQUdFIiwidHMiLCJhcmciLCJCRUVUX1RZUEVfQVJHX0xFTiIsInN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.tuplesTypeMap = exports.tuple = exports.fixedSizeTuple = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst beet_fixable_1 = __webpack_require__(/*! ../beet.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\");\n// Tuples are a special kind of composite which can be understood as\n// fixed length arrays where each tuple element can have a different data type.\n// Since the Tuple type itself dictates the length, and buffer layout, no extra\n// information is included in the serialized data.\n/**\n * De/Serializes a tuple with all fixed size tuple elements .\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n *\n * @category beet/composite\n */ function fixedSizeTuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x)=>x.description);\n    const byteSizes = elements.map((x)=>x.byteSize);\n    const byteSize = byteSizes.reduce((acc, x)=>acc + x, 0);\n    return {\n        write: function(buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);\n            let cursor = offset;\n            for(let i = 0; i < len; i++){\n                const v = value[i];\n                const beetEl = elements[i];\n                beetEl.write(buf, cursor, v);\n                cursor += beetEl.byteSize;\n            }\n        },\n        read: function(buf, offset) {\n            const els = [];\n            let cursor = offset;\n            for(let i = 0; i < len; i++){\n                const elBeet = elements[i];\n                els[i] = elBeet.read(buf, cursor);\n                cursor += elBeet.byteSize;\n            }\n            return els;\n        },\n        byteSize,\n        length: len,\n        description: `FixedSizeTuple<${elDescs.join(\",\")}>[ ${byteSizes.join(\", \")} ]`\n    };\n}\nexports.fixedSizeTuple = fixedSizeTuple;\n/**\n * De/Serializes a tuple which contains some non-fixed size tuple elements.\n *\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n * @category beet/composite\n */ function tuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x)=>x.description);\n    return {\n        toFixedFromData (buf, offset) {\n            let cursor = offset;\n            const fixedElements = new Array(len);\n            for(let i = 0; i < len; i++){\n                const fixedElement = (0, beet_fixable_1.fixBeetFromData)(elements[i], buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        toFixedFromValue (vals) {\n            (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array of tuple values`);\n            assert_1.strict.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);\n            const fixedElements = new Array(len);\n            for(let i = 0; i < vals.length; i++){\n                const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(elements[i], vals[i]);\n                fixedElements[i] = fixedElement;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        description: `Tuple<${elDescs.join(\",\")}>`\n    };\n}\nexports.tuple = tuple;\n/**\n * Maps tuples beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.tuplesTypeMap = {\n    Tuple: {\n        beet: \"tuple\",\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"[__tuple_elements__]\"\n    },\n    FixedSizeTuple: {\n        beet: \"fixedSizeTuple\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"[__tuple_elements__]\"\n    }\n}; //# sourceMappingURL=tuples.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvdHVwbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ3RFLE1BQU1LLFVBQVVDLG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsdUpBQWlCO0FBQ2hELG9FQUFvRTtBQUNwRSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLGtEQUFrRDtBQUNsRDs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNGLGVBQWVLLFFBQVE7SUFDNUIsTUFBTUMsTUFBTUQsU0FBU0UsTUFBTTtJQUMzQixNQUFNQyxVQUFVSCxTQUFTSSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsV0FBVztJQUNqRCxNQUFNQyxZQUFZUCxTQUFTSSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUcsUUFBUTtJQUNoRCxNQUFNQSxXQUFXRCxVQUFVRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0wsSUFBTUssTUFBTUwsR0FBRztJQUN2RCxPQUFPO1FBQ0hNLE9BQU8sU0FBVUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVyQixLQUFLO1lBQy9CTSxTQUFTZ0IsTUFBTSxDQUFDQyxLQUFLLENBQUN2QixNQUFNVSxNQUFNLEVBQUVELEtBQUssQ0FBQyx5QkFBeUIsRUFBRVQsTUFBTVUsTUFBTSxDQUFDLGtCQUFrQixFQUFFRCxJQUFJLENBQUM7WUFDM0csSUFBSWUsU0FBU0g7WUFDYixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSWhCLEtBQUtnQixJQUFLO2dCQUMxQixNQUFNQyxJQUFJMUIsS0FBSyxDQUFDeUIsRUFBRTtnQkFDbEIsTUFBTUUsU0FBU25CLFFBQVEsQ0FBQ2lCLEVBQUU7Z0JBQzFCRSxPQUFPUixLQUFLLENBQUNDLEtBQUtJLFFBQVFFO2dCQUMxQkYsVUFBVUcsT0FBT1gsUUFBUTtZQUM3QjtRQUNKO1FBQ0FZLE1BQU0sU0FBVVIsR0FBRyxFQUFFQyxNQUFNO1lBQ3ZCLE1BQU1RLE1BQU0sRUFBRTtZQUNkLElBQUlMLFNBQVNIO1lBQ2IsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUloQixLQUFLZ0IsSUFBSztnQkFDMUIsTUFBTUssU0FBU3RCLFFBQVEsQ0FBQ2lCLEVBQUU7Z0JBQzFCSSxHQUFHLENBQUNKLEVBQUUsR0FBR0ssT0FBT0YsSUFBSSxDQUFDUixLQUFLSTtnQkFDMUJBLFVBQVVNLE9BQU9kLFFBQVE7WUFDN0I7WUFDQSxPQUFPYTtRQUNYO1FBQ0FiO1FBQ0FOLFFBQVFEO1FBQ1JLLGFBQWEsQ0FBQyxlQUFlLEVBQUVILFFBQVFvQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUVoQixVQUFVZ0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2xGO0FBQ0o7QUFDQWhDLHNCQUFzQixHQUFHSTtBQUN6Qjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELE1BQU1NLFFBQVE7SUFDbkIsTUFBTUMsTUFBTUQsU0FBU0UsTUFBTTtJQUMzQixNQUFNQyxVQUFVSCxTQUFTSSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsV0FBVztJQUNqRCxPQUFPO1FBQ0hrQixpQkFBZ0JaLEdBQUcsRUFBRUMsTUFBTTtZQUN2QixJQUFJRyxTQUFTSDtZQUNiLE1BQU1ZLGdCQUFnQixJQUFJQyxNQUFNekI7WUFDaEMsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJaEIsS0FBS2dCLElBQUs7Z0JBQzFCLE1BQU1VLGVBQWUsQ0FBQyxHQUFHNUIsZUFBZTZCLGVBQWUsRUFBRTVCLFFBQVEsQ0FBQ2lCLEVBQUUsRUFBRUwsS0FBS0k7Z0JBQzNFUyxhQUFhLENBQUNSLEVBQUUsR0FBR1U7Z0JBQ25CWCxVQUFVVyxhQUFhbkIsUUFBUTtZQUNuQztZQUNBLE9BQU9iLGVBQWU4QjtRQUMxQjtRQUNBSSxrQkFBaUJDLElBQUk7WUFDaEIsSUFBR2hDLFNBQVNnQixNQUFNLEVBQUVZLE1BQU1LLE9BQU8sQ0FBQ0QsT0FBTyxDQUFDLEVBQUVBLEtBQUssbUNBQW1DLENBQUM7WUFDdEZoQyxTQUFTZ0IsTUFBTSxDQUFDQyxLQUFLLENBQUNlLEtBQUs1QixNQUFNLEVBQUVELEtBQUssQ0FBQyxnQkFBZ0IsRUFBRUEsSUFBSSw2QkFBNkIsRUFBRTZCLEtBQUs1QixNQUFNLENBQUMsQ0FBQztZQUMzRyxNQUFNdUIsZ0JBQWdCLElBQUlDLE1BQU16QjtZQUNoQyxJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUlhLEtBQUs1QixNQUFNLEVBQUVlLElBQUs7Z0JBQ2xDLE1BQU1VLGVBQWUsQ0FBQyxHQUFHNUIsZUFBZWlDLGdCQUFnQixFQUFFaEMsUUFBUSxDQUFDaUIsRUFBRSxFQUFFYSxJQUFJLENBQUNiLEVBQUU7Z0JBQzlFUSxhQUFhLENBQUNSLEVBQUUsR0FBR1U7WUFDdkI7WUFDQSxPQUFPaEMsZUFBZThCO1FBQzFCO1FBQ0FuQixhQUFhLENBQUMsTUFBTSxFQUFFSCxRQUFRb0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlDO0FBQ0o7QUFDQWhDLGFBQWEsR0FBR0c7QUFDaEI7Ozs7OztDQU1DLEdBQ0RILHFCQUFxQixHQUFHO0lBQ3BCMEMsT0FBTztRQUNIQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsWUFBWXhDLFFBQVF5QyxZQUFZO1FBQ2hDQyxJQUFJO0lBQ1I7SUFDQUMsZ0JBQWdCO1FBQ1pMLE1BQU07UUFDTkMsV0FBVztRQUNYQyxZQUFZeEMsUUFBUXlDLFlBQVk7UUFDaENDLElBQUk7SUFDUjtBQUNKLEdBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YXBsZXgtZm91bmRhdGlvbitiZWV0QDAuNi4xL25vZGVfbW9kdWxlcy9AbWV0YXBsZXgtZm91bmRhdGlvbi9iZWV0L2Rpc3QvY2pzL3NyYy9iZWV0cy90dXBsZXMuanM/ZWUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHVwbGVzVHlwZU1hcCA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLmZpeGVkU2l6ZVR1cGxlID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGJlZXRfZml4YWJsZV8xID0gcmVxdWlyZShcIi4uL2JlZXQuZml4YWJsZVwiKTtcbi8vIFR1cGxlcyBhcmUgYSBzcGVjaWFsIGtpbmQgb2YgY29tcG9zaXRlIHdoaWNoIGNhbiBiZSB1bmRlcnN0b29kIGFzXG4vLyBmaXhlZCBsZW5ndGggYXJyYXlzIHdoZXJlIGVhY2ggdHVwbGUgZWxlbWVudCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBkYXRhIHR5cGUuXG4vLyBTaW5jZSB0aGUgVHVwbGUgdHlwZSBpdHNlbGYgZGljdGF0ZXMgdGhlIGxlbmd0aCwgYW5kIGJ1ZmZlciBsYXlvdXQsIG5vIGV4dHJhXG4vLyBpbmZvcm1hdGlvbiBpcyBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXplZCBkYXRhLlxuLyoqXG4gKiBEZS9TZXJpYWxpemVzIGEgdHVwbGUgd2l0aCBhbGwgZml4ZWQgc2l6ZSB0dXBsZSBlbGVtZW50cyAuXG4gKiBTaW5jZSBlYWNoIHR1cGxlIGVsZW1lbnQgY2FuIGJlIG9mIGEgZGlmZmVyZW50IHR5cGUgbm90IG11Y2ggdHlwZSBzYWZldHkgY2FuXG4gKiBiZSBwcm92aWRlZCBoZXJlLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyB0aGUgRGUvU2VyaWFsaXplciBmb3IgZWFjaCB0dXBsZSBlbGVtZW50IHR5cGVcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9jb21wb3NpdGVcbiAqL1xuZnVuY3Rpb24gZml4ZWRTaXplVHVwbGUoZWxlbWVudHMpIHtcbiAgICBjb25zdCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZWxEZXNjcyA9IGVsZW1lbnRzLm1hcCgoeCkgPT4geC5kZXNjcmlwdGlvbik7XG4gICAgY29uc3QgYnl0ZVNpemVzID0gZWxlbWVudHMubWFwKCh4KSA9PiB4LmJ5dGVTaXplKTtcbiAgICBjb25zdCBieXRlU2l6ZSA9IGJ5dGVTaXplcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydF8xLnN0cmljdC5lcXVhbCh2YWx1ZS5sZW5ndGgsIGxlbiwgYHR1cGxlIHZhbHVlIGVsZW1lbnQgc2l6ZSAke3ZhbHVlLmxlbmd0aH0gc2hvdWxkIG1hdGNoIGxlbiAke2xlbn1gKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZXRFbCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGJlZXRFbC53cml0ZShidWYsIGN1cnNvciwgdik7XG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGJlZXRFbC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCBlbHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxCZWV0ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgZWxzW2ldID0gZWxCZWV0LnJlYWQoYnVmLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBlbEJlZXQuYnl0ZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxzO1xuICAgICAgICB9LFxuICAgICAgICBieXRlU2l6ZSxcbiAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgRml4ZWRTaXplVHVwbGU8JHtlbERlc2NzLmpvaW4oJywnKX0+WyAke2J5dGVTaXplcy5qb2luKCcsICcpfSBdYCxcbiAgICB9O1xufVxuZXhwb3J0cy5maXhlZFNpemVUdXBsZSA9IGZpeGVkU2l6ZVR1cGxlO1xuLyoqXG4gKiBEZS9TZXJpYWxpemVzIGEgdHVwbGUgd2hpY2ggY29udGFpbnMgc29tZSBub24tZml4ZWQgc2l6ZSB0dXBsZSBlbGVtZW50cy5cbiAqXG4gKiBTaW5jZSBlYWNoIHR1cGxlIGVsZW1lbnQgY2FuIGJlIG9mIGEgZGlmZmVyZW50IHR5cGUgbm90IG11Y2ggdHlwZSBzYWZldHkgY2FuXG4gKiBiZSBwcm92aWRlZCBoZXJlLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50cyB0aGUgRGUvU2VyaWFsaXplciBmb3IgZWFjaCB0dXBsZSBlbGVtZW50IHR5cGVcbiAqIEBjYXRlZ29yeSBiZWV0L2NvbXBvc2l0ZVxuICovXG5mdW5jdGlvbiB0dXBsZShlbGVtZW50cykge1xuICAgIGNvbnN0IGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbERlc2NzID0gZWxlbWVudHMubWFwKCh4KSA9PiB4LmRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b0ZpeGVkRnJvbURhdGEoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBmaXhlZEVsZW1lbnRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZml4ZWRFbGVtZW50ID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tRGF0YSkoZWxlbWVudHNbaV0sIGJ1ZiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBmaXhlZEVsZW1lbnRzW2ldID0gZml4ZWRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBmaXhlZEVsZW1lbnQuYnl0ZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZml4ZWRTaXplVHVwbGUoZml4ZWRFbGVtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvRml4ZWRGcm9tVmFsdWUodmFscykge1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLnN0cmljdCkoQXJyYXkuaXNBcnJheSh2YWxzKSwgYCR7dmFsc30gc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR1cGxlIHZhbHVlc2ApO1xuICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmVxdWFsKHZhbHMubGVuZ3RoLCBsZW4sIGBUaGVyZSBzaG91bGQgYmUgJHtsZW59IHR1cGxlIHZhbHVlcywgYnV0IHRoZXJlIGFyZSAke3ZhbHMubGVuZ3RofWApO1xuICAgICAgICAgICAgY29uc3QgZml4ZWRFbGVtZW50cyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZml4ZWRFbGVtZW50ID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tVmFsdWUpKGVsZW1lbnRzW2ldLCB2YWxzW2ldKTtcbiAgICAgICAgICAgICAgICBmaXhlZEVsZW1lbnRzW2ldID0gZml4ZWRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeGVkU2l6ZVR1cGxlKGZpeGVkRWxlbWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogYFR1cGxlPCR7ZWxEZXNjcy5qb2luKCcsJyl9PmAsXG4gICAgfTtcbn1cbmV4cG9ydHMudHVwbGUgPSB0dXBsZTtcbi8qKlxuICogTWFwcyB0dXBsZXMgYmVldCBleHBvcnRzIHRvIG1ldGFkYXRhIHdoaWNoIGRlc2NyaWJlcyBpbiB3aGljaCBwYWNrYWdlIGl0XG4gKiBpcyBkZWZpbmVkIGFzIHdlbGwgYXMgd2hpY2ggVHlwZVNjcmlwdCB0eXBlIGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZVxuICogZGVzZXJpYWxpemVkIHZhbHVlIGluIEphdmFTY3JpcHQuXG4gKlxuICogQGNhdGVnb3J5IFR5cGVEZWZpbml0aW9uXG4gKi9cbmV4cG9ydHMudHVwbGVzVHlwZU1hcCA9IHtcbiAgICBUdXBsZToge1xuICAgICAgICBiZWV0OiAndHVwbGUnLFxuICAgICAgICBpc0ZpeGFibGU6IHRydWUsXG4gICAgICAgIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLFxuICAgICAgICB0czogJ1tfX3R1cGxlX2VsZW1lbnRzX19dJyxcbiAgICB9LFxuICAgIEZpeGVkU2l6ZVR1cGxlOiB7XG4gICAgICAgIGJlZXQ6ICdmaXhlZFNpemVUdXBsZScsXG4gICAgICAgIGlzRml4YWJsZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVBhY2s6IHR5cGVzXzEuQkVFVF9QQUNLQUdFLFxuICAgICAgICB0czogJ1tfX3R1cGxlX2VsZW1lbnRzX19dJyxcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0dXBsZXNUeXBlTWFwIiwidHVwbGUiLCJmaXhlZFNpemVUdXBsZSIsInR5cGVzXzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJiZWV0X2ZpeGFibGVfMSIsImVsZW1lbnRzIiwibGVuIiwibGVuZ3RoIiwiZWxEZXNjcyIsIm1hcCIsIngiLCJkZXNjcmlwdGlvbiIsImJ5dGVTaXplcyIsImJ5dGVTaXplIiwicmVkdWNlIiwiYWNjIiwid3JpdGUiLCJidWYiLCJvZmZzZXQiLCJzdHJpY3QiLCJlcXVhbCIsImN1cnNvciIsImkiLCJ2IiwiYmVldEVsIiwicmVhZCIsImVscyIsImVsQmVldCIsImpvaW4iLCJ0b0ZpeGVkRnJvbURhdGEiLCJmaXhlZEVsZW1lbnRzIiwiQXJyYXkiLCJmaXhlZEVsZW1lbnQiLCJmaXhCZWV0RnJvbURhdGEiLCJ0b0ZpeGVkRnJvbVZhbHVlIiwidmFscyIsImlzQXJyYXkiLCJmaXhCZWV0RnJvbVZhbHVlIiwiVHVwbGUiLCJiZWV0IiwiaXNGaXhhYmxlIiwic291cmNlUGFjayIsIkJFRVRfUEFDS0FHRSIsInRzIiwiRml4ZWRTaXplVHVwbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.unitTypeMap = exports.unit = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\n/**\n * De/Serializer for non-values, i.e. `void`, `()`, `undefined` aka the _unit_ type .\n *\n * @category beet/primitive\n */ exports.unit = {\n    write: function(_buf, _offset, _value) {},\n    read: function(_buf, _offset) {\n        return undefined;\n    },\n    byteSize: 0,\n    description: \"unit\"\n};\n/**\n * Maps unit beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */ exports.unitTypeMap = {\n    unit: {\n        beet: \"unit\",\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: \"void\"\n    }\n}; //# sourceMappingURL=unit.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvYmVldHMvdW5pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQzFDLE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLHlJQUFVO0FBQ2xDOzs7O0NBSUMsR0FDREwsWUFBWSxHQUFHO0lBQ1hNLE9BQU8sU0FBVUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sR0FBSTtJQUMxQ0MsTUFBTSxTQUFVSCxJQUFJLEVBQUVDLE9BQU87UUFDekIsT0FBT0c7SUFDWDtJQUNBQyxVQUFVO0lBQ1ZDLGFBQWE7QUFDakI7QUFDQTs7Ozs7O0NBTUMsR0FDRGIsbUJBQW1CLEdBQUc7SUFDbEJHLE1BQU07UUFDRlcsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLFlBQVlaLFFBQVFhLFlBQVk7UUFDaENDLElBQUk7SUFDUjtBQUNKLEdBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YXBsZXgtZm91bmRhdGlvbitiZWV0QDAuNi4xL25vZGVfbW9kdWxlcy9AbWV0YXBsZXgtZm91bmRhdGlvbi9iZWV0L2Rpc3QvY2pzL3NyYy9iZWV0cy91bml0LmpzPzY5MWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaXRUeXBlTWFwID0gZXhwb3J0cy51bml0ID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbi8qKlxuICogRGUvU2VyaWFsaXplciBmb3Igbm9uLXZhbHVlcywgaS5lLiBgdm9pZGAsIGAoKWAsIGB1bmRlZmluZWRgIGFrYSB0aGUgX3VuaXRfIHR5cGUgLlxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L3ByaW1pdGl2ZVxuICovXG5leHBvcnRzLnVuaXQgPSB7XG4gICAgd3JpdGU6IGZ1bmN0aW9uIChfYnVmLCBfb2Zmc2V0LCBfdmFsdWUpIHsgfSxcbiAgICByZWFkOiBmdW5jdGlvbiAoX2J1ZiwgX29mZnNldCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZGVzY3JpcHRpb246ICd1bml0Jyxcbn07XG4vKipcbiAqIE1hcHMgdW5pdCBiZWV0IGV4cG9ydHMgdG8gbWV0YWRhdGEgd2hpY2ggZGVzY3JpYmVzIGluIHdoaWNoIHBhY2thZ2UgaXRcbiAqIGlzIGRlZmluZWQgYXMgd2VsbCBhcyB3aGljaCBUeXBlU2NyaXB0IHR5cGUgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlXG4gKiBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHlwZURlZmluaXRpb25cbiAqL1xuZXhwb3J0cy51bml0VHlwZU1hcCA9IHtcbiAgICB1bml0OiB7XG4gICAgICAgIGJlZXQ6ICd1bml0JyxcbiAgICAgICAgaXNGaXhhYmxlOiBmYWxzZSxcbiAgICAgICAgc291cmNlUGFjazogdHlwZXNfMS5CRUVUX1BBQ0tBR0UsXG4gICAgICAgIHRzOiAndm9pZCcsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVuaXRUeXBlTWFwIiwidW5pdCIsInR5cGVzXzEiLCJyZXF1aXJlIiwid3JpdGUiLCJfYnVmIiwiX29mZnNldCIsIl92YWx1ZSIsInJlYWQiLCJ1bmRlZmluZWQiLCJieXRlU2l6ZSIsImRlc2NyaXB0aW9uIiwiYmVldCIsImlzRml4YWJsZSIsInNvdXJjZVBhY2siLCJCRUVUX1BBQ0tBR0UiLCJ0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BeetReader = exports.BeetWriter = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\n/**\n * Underlying writer used to serialize structs.\n *\n * @private\n * @category beet/struct\n */ class BeetWriter {\n    constructor(byteSize){\n        this.buf = Buffer.alloc(byteSize);\n        this._offset = 0;\n    }\n    get buffer() {\n        return this.buf;\n    }\n    get offset() {\n        return this._offset;\n    }\n    maybeResize(bytesNeeded) {\n        if (this._offset + bytesNeeded > this.buf.length) {\n            assert_1.strict.fail(`We shouldn't ever need to resize, but ${this._offset + bytesNeeded} > ${this.buf.length}`);\n        // this.buf = Buffer.concat([this.buf, Buffer.alloc(this.allocateBytes)])\n        }\n    }\n    write(beet, value) {\n        this.maybeResize(beet.byteSize);\n        beet.write(this.buf, this._offset, value);\n        this._offset += beet.byteSize;\n    }\n    writeStruct(instance, fields) {\n        for (const [key, beet] of fields){\n            const value = instance[key];\n            this.write(beet, value);\n        }\n    }\n}\nexports.BeetWriter = BeetWriter;\n/**\n * Underlying reader used to deserialize structs.\n *\n * @private\n * @category beet/struct\n */ class BeetReader {\n    constructor(buffer, _offset = 0){\n        this.buffer = buffer;\n        this._offset = _offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read(beet) {\n        const value = beet.read(this.buffer, this._offset);\n        this._offset += beet.byteSize;\n        return value;\n    }\n    readStruct(fields) {\n        const acc = {};\n        for (const [key, beet] of fields){\n            acc[key] = this.read(beet);\n        }\n        return acc;\n    }\n}\nexports.BeetReader = BeetReader; //# sourceMappingURL=read-write.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvcmVhZC13cml0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDL0MsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakM7Ozs7O0NBS0MsR0FDRCxNQUFNRjtJQUNGRyxZQUFZQyxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDQyxHQUFHLEdBQUdDLE9BQU9DLEtBQUssQ0FBQ0g7UUFDeEIsSUFBSSxDQUFDSSxPQUFPLEdBQUc7SUFDbkI7SUFDQSxJQUFJQyxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNKLEdBQUc7SUFDbkI7SUFDQSxJQUFJSyxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNGLE9BQU87SUFDdkI7SUFDQUcsWUFBWUMsV0FBVyxFQUFFO1FBQ3JCLElBQUksSUFBSSxDQUFDSixPQUFPLEdBQUdJLGNBQWMsSUFBSSxDQUFDUCxHQUFHLENBQUNRLE1BQU0sRUFBRTtZQUM5Q1osU0FBU2EsTUFBTSxDQUFDQyxJQUFJLENBQUMsQ0FBQyxzQ0FBc0MsRUFBRSxJQUFJLENBQUNQLE9BQU8sR0FBR0ksWUFBWSxHQUFHLEVBQUUsSUFBSSxDQUFDUCxHQUFHLENBQUNRLE1BQU0sQ0FBQyxDQUFDO1FBQy9HLHlFQUF5RTtRQUM3RTtJQUNKO0lBQ0FHLE1BQU1DLElBQUksRUFBRW5CLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ2EsV0FBVyxDQUFDTSxLQUFLYixRQUFRO1FBQzlCYSxLQUFLRCxLQUFLLENBQUMsSUFBSSxDQUFDWCxHQUFHLEVBQUUsSUFBSSxDQUFDRyxPQUFPLEVBQUVWO1FBQ25DLElBQUksQ0FBQ1UsT0FBTyxJQUFJUyxLQUFLYixRQUFRO0lBQ2pDO0lBQ0FjLFlBQVlDLFFBQVEsRUFBRUMsTUFBTSxFQUFFO1FBQzFCLEtBQUssTUFBTSxDQUFDQyxLQUFLSixLQUFLLElBQUlHLE9BQVE7WUFDOUIsTUFBTXRCLFFBQVFxQixRQUFRLENBQUNFLElBQUk7WUFDM0IsSUFBSSxDQUFDTCxLQUFLLENBQUNDLE1BQU1uQjtRQUNyQjtJQUNKO0FBQ0o7QUFDQUQsa0JBQWtCLEdBQUdHO0FBQ3JCOzs7OztDQUtDLEdBQ0QsTUFBTUQ7SUFDRkksWUFBWU0sTUFBTSxFQUFFRCxVQUFVLENBQUMsQ0FBRTtRQUM3QixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDbkI7SUFDQSxJQUFJRSxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNGLE9BQU87SUFDdkI7SUFDQWMsS0FBS0wsSUFBSSxFQUFFO1FBQ1AsTUFBTW5CLFFBQVFtQixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDYixNQUFNLEVBQUUsSUFBSSxDQUFDRCxPQUFPO1FBQ2pELElBQUksQ0FBQ0EsT0FBTyxJQUFJUyxLQUFLYixRQUFRO1FBQzdCLE9BQU9OO0lBQ1g7SUFDQXlCLFdBQVdILE1BQU0sRUFBRTtRQUNmLE1BQU1JLE1BQU0sQ0FBQztRQUNiLEtBQUssTUFBTSxDQUFDSCxLQUFLSixLQUFLLElBQUlHLE9BQVE7WUFDOUJJLEdBQUcsQ0FBQ0gsSUFBSSxHQUFHLElBQUksQ0FBQ0MsSUFBSSxDQUFDTDtRQUN6QjtRQUNBLE9BQU9PO0lBQ1g7QUFDSjtBQUNBM0Isa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvcmVhZC13cml0ZS5qcz9mODEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWV0UmVhZGVyID0gZXhwb3J0cy5CZWV0V3JpdGVyID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuLyoqXG4gKiBVbmRlcmx5aW5nIHdyaXRlciB1c2VkIHRvIHNlcmlhbGl6ZSBzdHJ1Y3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgYmVldC9zdHJ1Y3RcbiAqL1xuY2xhc3MgQmVldFdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZVNpemUpIHtcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2MoYnl0ZVNpemUpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIH1cbiAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWY7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuICAgIG1heWJlUmVzaXplKGJ5dGVzTmVlZGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgKyBieXRlc05lZWRlZCA+IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgYXNzZXJ0XzEuc3RyaWN0LmZhaWwoYFdlIHNob3VsZG4ndCBldmVyIG5lZWQgdG8gcmVzaXplLCBidXQgJHt0aGlzLl9vZmZzZXQgKyBieXRlc05lZWRlZH0gPiAke3RoaXMuYnVmLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWYsIEJ1ZmZlci5hbGxvYyh0aGlzLmFsbG9jYXRlQnl0ZXMpXSlcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZShiZWV0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKGJlZXQuYnl0ZVNpemUpO1xuICAgICAgICBiZWV0LndyaXRlKHRoaXMuYnVmLCB0aGlzLl9vZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IGJlZXQuYnl0ZVNpemU7XG4gICAgfVxuICAgIHdyaXRlU3RydWN0KGluc3RhbmNlLCBmaWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBiZWV0XSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoYmVldCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CZWV0V3JpdGVyID0gQmVldFdyaXRlcjtcbi8qKlxuICogVW5kZXJseWluZyByZWFkZXIgdXNlZCB0byBkZXNlcmlhbGl6ZSBzdHJ1Y3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgYmVldC9zdHJ1Y3RcbiAqL1xuY2xhc3MgQmVldFJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBfb2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gX29mZnNldDtcbiAgICB9XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgcmVhZChiZWV0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYmVldC5yZWFkKHRoaXMuYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gYmVldC5ieXRlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkU3RydWN0KGZpZWxkcykge1xuICAgICAgICBjb25zdCBhY2MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBiZWV0XSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdGhpcy5yZWFkKGJlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxufVxuZXhwb3J0cy5CZWV0UmVhZGVyID0gQmVldFJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWQtd3JpdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmVldFJlYWRlciIsIkJlZXRXcml0ZXIiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJjb25zdHJ1Y3RvciIsImJ5dGVTaXplIiwiYnVmIiwiQnVmZmVyIiwiYWxsb2MiLCJfb2Zmc2V0IiwiYnVmZmVyIiwib2Zmc2V0IiwibWF5YmVSZXNpemUiLCJieXRlc05lZWRlZCIsImxlbmd0aCIsInN0cmljdCIsImZhaWwiLCJ3cml0ZSIsImJlZXQiLCJ3cml0ZVN0cnVjdCIsImluc3RhbmNlIiwiZmllbGRzIiwia2V5IiwicmVhZCIsInJlYWRTdHJ1Y3QiLCJhY2MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FixableBeetArgsStruct = exports.isFixableBeetStruct = exports.FixableBeetStruct = void 0;\nconst beet_fixable_1 = __webpack_require__(/*! ./beet.fixable */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js\");\nconst struct_1 = __webpack_require__(/*! ./struct */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\nconst ansicolors_1 = __importDefault(__webpack_require__(/*! ansicolors */ \"(ssr)/./node_modules/.pnpm/ansicolors@0.3.2/node_modules/ansicolors/ansicolors.js\"));\nconst { brightBlack } = ansicolors_1.default;\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. Not all fields of that class have to be of fixed size.\n * If none of the fields requires a {@link FixableBeet} use the {@link BeetStruct} instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */ class FixableBeetStruct {\n    /**\n     * Creates an instance of the {@link FixableBeetStruct}.\n     *\n     * @param fields fixed or fixable de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */ constructor(fields, construct, description = FixableBeetStruct.description){\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        let minByteSize = 0;\n        if (utils_1.logDebug.enabled) {\n            const flds = fields.map(([key, val])=>{\n                if ((0, types_1.isFixedSizeBeet)(val)) {\n                    minByteSize += val.byteSize;\n                }\n                return `${key}: ${val.description} ${(0, utils_1.beetBytes)(val)}`;\n            }).join(\"\\n  \");\n            const bytes = `> ${minByteSize} B`;\n            (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${brightBlack(bytes)}`);\n        }\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */ deserialize(buffer, offset = 0) {\n        return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * **NOTE:** that the `instance` is traversed and each of its fields accessed\n     * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to\n     * serialize the `instance`.\n     * Therefore ensure that none of the properties that are part of the struct\n     * have side effects, i.e. via `Getter`s.\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */ serialize(instance, byteSize) {\n        return this.toFixedFromValue(instance).serialize(instance, byteSize);\n    }\n    toFixedFromData(buf, offset) {\n        let cursor = offset;\n        const fixedFields = new Array(this.fields.length);\n        for(let i = 0; i < this.fields.length; i++){\n            const [key, beet] = this.fields[i];\n            const fixedBeet = (0, beet_fixable_1.fixBeetFromData)(beet, buf, cursor);\n            fixedFields[i] = [\n                key,\n                fixedBeet\n            ];\n            cursor += fixedBeet.byteSize;\n        }\n        return this.description !== FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);\n    }\n    toFixedFromValue(args) {\n        const argsKeys = Object.keys(args);\n        const fixedFields = new Array(this.fields.length);\n        for(let i = 0; i < this.fields.length; i++){\n            const [key, beet] = this.fields[i];\n            (0, assert_1.strict)(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);\n            const val = args[key];\n            const fixedBeet = (0, beet_fixable_1.fixBeetFromValue)(beet, val);\n            fixedFields[i] = [\n                key,\n                fixedBeet\n            ];\n        }\n        return this.description !== FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);\n    }\n    get type() {\n        return FixableBeetStruct.TYPE;\n    }\n}\nexports.FixableBeetStruct = FixableBeetStruct;\nFixableBeetStruct.description = \"FixableBeetStruct\";\nFixableBeetStruct.TYPE = \"FixableBeetStruct\";\nfunction isFixableBeetStruct(beet) {\n    return beet.type === FixableBeetStruct.TYPE;\n}\nexports.isFixableBeetStruct = isFixableBeetStruct;\n/**\n * Convenience wrapper around {@link FixableBeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */ class FixableBeetArgsStruct extends FixableBeetStruct {\n    constructor(fields, description = FixableBeetArgsStruct.description){\n        super(fields, (args)=>args, description);\n    }\n}\nexports.FixableBeetArgsStruct = FixableBeetArgsStruct;\nFixableBeetArgsStruct.description = \"FixableBeetArgsStruct\"; //# sourceMappingURL=struct.fixable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvc3RydWN0LmZpeGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMvRixNQUFNSyxpQkFBaUJDLG1CQUFPQSxDQUFDLHNKQUFnQjtBQUMvQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywwSUFBVTtBQUNuQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyx3SUFBUztBQUNqQyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyx3SUFBUztBQUNqQyxNQUFNSyxlQUFlaEIsZ0JBQWdCVyxtQkFBT0EsQ0FBQyxxR0FBWTtBQUN6RCxNQUFNLEVBQUVNLFdBQVcsRUFBRSxHQUFHRCxhQUFhRSxPQUFPO0FBQzVDOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNVDtJQUNGOzs7Ozs7OztLQVFDLEdBQ0RVLFlBQVlDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxjQUFjYixrQkFBa0JhLFdBQVcsQ0FBRTtRQUN4RSxJQUFJLENBQUNGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUlDLGNBQWM7UUFDbEIsSUFBSVIsUUFBUVMsUUFBUSxDQUFDQyxPQUFPLEVBQUU7WUFDMUIsTUFBTUMsT0FBT04sT0FDUk8sR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS0MsSUFBSTtnQkFDaEIsSUFBSSxDQUFDLEdBQUdoQixRQUFRaUIsZUFBZSxFQUFFRCxNQUFNO29CQUNuQ04sZUFBZU0sSUFBSUUsUUFBUTtnQkFDL0I7Z0JBQ0EsT0FBTyxDQUFDLEVBQUVILElBQUksRUFBRSxFQUFFQyxJQUFJUCxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBR1AsUUFBUWlCLFNBQVMsRUFBRUgsS0FBSyxDQUFDO1lBQ3RFLEdBQ0tJLElBQUksQ0FBQztZQUNWLE1BQU1DLFFBQVEsQ0FBQyxFQUFFLEVBQUVYLFlBQVksRUFBRSxDQUFDO1lBQ2pDLElBQUdSLFFBQVFTLFFBQVEsRUFBRSxDQUFDLE9BQU8sRUFBRUYsWUFBWSxNQUFNLEVBQUVJLEtBQUssSUFBSSxFQUFFVCxZQUFZaUIsT0FBTyxDQUFDO1FBQ3ZGO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUNGLFFBQVFDLFFBQVFGLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDcEU7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREUsVUFBVUMsUUFBUSxFQUFFVCxRQUFRLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNVLGdCQUFnQixDQUFDRCxVQUFVRCxTQUFTLENBQUNDLFVBQVVUO0lBQy9EO0lBQ0FPLGdCQUFnQkksR0FBRyxFQUFFTCxNQUFNLEVBQUU7UUFDekIsSUFBSU0sU0FBU047UUFDYixNQUFNTyxjQUFjLElBQUlDLE1BQU0sSUFBSSxDQUFDekIsTUFBTSxDQUFDMEIsTUFBTTtRQUNoRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMzQixNQUFNLENBQUMwQixNQUFNLEVBQUVDLElBQUs7WUFDekMsTUFBTSxDQUFDbkIsS0FBS29CLEtBQUssR0FBRyxJQUFJLENBQUM1QixNQUFNLENBQUMyQixFQUFFO1lBQ2xDLE1BQU1FLFlBQVksQ0FBQyxHQUFHdkMsZUFBZXdDLGVBQWUsRUFBRUYsTUFBTU4sS0FBS0M7WUFDakVDLFdBQVcsQ0FBQ0csRUFBRSxHQUFHO2dCQUFDbkI7Z0JBQUtxQjthQUFVO1lBQ2pDTixVQUFVTSxVQUFVbEIsUUFBUTtRQUNoQztRQUNBLE9BQU8sSUFBSSxDQUFDVCxXQUFXLEtBQUtiLGtCQUFrQmEsV0FBVyxHQUNuRCxJQUFJVixTQUFTdUMsVUFBVSxDQUFDUCxhQUFhLElBQUksQ0FBQ3ZCLFNBQVMsRUFBRSxJQUFJLENBQUNDLFdBQVcsSUFDckUsSUFBSVYsU0FBU3VDLFVBQVUsQ0FBQ1AsYUFBYSxJQUFJLENBQUN2QixTQUFTO0lBQzdEO0lBQ0FvQixpQkFBaUJXLElBQUksRUFBRTtRQUNuQixNQUFNQyxXQUFXbEQsT0FBT21ELElBQUksQ0FBQ0Y7UUFDN0IsTUFBTVIsY0FBYyxJQUFJQyxNQUFNLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQzBCLE1BQU07UUFDaEQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDM0IsTUFBTSxDQUFDMEIsTUFBTSxFQUFFQyxJQUFLO1lBQ3pDLE1BQU0sQ0FBQ25CLEtBQUtvQixLQUFLLEdBQUcsSUFBSSxDQUFDNUIsTUFBTSxDQUFDMkIsRUFBRTtZQUNqQyxJQUFHakMsU0FBU3lDLE1BQU0sRUFBRUYsU0FBU0csUUFBUSxDQUFDNUIsTUFBTSxDQUFDLGtCQUFrQixFQUFFeUIsU0FBUyw4QkFBOEIsRUFBRXpCLElBQUksY0FBYyxDQUFDO1lBQzlILE1BQU1DLE1BQU11QixJQUFJLENBQUN4QixJQUFJO1lBQ3JCLE1BQU1xQixZQUFZLENBQUMsR0FBR3ZDLGVBQWUrQyxnQkFBZ0IsRUFBRVQsTUFBTW5CO1lBQzdEZSxXQUFXLENBQUNHLEVBQUUsR0FBRztnQkFBQ25CO2dCQUFLcUI7YUFBVTtRQUNyQztRQUNBLE9BQU8sSUFBSSxDQUFDM0IsV0FBVyxLQUFLYixrQkFBa0JhLFdBQVcsR0FDbkQsSUFBSVYsU0FBU3VDLFVBQVUsQ0FBQ1AsYUFBYSxJQUFJLENBQUN2QixTQUFTLEVBQUUsSUFBSSxDQUFDQyxXQUFXLElBQ3JFLElBQUlWLFNBQVN1QyxVQUFVLENBQUNQLGFBQWEsSUFBSSxDQUFDdkIsU0FBUztJQUM3RDtJQUNBLElBQUlxQyxPQUFPO1FBQ1AsT0FBT2pELGtCQUFrQmtELElBQUk7SUFDakM7QUFDSjtBQUNBdEQseUJBQXlCLEdBQUdJO0FBQzVCQSxrQkFBa0JhLFdBQVcsR0FBRztBQUNoQ2Isa0JBQWtCa0QsSUFBSSxHQUFHO0FBQ3pCLFNBQVNuRCxvQkFBb0J3QyxJQUFJO0lBQzdCLE9BQU9BLEtBQUtVLElBQUksS0FBS2pELGtCQUFrQmtELElBQUk7QUFDL0M7QUFDQXRELDJCQUEyQixHQUFHRztBQUM5Qjs7Ozs7Q0FLQyxHQUNELE1BQU1ELDhCQUE4QkU7SUFDaENVLFlBQVlDLE1BQU0sRUFBRUUsY0FBY2Ysc0JBQXNCZSxXQUFXLENBQUU7UUFDakUsS0FBSyxDQUFDRixRQUFRLENBQUNnQyxPQUFTQSxNQUFNOUI7SUFDbEM7QUFDSjtBQUNBakIsNkJBQTZCLEdBQUdFO0FBQ2hDQSxzQkFBc0JlLFdBQVcsR0FBRyx5QkFDcEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YXBsZXgtZm91bmRhdGlvbitiZWV0QDAuNi4xL25vZGVfbW9kdWxlcy9AbWV0YXBsZXgtZm91bmRhdGlvbi9iZWV0L2Rpc3QvY2pzL3NyYy9zdHJ1Y3QuZml4YWJsZS5qcz9mNzIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaXhhYmxlQmVldEFyZ3NTdHJ1Y3QgPSBleHBvcnRzLmlzRml4YWJsZUJlZXRTdHJ1Y3QgPSBleHBvcnRzLkZpeGFibGVCZWV0U3RydWN0ID0gdm9pZCAwO1xuY29uc3QgYmVldF9maXhhYmxlXzEgPSByZXF1aXJlKFwiLi9iZWV0LmZpeGFibGVcIik7XG5jb25zdCBzdHJ1Y3RfMSA9IHJlcXVpcmUoXCIuL3N0cnVjdFwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGFuc2ljb2xvcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zaWNvbG9yc1wiKSk7XG5jb25zdCB7IGJyaWdodEJsYWNrIH0gPSBhbnNpY29sb3JzXzEuZGVmYXVsdDtcbi8qKlxuICogQ29uZmlndXJlcyBhIGNsYXNzIG9yIGFueSBKYXZhU2NyaXB0IG9iamVjdCB0eXBlIGZvciBkZS9zZXJpYWxpemF0aW9uIGFrYVxuICogcmVhZC93cml0ZS4gTm90IGFsbCBmaWVsZHMgb2YgdGhhdCBjbGFzcyBoYXZlIHRvIGJlIG9mIGZpeGVkIHNpemUuXG4gKiBJZiBub25lIG9mIHRoZSBmaWVsZHMgcmVxdWlyZXMgYSB7QGxpbmsgRml4YWJsZUJlZXR9IHVzZSB0aGUge0BsaW5rIEJlZXRTdHJ1Y3R9IGluc3RlYWQuXG4gKlxuICogQHRlbXBsYXRlIENsYXNzIHRoZSB0eXBlIHRvIHByb2R1Y2Ugd2hlbiBkZXNlcmlhbGl6aW5nXG4gKiBAdGVtcGxhdGUgQXJncyBjb250YWlucyBhbGwgZmllbGRzLCBpcyB0eXBpY2FsbHkgYSBzdWJzZXQgb2YgQ2xhc3MgYW5kIGlzXG4gKiB1c2VkIHRvIGNvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiBpdFxuICpcbiAqIEBjYXRlZ29yeSBiZWV0L3N0cnVjdFxuICovXG5jbGFzcyBGaXhhYmxlQmVldFN0cnVjdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEZpeGFibGVCZWV0U3RydWN0fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZHMgZml4ZWQgb3IgZml4YWJsZSBkZS9zZXJpYWxpemVycyBmb3IgZWFjaCBmaWVsZCBvZiB0aGUge0BsaW5rIENsYXNzfVxuICAgICAqIEBwYXJhbSBjb25zdHJ1Y3QgdGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgQ2xhc3N9XG4gICAgICogZnJvbSB0aGUgYXJnc1xuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBpZGVudGlmaWVzIHRoaXMgc3RydWN0IGZvciBkaWFnbm9zdGljcy9kZWJ1Z2dpbmdcbiAgICAgKiBwdXJwb3Nlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY29uc3RydWN0LCBkZXNjcmlwdGlvbiA9IEZpeGFibGVCZWV0U3RydWN0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdCA9IGNvbnN0cnVjdDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICBsZXQgbWluQnl0ZVNpemUgPSAwO1xuICAgICAgICBpZiAodXRpbHNfMS5sb2dEZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBmbGRzID0gZmllbGRzXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdHlwZXNfMS5pc0ZpeGVkU2l6ZUJlZXQpKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQnl0ZVNpemUgKz0gdmFsLmJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7a2V5fTogJHt2YWwuZGVzY3JpcHRpb259ICR7KDAsIHV0aWxzXzEuYmVldEJ5dGVzKSh2YWwpfWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4gICcpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBgPiAke21pbkJ5dGVTaXplfSBCYDtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmxvZ0RlYnVnKShgc3RydWN0ICR7ZGVzY3JpcHRpb259IHtcXG4gICR7Zmxkc31cXG59ICR7YnJpZ2h0QmxhY2soYnl0ZXMpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhbiBpbnN0YW5jZSBvZiB0aGUgQ2xhc3MgZnJvbSB0aGUgcHJvdmlkZWQgYnVmZmVyIHN0YXJ0aW5nIHRvXG4gICAgICogcmVhZCBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYFtpbnN0YW5jZSBvZiBDbGFzcywgb2Zmc2V0IGludG8gYnVmZmVyIGFmdGVyIGRlc2VyaWFsaXphdGlvbiBjb21wbGV0ZWRdYFxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0ZpeGVkRnJvbURhdGEoYnVmZmVyLCBvZmZzZXQpLmRlc2VyaWFsaXplKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgaW50byBhIG5ldyB7QGxpbmsgQnVmZmVyfVxuICAgICAqXG4gICAgICogKipOT1RFOioqIHRoYXQgdGhlIGBpbnN0YW5jZWAgaXMgdHJhdmVyc2VkIGFuZCBlYWNoIG9mIGl0cyBmaWVsZHMgYWNjZXNzZWRcbiAgICAgKiB0d2ljZSwgb25jZSB0byBkZXJpdmUgYSBfZml4ZWQgc2l6ZV8ge0BsaW5rIEJlZXRTdHJ1Y3R9IGFuZCB0aGVuIHVzZSBpdCB0b1xuICAgICAqIHNlcmlhbGl6ZSB0aGUgYGluc3RhbmNlYC5cbiAgICAgKiBUaGVyZWZvcmUgZW5zdXJlIHRoYXQgbm9uZSBvZiB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBzdHJ1Y3RcbiAgICAgKiBoYXZlIHNpZGUgZWZmZWN0cywgaS5lLiB2aWEgYEdldHRlcmBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluc3RhbmNlIG9mIHRoZSBzdHJ1Y3QgdG8gc2VyaWFsaXplXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIGFsbG93cyB0byBvdmVycmlkZSB0aGUgc2l6ZSBmbyB0aGUgY3JlYXRlZCBCdWZmZXIgYW5kXG4gICAgICogZGVmYXVsdHMgdG8gdGhlIHNpemUgb2YgdGhlIHN0cnVjdCB0byBzZXJpYWxpemVcbiAgICAgKi9cbiAgICBzZXJpYWxpemUoaW5zdGFuY2UsIGJ5dGVTaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRml4ZWRGcm9tVmFsdWUoaW5zdGFuY2UpLnNlcmlhbGl6ZShpbnN0YW5jZSwgYnl0ZVNpemUpO1xuICAgIH1cbiAgICB0b0ZpeGVkRnJvbURhdGEoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgZml4ZWRGaWVsZHMgPSBuZXcgQXJyYXkodGhpcy5maWVsZHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgYmVldF0gPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGZpeGVkQmVldCA9ICgwLCBiZWV0X2ZpeGFibGVfMS5maXhCZWV0RnJvbURhdGEpKGJlZXQsIGJ1ZiwgY3Vyc29yKTtcbiAgICAgICAgICAgIGZpeGVkRmllbGRzW2ldID0gW2tleSwgZml4ZWRCZWV0XTtcbiAgICAgICAgICAgIGN1cnNvciArPSBmaXhlZEJlZXQuYnl0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb24gIT09IEZpeGFibGVCZWV0U3RydWN0LmRlc2NyaXB0aW9uXG4gICAgICAgICAgICA/IG5ldyBzdHJ1Y3RfMS5CZWV0U3RydWN0KGZpeGVkRmllbGRzLCB0aGlzLmNvbnN0cnVjdCwgdGhpcy5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgIDogbmV3IHN0cnVjdF8xLkJlZXRTdHJ1Y3QoZml4ZWRGaWVsZHMsIHRoaXMuY29uc3RydWN0KTtcbiAgICB9XG4gICAgdG9GaXhlZEZyb21WYWx1ZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3NLZXlzID0gT2JqZWN0LmtleXMoYXJncyk7XG4gICAgICAgIGNvbnN0IGZpeGVkRmllbGRzID0gbmV3IEFycmF5KHRoaXMuZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIGJlZXRdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuc3RyaWN0KShhcmdzS2V5cy5pbmNsdWRlcyhrZXkpLCBgVmFsdWUgd2l0aCBrZXlzIFsgJHthcmdzS2V5c30gXSBzaG91bGQgaW5jbHVkZSBzdHJ1Y3Qga2V5ICcke2tleX0nIGJ1dCBkb2Vzbid0LmApO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gYXJnc1trZXldO1xuICAgICAgICAgICAgY29uc3QgZml4ZWRCZWV0ID0gKDAsIGJlZXRfZml4YWJsZV8xLmZpeEJlZXRGcm9tVmFsdWUpKGJlZXQsIHZhbCk7XG4gICAgICAgICAgICBmaXhlZEZpZWxkc1tpXSA9IFtrZXksIGZpeGVkQmVldF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb24gIT09IEZpeGFibGVCZWV0U3RydWN0LmRlc2NyaXB0aW9uXG4gICAgICAgICAgICA/IG5ldyBzdHJ1Y3RfMS5CZWV0U3RydWN0KGZpeGVkRmllbGRzLCB0aGlzLmNvbnN0cnVjdCwgdGhpcy5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgIDogbmV3IHN0cnVjdF8xLkJlZXRTdHJ1Y3QoZml4ZWRGaWVsZHMsIHRoaXMuY29uc3RydWN0KTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGaXhhYmxlQmVldFN0cnVjdC5UWVBFO1xuICAgIH1cbn1cbmV4cG9ydHMuRml4YWJsZUJlZXRTdHJ1Y3QgPSBGaXhhYmxlQmVldFN0cnVjdDtcbkZpeGFibGVCZWV0U3RydWN0LmRlc2NyaXB0aW9uID0gJ0ZpeGFibGVCZWV0U3RydWN0JztcbkZpeGFibGVCZWV0U3RydWN0LlRZUEUgPSAnRml4YWJsZUJlZXRTdHJ1Y3QnO1xuZnVuY3Rpb24gaXNGaXhhYmxlQmVldFN0cnVjdChiZWV0KSB7XG4gICAgcmV0dXJuIGJlZXQudHlwZSA9PT0gRml4YWJsZUJlZXRTdHJ1Y3QuVFlQRTtcbn1cbmV4cG9ydHMuaXNGaXhhYmxlQmVldFN0cnVjdCA9IGlzRml4YWJsZUJlZXRTdHJ1Y3Q7XG4vKipcbiAqIENvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIHtAbGluayBGaXhhYmxlQmVldFN0cnVjdH0gd2hpY2ggaXMgdXNlZCBmb3IgcGxhaW4gSmF2YXNTY3JpcHRcbiAqIG9iamVjdHMsIGxpa2UgYXJlIHVzZWQgZm9yIG9wdGlvbiBhcmdzIHBhc3NlZCB0byBmdW5jdGlvbnMuXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvc3RydWN0XG4gKi9cbmNsYXNzIEZpeGFibGVCZWV0QXJnc1N0cnVjdCBleHRlbmRzIEZpeGFibGVCZWV0U3RydWN0IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGRlc2NyaXB0aW9uID0gRml4YWJsZUJlZXRBcmdzU3RydWN0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgKGFyZ3MpID0+IGFyZ3MsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkZpeGFibGVCZWV0QXJnc1N0cnVjdCA9IEZpeGFibGVCZWV0QXJnc1N0cnVjdDtcbkZpeGFibGVCZWV0QXJnc1N0cnVjdC5kZXNjcmlwdGlvbiA9ICdGaXhhYmxlQmVldEFyZ3NTdHJ1Y3QnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RydWN0LmZpeGFibGUuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpeGFibGVCZWV0QXJnc1N0cnVjdCIsImlzRml4YWJsZUJlZXRTdHJ1Y3QiLCJGaXhhYmxlQmVldFN0cnVjdCIsImJlZXRfZml4YWJsZV8xIiwicmVxdWlyZSIsInN0cnVjdF8xIiwidHlwZXNfMSIsImFzc2VydF8xIiwidXRpbHNfMSIsImFuc2ljb2xvcnNfMSIsImJyaWdodEJsYWNrIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwiZmllbGRzIiwiY29uc3RydWN0IiwiZGVzY3JpcHRpb24iLCJtaW5CeXRlU2l6ZSIsImxvZ0RlYnVnIiwiZW5hYmxlZCIsImZsZHMiLCJtYXAiLCJrZXkiLCJ2YWwiLCJpc0ZpeGVkU2l6ZUJlZXQiLCJieXRlU2l6ZSIsImJlZXRCeXRlcyIsImpvaW4iLCJieXRlcyIsImRlc2VyaWFsaXplIiwiYnVmZmVyIiwib2Zmc2V0IiwidG9GaXhlZEZyb21EYXRhIiwic2VyaWFsaXplIiwiaW5zdGFuY2UiLCJ0b0ZpeGVkRnJvbVZhbHVlIiwiYnVmIiwiY3Vyc29yIiwiZml4ZWRGaWVsZHMiLCJBcnJheSIsImxlbmd0aCIsImkiLCJiZWV0IiwiZml4ZWRCZWV0IiwiZml4QmVldEZyb21EYXRhIiwiQmVldFN0cnVjdCIsImFyZ3MiLCJhcmdzS2V5cyIsImtleXMiLCJzdHJpY3QiLCJpbmNsdWRlcyIsImZpeEJlZXRGcm9tVmFsdWUiLCJ0eXBlIiwiVFlQRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BeetArgsStruct = exports.isBeetStruct = exports.BeetStruct = void 0;\nconst read_write_1 = __webpack_require__(/*! ./read-write */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\");\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */ class BeetStruct {\n    /**\n     * Creates an instance of the BeetStruct.\n     *\n     * @param fields de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */ constructor(fields, construct, description = BeetStruct.description){\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        this.byteSize = this.getByteSize();\n        if (utils_1.logDebug.enabled) {\n            const flds = fields.map(([key, val])=>`${String(key)}: ${val.description} ${(0, utils_1.beetBytes)(val)}`).join(\"\\n  \");\n            (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${(0, utils_1.beetBytes)(this)}`);\n        }\n    }\n    /**\n     * Along with `write` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */ read(buf, offset) {\n        const [value] = this.deserialize(buf, offset);\n        return value;\n    }\n    /**\n     * Along with `read` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */ write(buf, offset, value) {\n        const [innerBuf, innerOffset] = this.serialize(value);\n        innerBuf.copy(buf, offset, 0, innerOffset);\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */ deserialize(buffer, offset = 0) {\n        if (utils_1.logTrace.enabled) {\n            (0, utils_1.logTrace)(\"deserializing [%s] from %d bytes buffer\", this.description, buffer.byteLength);\n            (0, utils_1.logTrace)(buffer);\n            (0, utils_1.logTrace)(buffer.toJSON().data);\n        }\n        const reader = new read_write_1.BeetReader(buffer, offset);\n        const args = reader.readStruct(this.fields);\n        return [\n            this.construct(args),\n            reader.offset\n        ];\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */ serialize(instance, byteSize = this.byteSize) {\n        (0, utils_1.logTrace)(\"serializing [%s] %o to %d bytes buffer\", this.description, instance, byteSize);\n        const writer = new read_write_1.BeetWriter(byteSize);\n        writer.writeStruct(instance, this.fields);\n        return [\n            writer.buffer,\n            writer.offset\n        ];\n    }\n    getByteSize() {\n        return this.fields.reduce((acc, [_, beet])=>acc + beet.byteSize, 0);\n    }\n    get type() {\n        return BeetStruct.TYPE;\n    }\n}\nexports.BeetStruct = BeetStruct;\nBeetStruct.description = \"BeetStruct\";\nBeetStruct.TYPE = \"BeetStruct\";\nfunction isBeetStruct(beet) {\n    return beet.type === BeetStruct.TYPE;\n}\nexports.isBeetStruct = isBeetStruct;\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */ class BeetArgsStruct extends BeetStruct {\n    constructor(fields, description = BeetArgsStruct.description){\n        super(fields, (args)=>args, description);\n    }\n}\nexports.BeetArgsStruct = BeetArgsStruct;\nBeetArgsStruct.description = \"BeetArgsStruct\"; //# sourceMappingURL=struct.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvc3RydWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDMUUsTUFBTUssZUFBZUMsbUJBQU9BLENBQUMsa0pBQWM7QUFDM0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsd0lBQVM7QUFDakM7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNRjtJQUNGOzs7Ozs7OztLQVFDLEdBQ0RJLFlBQVlDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxjQUFjUCxXQUFXTyxXQUFXLENBQUU7UUFDakUsSUFBSSxDQUFDRixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNDLFdBQVc7UUFDaEMsSUFBSU4sUUFBUU8sUUFBUSxDQUFDQyxPQUFPLEVBQUU7WUFDMUIsTUFBTUMsT0FBT1AsT0FDUlEsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS0MsSUFBSSxHQUFLLENBQUMsRUFBRUMsT0FBT0YsS0FBSyxFQUFFLEVBQUVDLElBQUlSLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHSixRQUFRYyxTQUFTLEVBQUVGLEtBQUssQ0FBQyxFQUN2RkcsSUFBSSxDQUFDO1lBQ1QsSUFBR2YsUUFBUU8sUUFBUSxFQUFFLENBQUMsT0FBTyxFQUFFSCxZQUFZLE1BQU0sRUFBRUssS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHVCxRQUFRYyxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDakc7SUFDSjtJQUNBOzs7O0tBSUMsR0FDREUsS0FBS0MsR0FBRyxFQUFFQyxNQUFNLEVBQUU7UUFDZCxNQUFNLENBQUN4QixNQUFNLEdBQUcsSUFBSSxDQUFDeUIsV0FBVyxDQUFDRixLQUFLQztRQUN0QyxPQUFPeEI7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRDBCLE1BQU1ILEdBQUcsRUFBRUMsTUFBTSxFQUFFeEIsS0FBSyxFQUFFO1FBQ3RCLE1BQU0sQ0FBQzJCLFVBQVVDLFlBQVksR0FBRyxJQUFJLENBQUNDLFNBQVMsQ0FBQzdCO1FBQy9DMkIsU0FBU0csSUFBSSxDQUFDUCxLQUFLQyxRQUFRLEdBQUdJO0lBQ2xDO0lBQ0E7Ozs7O0tBS0MsR0FDREgsWUFBWU0sTUFBTSxFQUFFUCxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFJbEIsUUFBUTBCLFFBQVEsQ0FBQ2xCLE9BQU8sRUFBRTtZQUN6QixJQUFHUixRQUFRMEIsUUFBUSxFQUFFLDJDQUEyQyxJQUFJLENBQUN0QixXQUFXLEVBQUVxQixPQUFPRSxVQUFVO1lBQ25HLElBQUczQixRQUFRMEIsUUFBUSxFQUFFRDtZQUNyQixJQUFHekIsUUFBUTBCLFFBQVEsRUFBRUQsT0FBT0csTUFBTSxHQUFHQyxJQUFJO1FBQzlDO1FBQ0EsTUFBTUMsU0FBUyxJQUFJaEMsYUFBYWlDLFVBQVUsQ0FBQ04sUUFBUVA7UUFDbkQsTUFBTWMsT0FBT0YsT0FBT0csVUFBVSxDQUFDLElBQUksQ0FBQy9CLE1BQU07UUFDMUMsT0FBTztZQUFDLElBQUksQ0FBQ0MsU0FBUyxDQUFDNkI7WUFBT0YsT0FBT1osTUFBTTtTQUFDO0lBQ2hEO0lBQ0E7Ozs7OztLQU1DLEdBQ0RLLFVBQVVXLFFBQVEsRUFBRTdCLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEVBQUU7UUFDekMsSUFBR0wsUUFBUTBCLFFBQVEsRUFBRSwwQ0FBMEMsSUFBSSxDQUFDdEIsV0FBVyxFQUFFOEIsVUFBVTdCO1FBQzVGLE1BQU04QixTQUFTLElBQUlyQyxhQUFhc0MsVUFBVSxDQUFDL0I7UUFDM0M4QixPQUFPRSxXQUFXLENBQUNILFVBQVUsSUFBSSxDQUFDaEMsTUFBTTtRQUN4QyxPQUFPO1lBQUNpQyxPQUFPVixNQUFNO1lBQUVVLE9BQU9qQixNQUFNO1NBQUM7SUFDekM7SUFDQVosY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDSixNQUFNLENBQUNvQyxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHQyxLQUFLLEdBQUtGLE1BQU1FLEtBQUtwQyxRQUFRLEVBQUU7SUFDdkU7SUFDQSxJQUFJcUMsT0FBTztRQUNQLE9BQU83QyxXQUFXOEMsSUFBSTtJQUMxQjtBQUNKO0FBQ0FsRCxrQkFBa0IsR0FBR0k7QUFDckJBLFdBQVdPLFdBQVcsR0FBRztBQUN6QlAsV0FBVzhDLElBQUksR0FBRztBQUNsQixTQUFTL0MsYUFBYTZDLElBQUk7SUFDdEIsT0FBT0EsS0FBS0MsSUFBSSxLQUFLN0MsV0FBVzhDLElBQUk7QUFDeEM7QUFDQWxELG9CQUFvQixHQUFHRztBQUN2Qjs7Ozs7Q0FLQyxHQUNELE1BQU1ELHVCQUF1QkU7SUFDekJJLFlBQVlDLE1BQU0sRUFBRUUsY0FBY1QsZUFBZVMsV0FBVyxDQUFFO1FBQzFELEtBQUssQ0FBQ0YsUUFBUSxDQUFDOEIsT0FBU0EsTUFBTTVCO0lBQ2xDO0FBQ0o7QUFDQVgsc0JBQXNCLEdBQUdFO0FBQ3pCQSxlQUFlUyxXQUFXLEdBQUcsa0JBQzdCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvc3RydWN0LmpzP2Y2ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZXRBcmdzU3RydWN0ID0gZXhwb3J0cy5pc0JlZXRTdHJ1Y3QgPSBleHBvcnRzLkJlZXRTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCByZWFkX3dyaXRlXzEgPSByZXF1aXJlKFwiLi9yZWFkLXdyaXRlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBDb25maWd1cmVzIGEgY2xhc3Mgb3IgYW55IEphdmFTY3JpcHQgb2JqZWN0IHR5cGUgZm9yIGRlL3NlcmlhbGl6YXRpb24gYWthXG4gKiByZWFkL3dyaXRlLiBBbGwgZmllbGRzIG9mIHRoYXQgY2xhc3MgaGF2ZSB0byBiZSBvZiBmaXhlZCBzaXplLlxuICogSWYgYSBmaWVsZCByZXF1aXJlcyBhIHtAbGluayBGaXhhYmxlQmVldH0gdXNlIHRoZSB7QGxpbmsgRml4YWJsZUJlZXRTdHJ1Y3R9XG4gKiBpbnN0ZWFkLlxuICpcbiAqIEB0ZW1wbGF0ZSBDbGFzcyB0aGUgdHlwZSB0byBwcm9kdWNlIHdoZW4gZGVzZXJpYWxpemluZ1xuICogQHRlbXBsYXRlIEFyZ3MgY29udGFpbnMgYWxsIGZpZWxkcywgaXMgdHlwaWNhbGx5IGEgc3Vic2V0IG9mIENsYXNzIGFuZCBpc1xuICogdXNlZCB0byBjb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgaXRcbiAqXG4gKiBAY2F0ZWdvcnkgYmVldC9zdHJ1Y3RcbiAqL1xuY2xhc3MgQmVldFN0cnVjdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgQmVldFN0cnVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZHMgZGUvc2VyaWFsaXplcnMgZm9yIGVhY2ggZmllbGQgb2YgdGhlIHtAbGluayBDbGFzc31cbiAgICAgKiBAcGFyYW0gY29uc3RydWN0IHRoZSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIENsYXNzfVxuICAgICAqIGZyb20gdGhlIGFyZ3NcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gaWRlbnRpZmllcyB0aGlzIHN0cnVjdCBmb3IgZGlhZ25vc3RpY3MvZGVidWdnaW5nXG4gICAgICogcHVycG9zZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNvbnN0cnVjdCwgZGVzY3JpcHRpb24gPSBCZWV0U3RydWN0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdCA9IGNvbnN0cnVjdDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gdGhpcy5nZXRCeXRlU2l6ZSgpO1xuICAgICAgICBpZiAodXRpbHNfMS5sb2dEZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBmbGRzID0gZmllbGRzXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsXSkgPT4gYCR7U3RyaW5nKGtleSl9OiAke3ZhbC5kZXNjcmlwdGlvbn0gJHsoMCwgdXRpbHNfMS5iZWV0Qnl0ZXMpKHZhbCl9YClcbiAgICAgICAgICAgICAgICAuam9pbignXFxuICAnKTtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmxvZ0RlYnVnKShgc3RydWN0ICR7ZGVzY3JpcHRpb259IHtcXG4gICR7Zmxkc31cXG59ICR7KDAsIHV0aWxzXzEuYmVldEJ5dGVzKSh0aGlzKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbG9uZyB3aXRoIGB3cml0ZWAgdGhpcyBhbGxvd3Mgc3RydWN0cyB0byBiZSB0cmVhdGVkIGFzIHtAbGluayBCZWV0fXMgYW5kXG4gICAgICogdGh1cyBzdXBwb3J0cyBjb21wb3NpbmcvbmVzdGluZyB0aGVtIHRoZSBzYW1lIHdheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgW3ZhbHVlXSA9IHRoaXMuZGVzZXJpYWxpemUoYnVmLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsb25nIHdpdGggYHJlYWRgIHRoaXMgYWxsb3dzIHN0cnVjdHMgdG8gYmUgdHJlYXRlZCBhcyB7QGxpbmsgQmVldH1zIGFuZFxuICAgICAqIHRodXMgc3VwcG9ydHMgY29tcG9zaW5nL25lc3RpbmcgdGhlbSB0aGUgc2FtZSB3YXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB3cml0ZShidWYsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2lubmVyQnVmLCBpbm5lck9mZnNldF0gPSB0aGlzLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlubmVyQnVmLmNvcHkoYnVmLCBvZmZzZXQsIDAsIGlubmVyT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGluc3RhbmNlIG9mIHRoZSBDbGFzcyBmcm9tIHRoZSBwcm92aWRlZCBidWZmZXIgc3RhcnRpbmcgdG9cbiAgICAgKiByZWFkIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgW2luc3RhbmNlIG9mIENsYXNzLCBvZmZzZXQgaW50byBidWZmZXIgYWZ0ZXIgZGVzZXJpYWxpemF0aW9uIGNvbXBsZXRlZF1gXG4gICAgICovXG4gICAgZGVzZXJpYWxpemUoYnVmZmVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICh1dGlsc18xLmxvZ1RyYWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmxvZ1RyYWNlKSgnZGVzZXJpYWxpemluZyBbJXNdIGZyb20gJWQgYnl0ZXMgYnVmZmVyJywgdGhpcy5kZXNjcmlwdGlvbiwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEubG9nVHJhY2UpKGJ1ZmZlcik7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5sb2dUcmFjZSkoYnVmZmVyLnRvSlNPTigpLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyByZWFkX3dyaXRlXzEuQmVldFJlYWRlcihidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSByZWFkZXIucmVhZFN0cnVjdCh0aGlzLmZpZWxkcyk7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb25zdHJ1Y3QoYXJncyksIHJlYWRlci5vZmZzZXRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBwcm92aWRlZCBpbnN0YW5jZSBpbnRvIGEgbmV3IHtAbGluayBCdWZmZXJ9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2Ugb2YgdGhlIHN0cnVjdCB0byBzZXJpYWxpemVcbiAgICAgKiBAcGFyYW0gYnl0ZVNpemUgYWxsb3dzIHRvIG92ZXJyaWRlIHRoZSBzaXplIGZvIHRoZSBjcmVhdGVkIEJ1ZmZlciBhbmRcbiAgICAgKiBkZWZhdWx0cyB0byB0aGUgc2l6ZSBvZiB0aGUgc3RydWN0IHRvIHNlcmlhbGl6ZVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShpbnN0YW5jZSwgYnl0ZVNpemUgPSB0aGlzLmJ5dGVTaXplKSB7XG4gICAgICAgICgwLCB1dGlsc18xLmxvZ1RyYWNlKSgnc2VyaWFsaXppbmcgWyVzXSAlbyB0byAlZCBieXRlcyBidWZmZXInLCB0aGlzLmRlc2NyaXB0aW9uLCBpbnN0YW5jZSwgYnl0ZVNpemUpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgcmVhZF93cml0ZV8xLkJlZXRXcml0ZXIoYnl0ZVNpemUpO1xuICAgICAgICB3cml0ZXIud3JpdGVTdHJ1Y3QoaW5zdGFuY2UsIHRoaXMuZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIFt3cml0ZXIuYnVmZmVyLCB3cml0ZXIub2Zmc2V0XTtcbiAgICB9XG4gICAgZ2V0Qnl0ZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5yZWR1Y2UoKGFjYywgW18sIGJlZXRdKSA9PiBhY2MgKyBiZWV0LmJ5dGVTaXplLCAwKTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBCZWV0U3RydWN0LlRZUEU7XG4gICAgfVxufVxuZXhwb3J0cy5CZWV0U3RydWN0ID0gQmVldFN0cnVjdDtcbkJlZXRTdHJ1Y3QuZGVzY3JpcHRpb24gPSAnQmVldFN0cnVjdCc7XG5CZWV0U3RydWN0LlRZUEUgPSAnQmVldFN0cnVjdCc7XG5mdW5jdGlvbiBpc0JlZXRTdHJ1Y3QoYmVldCkge1xuICAgIHJldHVybiBiZWV0LnR5cGUgPT09IEJlZXRTdHJ1Y3QuVFlQRTtcbn1cbmV4cG9ydHMuaXNCZWV0U3RydWN0ID0gaXNCZWV0U3RydWN0O1xuLyoqXG4gKiBDb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgQmVldFN0cnVjdH0gd2hpY2ggaXMgdXNlZCBmb3IgcGxhaW4gSmF2YXNTY3JpcHRcbiAqIG9iamVjdHMsIGxpa2UgYXJlIHVzZWQgZm9yIG9wdGlvbiBhcmdzIHBhc3NlZCB0byBmdW5jdGlvbnMuXG4gKlxuICogQGNhdGVnb3J5IGJlZXQvc3RydWN0XG4gKi9cbmNsYXNzIEJlZXRBcmdzU3RydWN0IGV4dGVuZHMgQmVldFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBkZXNjcmlwdGlvbiA9IEJlZXRBcmdzU3RydWN0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgKGFyZ3MpID0+IGFyZ3MsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkJlZXRBcmdzU3RydWN0ID0gQmVldEFyZ3NTdHJ1Y3Q7XG5CZWV0QXJnc1N0cnVjdC5kZXNjcmlwdGlvbiA9ICdCZWV0QXJnc1N0cnVjdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJ1Y3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmVldEFyZ3NTdHJ1Y3QiLCJpc0JlZXRTdHJ1Y3QiLCJCZWV0U3RydWN0IiwicmVhZF93cml0ZV8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJjb25zdHJ1Y3RvciIsImZpZWxkcyIsImNvbnN0cnVjdCIsImRlc2NyaXB0aW9uIiwiYnl0ZVNpemUiLCJnZXRCeXRlU2l6ZSIsImxvZ0RlYnVnIiwiZW5hYmxlZCIsImZsZHMiLCJtYXAiLCJrZXkiLCJ2YWwiLCJTdHJpbmciLCJiZWV0Qnl0ZXMiLCJqb2luIiwicmVhZCIsImJ1ZiIsIm9mZnNldCIsImRlc2VyaWFsaXplIiwid3JpdGUiLCJpbm5lckJ1ZiIsImlubmVyT2Zmc2V0Iiwic2VyaWFsaXplIiwiY29weSIsImJ1ZmZlciIsImxvZ1RyYWNlIiwiYnl0ZUxlbmd0aCIsInRvSlNPTiIsImRhdGEiLCJyZWFkZXIiLCJCZWV0UmVhZGVyIiwiYXJncyIsInJlYWRTdHJ1Y3QiLCJpbnN0YW5jZSIsIndyaXRlciIsIkJlZXRXcml0ZXIiLCJ3cml0ZVN0cnVjdCIsInJlZHVjZSIsImFjYyIsIl8iLCJiZWV0IiwidHlwZSIsIlRZUEUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isElementCollectionFixedSizeBeet = exports.isFixableBeet = exports.assertFixedSizeBeet = exports.isFixedSizeBeet = exports.BEET_TYPE_ARG_INNER = exports.BEET_TYPE_ARG_LEN = exports.BEET_PACKAGE = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\n/**\n * Matches name in package.json\n *\n * @private\n */ exports.BEET_PACKAGE = \"@metaplex-foundation/beet\";\n/**\n * @private\n * @category beet\n */ exports.BEET_TYPE_ARG_LEN = \"len\";\n/**\n * @private\n * @category beet\n */ exports.BEET_TYPE_ARG_INNER = \"Beet<{innner}>\";\n// -----------------\n// Guards\n// -----------------\n/**\n * @private\n */ function isFixedSizeBeet(x) {\n    return Object.keys(x).includes(\"byteSize\");\n}\nexports.isFixedSizeBeet = isFixedSizeBeet;\n/**\n * @private\n */ function assertFixedSizeBeet(x, msg = `${x} should have been a fixed beet`) {\n    (0, assert_1.strict)(isFixedSizeBeet(x), msg);\n}\nexports.assertFixedSizeBeet = assertFixedSizeBeet;\n/**\n * @private\n */ function isFixableBeet(x) {\n    return typeof x.toFixedFromData === \"function\" && typeof x.toFixedFromValue === \"function\";\n}\nexports.isFixableBeet = isFixableBeet;\n/**\n * @private\n */ function isElementCollectionFixedSizeBeet(x) {\n    const keys = Object.keys(x);\n    return keys.includes(\"length\") && keys.includes(\"elementByteSize\") && keys.includes(\"lenPrefixByteSize\");\n}\nexports.isElementCollectionFixedSizeBeet = isElementCollectionFixedSizeBeet; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdDQUF3QyxHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLHVCQUF1QixHQUFHQSwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDak4sTUFBTVMsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakM7Ozs7Q0FJQyxHQUNEVixvQkFBb0IsR0FBRztBQUN2Qjs7O0NBR0MsR0FDREEseUJBQXlCLEdBQUc7QUFDNUI7OztDQUdDLEdBQ0RBLDJCQUEyQixHQUFHO0FBQzlCLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCOztDQUVDLEdBQ0QsU0FBU0ssZ0JBQWdCTSxDQUFDO0lBQ3RCLE9BQU9iLE9BQU9jLElBQUksQ0FBQ0QsR0FBR0UsUUFBUSxDQUFDO0FBQ25DO0FBQ0FiLHVCQUF1QixHQUFHSztBQUMxQjs7Q0FFQyxHQUNELFNBQVNELG9CQUFvQk8sQ0FBQyxFQUFFRyxNQUFNLENBQUMsRUFBRUgsRUFBRSw4QkFBOEIsQ0FBQztJQUNyRSxJQUFHRixTQUFTTSxNQUFNLEVBQUVWLGdCQUFnQk0sSUFBSUc7QUFDN0M7QUFDQWQsMkJBQTJCLEdBQUdJO0FBQzlCOztDQUVDLEdBQ0QsU0FBU0QsY0FBY1EsQ0FBQztJQUNwQixPQUFRLE9BQU9BLEVBQUVLLGVBQWUsS0FBSyxjQUNqQyxPQUFPTCxFQUFFTSxnQkFBZ0IsS0FBSztBQUN0QztBQUNBakIscUJBQXFCLEdBQUdHO0FBQ3hCOztDQUVDLEdBQ0QsU0FBU0QsaUNBQWlDUyxDQUFDO0lBQ3ZDLE1BQU1DLE9BQU9kLE9BQU9jLElBQUksQ0FBQ0Q7SUFDekIsT0FBUUMsS0FBS0MsUUFBUSxDQUFDLGFBQ2xCRCxLQUFLQyxRQUFRLENBQUMsc0JBQ2RELEtBQUtDLFFBQVEsQ0FBQztBQUN0QjtBQUNBYix3Q0FBd0MsR0FBR0Usa0NBQzNDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvdHlwZXMuanM/OWJkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNFbGVtZW50Q29sbGVjdGlvbkZpeGVkU2l6ZUJlZXQgPSBleHBvcnRzLmlzRml4YWJsZUJlZXQgPSBleHBvcnRzLmFzc2VydEZpeGVkU2l6ZUJlZXQgPSBleHBvcnRzLmlzRml4ZWRTaXplQmVldCA9IGV4cG9ydHMuQkVFVF9UWVBFX0FSR19JTk5FUiA9IGV4cG9ydHMuQkVFVF9UWVBFX0FSR19MRU4gPSBleHBvcnRzLkJFRVRfUEFDS0FHRSA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcImFzc2VydFwiKTtcbi8qKlxuICogTWF0Y2hlcyBuYW1lIGluIHBhY2thZ2UuanNvblxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuQkVFVF9QQUNLQUdFID0gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL2JlZXQnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IGJlZXRcbiAqL1xuZXhwb3J0cy5CRUVUX1RZUEVfQVJHX0xFTiA9ICdsZW4nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IGJlZXRcbiAqL1xuZXhwb3J0cy5CRUVUX1RZUEVfQVJHX0lOTkVSID0gJ0JlZXQ8e2lubm5lcn0+Jztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHdWFyZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWRTaXplQmVldCh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHgpLmluY2x1ZGVzKCdieXRlU2l6ZScpO1xufVxuZXhwb3J0cy5pc0ZpeGVkU2l6ZUJlZXQgPSBpc0ZpeGVkU2l6ZUJlZXQ7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEZpeGVkU2l6ZUJlZXQoeCwgbXNnID0gYCR7eH0gc2hvdWxkIGhhdmUgYmVlbiBhIGZpeGVkIGJlZXRgKSB7XG4gICAgKDAsIGFzc2VydF8xLnN0cmljdCkoaXNGaXhlZFNpemVCZWV0KHgpLCBtc2cpO1xufVxuZXhwb3J0cy5hc3NlcnRGaXhlZFNpemVCZWV0ID0gYXNzZXJ0Rml4ZWRTaXplQmVldDtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGaXhhYmxlQmVldCh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeC50b0ZpeGVkRnJvbURhdGEgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHgudG9GaXhlZEZyb21WYWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmlzRml4YWJsZUJlZXQgPSBpc0ZpeGFibGVCZWV0O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnRDb2xsZWN0aW9uRml4ZWRTaXplQmVldCh4KSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIHJldHVybiAoa2V5cy5pbmNsdWRlcygnbGVuZ3RoJykgJiZcbiAgICAgICAga2V5cy5pbmNsdWRlcygnZWxlbWVudEJ5dGVTaXplJykgJiZcbiAgICAgICAga2V5cy5pbmNsdWRlcygnbGVuUHJlZml4Qnl0ZVNpemUnKSk7XG59XG5leHBvcnRzLmlzRWxlbWVudENvbGxlY3Rpb25GaXhlZFNpemVCZWV0ID0gaXNFbGVtZW50Q29sbGVjdGlvbkZpeGVkU2l6ZUJlZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0VsZW1lbnRDb2xsZWN0aW9uRml4ZWRTaXplQmVldCIsImlzRml4YWJsZUJlZXQiLCJhc3NlcnRGaXhlZFNpemVCZWV0IiwiaXNGaXhlZFNpemVCZWV0IiwiQkVFVF9UWVBFX0FSR19JTk5FUiIsIkJFRVRfVFlQRV9BUkdfTEVOIiwiQkVFVF9QQUNLQUdFIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwieCIsImtleXMiLCJpbmNsdWRlcyIsIm1zZyIsInN0cmljdCIsInRvRml4ZWRGcm9tRGF0YSIsInRvRml4ZWRGcm9tVmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UnreachableCaseError = exports.bytes = exports.beetBytes = exports.logTrace = exports.logDebug = exports.logInfo = exports.logError = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js\"));\nconst ansicolors_1 = __importDefault(__webpack_require__(/*! ansicolors */ \"(ssr)/./node_modules/.pnpm/ansicolors@0.3.2/node_modules/ansicolors/ansicolors.js\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js\");\nconst { brightBlack } = ansicolors_1.default;\nexports.logError = (0, debug_1.default)(\"beet:error\");\nexports.logInfo = (0, debug_1.default)(\"beet:info\");\nexports.logDebug = (0, debug_1.default)(\"beet:debug\");\nexports.logTrace = (0, debug_1.default)(\"beet:trace\");\nfunction beetBytes(beet, isFixable = false) {\n    let bytes;\n    if ((0, types_1.isFixableBeet)(beet)) {\n        bytes = \"? B\";\n    } else if ((0, types_1.isElementCollectionFixedSizeBeet)(beet)) {\n        const len = isFixable ? \"length\" : beet.length;\n        const lenBytes = beet.lenPrefixByteSize;\n        bytes = lenBytes > 0 ? `${lenBytes} + (${beet.elementByteSize} * ${len}) B  (${beet.byteSize} B)` : `(${beet.elementByteSize} * ${len}) B (${beet.byteSize} B)`;\n    } else {\n        bytes = `${beet.byteSize} B`;\n    }\n    return brightBlack(bytes);\n}\nexports.beetBytes = beetBytes;\nfunction bytes(n) {\n    return brightBlack(`${n} B`);\n}\nexports.bytes = bytes;\nclass UnreachableCaseError extends Error {\n    constructor(value){\n        super(`Unreachable case: ${value}`);\n    }\n}\nexports.UnreachableCaseError = UnreachableCaseError; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFwbGV4LWZvdW5kYXRpb24rYmVldEAwLjYuMS9ub2RlX21vZHVsZXMvQG1ldGFwbGV4LWZvdW5kYXRpb24vYmVldC9kaXN0L2Nqcy9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDRCQUE0QixHQUFHQSxhQUFhLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNuSixNQUFNUyxVQUFVZCxnQkFBZ0JlLG1CQUFPQSxDQUFDLHFGQUFPO0FBQy9DLE1BQU1DLGVBQWVoQixnQkFBZ0JlLG1CQUFPQSxDQUFDLHFHQUFZO0FBQ3pELE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHdJQUFTO0FBQ2pDLE1BQU0sRUFBRUcsV0FBVyxFQUFFLEdBQUdGLGFBQWFHLE9BQU87QUFDNUNkLGdCQUFnQixHQUFHLENBQUMsR0FBR1MsUUFBUUssT0FBTyxFQUFFO0FBQ3hDZCxlQUFlLEdBQUcsQ0FBQyxHQUFHUyxRQUFRSyxPQUFPLEVBQUU7QUFDdkNkLGdCQUFnQixHQUFHLENBQUMsR0FBR1MsUUFBUUssT0FBTyxFQUFFO0FBQ3hDZCxnQkFBZ0IsR0FBRyxDQUFDLEdBQUdTLFFBQVFLLE9BQU8sRUFBRTtBQUN4QyxTQUFTVixVQUFVVyxJQUFJLEVBQUVDLFlBQVksS0FBSztJQUN0QyxJQUFJYjtJQUNKLElBQUksQ0FBQyxHQUFHUyxRQUFRSyxhQUFhLEVBQUVGLE9BQU87UUFDbENaLFFBQVE7SUFDWixPQUNLLElBQUksQ0FBQyxHQUFHUyxRQUFRTSxnQ0FBZ0MsRUFBRUgsT0FBTztRQUMxRCxNQUFNSSxNQUFNSCxZQUFZLFdBQVdELEtBQUtLLE1BQU07UUFDOUMsTUFBTUMsV0FBV04sS0FBS08saUJBQWlCO1FBQ3ZDbkIsUUFDSWtCLFdBQVcsSUFDTCxDQUFDLEVBQUVBLFNBQVMsSUFBSSxFQUFFTixLQUFLUSxlQUFlLENBQUMsR0FBRyxFQUFFSixJQUFJLE1BQU0sRUFBRUosS0FBS1MsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUMxRSxDQUFDLENBQUMsRUFBRVQsS0FBS1EsZUFBZSxDQUFDLEdBQUcsRUFBRUosSUFBSSxLQUFLLEVBQUVKLEtBQUtTLFFBQVEsQ0FBQyxHQUFHLENBQUM7SUFDekUsT0FDSztRQUNEckIsUUFBUSxDQUFDLEVBQUVZLEtBQUtTLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDaEM7SUFDQSxPQUFPWCxZQUFZVjtBQUN2QjtBQUNBSCxpQkFBaUIsR0FBR0k7QUFDcEIsU0FBU0QsTUFBTXNCLENBQUM7SUFDWixPQUFPWixZQUFZLENBQUMsRUFBRVksRUFBRSxFQUFFLENBQUM7QUFDL0I7QUFDQXpCLGFBQWEsR0FBR0c7QUFDaEIsTUFBTUQsNkJBQTZCd0I7SUFDL0JDLFlBQVkxQixLQUFLLENBQUU7UUFDZixLQUFLLENBQUMsQ0FBQyxrQkFBa0IsRUFBRUEsTUFBTSxDQUFDO0lBQ3RDO0FBQ0o7QUFDQUQsNEJBQTRCLEdBQUdFLHNCQUMvQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhcGxleC1mb3VuZGF0aW9uK2JlZXRAMC42LjEvbm9kZV9tb2R1bGVzL0BtZXRhcGxleC1mb3VuZGF0aW9uL2JlZXQvZGlzdC9janMvc3JjL3V0aWxzLmpzPzM1NjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVucmVhY2hhYmxlQ2FzZUVycm9yID0gZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuYmVldEJ5dGVzID0gZXhwb3J0cy5sb2dUcmFjZSA9IGV4cG9ydHMubG9nRGVidWcgPSBleHBvcnRzLmxvZ0luZm8gPSBleHBvcnRzLmxvZ0Vycm9yID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYW5zaWNvbG9yc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNpY29sb3JzXCIpKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHsgYnJpZ2h0QmxhY2sgfSA9IGFuc2ljb2xvcnNfMS5kZWZhdWx0O1xuZXhwb3J0cy5sb2dFcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdiZWV0OmVycm9yJyk7XG5leHBvcnRzLmxvZ0luZm8gPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnYmVldDppbmZvJyk7XG5leHBvcnRzLmxvZ0RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ2JlZXQ6ZGVidWcnKTtcbmV4cG9ydHMubG9nVHJhY2UgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnYmVldDp0cmFjZScpO1xuZnVuY3Rpb24gYmVldEJ5dGVzKGJlZXQsIGlzRml4YWJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGJ5dGVzO1xuICAgIGlmICgoMCwgdHlwZXNfMS5pc0ZpeGFibGVCZWV0KShiZWV0KSkge1xuICAgICAgICBieXRlcyA9ICc/IEInO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdHlwZXNfMS5pc0VsZW1lbnRDb2xsZWN0aW9uRml4ZWRTaXplQmVldCkoYmVldCkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gaXNGaXhhYmxlID8gJ2xlbmd0aCcgOiBiZWV0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGVuQnl0ZXMgPSBiZWV0LmxlblByZWZpeEJ5dGVTaXplO1xuICAgICAgICBieXRlcyA9XG4gICAgICAgICAgICBsZW5CeXRlcyA+IDBcbiAgICAgICAgICAgICAgICA/IGAke2xlbkJ5dGVzfSArICgke2JlZXQuZWxlbWVudEJ5dGVTaXplfSAqICR7bGVufSkgQiAgKCR7YmVldC5ieXRlU2l6ZX0gQilgXG4gICAgICAgICAgICAgICAgOiBgKCR7YmVldC5lbGVtZW50Qnl0ZVNpemV9ICogJHtsZW59KSBCICgke2JlZXQuYnl0ZVNpemV9IEIpYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ5dGVzID0gYCR7YmVldC5ieXRlU2l6ZX0gQmA7XG4gICAgfVxuICAgIHJldHVybiBicmlnaHRCbGFjayhieXRlcyk7XG59XG5leHBvcnRzLmJlZXRCeXRlcyA9IGJlZXRCeXRlcztcbmZ1bmN0aW9uIGJ5dGVzKG4pIHtcbiAgICByZXR1cm4gYnJpZ2h0QmxhY2soYCR7bn0gQmApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuY2xhc3MgVW5yZWFjaGFibGVDYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFVucmVhY2hhYmxlIGNhc2U6ICR7dmFsdWV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5VbnJlYWNoYWJsZUNhc2VFcnJvciA9IFVucmVhY2hhYmxlQ2FzZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlVucmVhY2hhYmxlQ2FzZUVycm9yIiwiYnl0ZXMiLCJiZWV0Qnl0ZXMiLCJsb2dUcmFjZSIsImxvZ0RlYnVnIiwibG9nSW5mbyIsImxvZ0Vycm9yIiwiZGVidWdfMSIsInJlcXVpcmUiLCJhbnNpY29sb3JzXzEiLCJ0eXBlc18xIiwiYnJpZ2h0QmxhY2siLCJkZWZhdWx0IiwiYmVldCIsImlzRml4YWJsZSIsImlzRml4YWJsZUJlZXQiLCJpc0VsZW1lbnRDb2xsZWN0aW9uRml4ZWRTaXplQmVldCIsImxlbiIsImxlbmd0aCIsImxlbkJ5dGVzIiwibGVuUHJlZml4Qnl0ZVNpemUiLCJlbGVtZW50Qnl0ZVNpemUiLCJieXRlU2l6ZSIsIm4iLCJFcnJvciIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@metaplex-foundation+beet@0.6.1/node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js\n");

/***/ })

};
;