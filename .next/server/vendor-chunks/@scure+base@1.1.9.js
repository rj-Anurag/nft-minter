"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure+base@1.1.9";
exports.ids = ["vendor-chunks/@scure+base@1.1.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;\nexports.assertNumber = assertNumber;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nexports.utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nexports.base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nexports.base32nopad = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\nexports.base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nexports.base32hexnopad = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\nexports.base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nexports.base64 = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nexports.base64nopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\nexports.base64url = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nexports.base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nexports.base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexports.base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nexports.base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nexports.base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), exports.base58);\nexports.createBase58check = createBase58check;\n// legacy export, bad name\nexports.base58check = exports.createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (words instanceof Uint8Array) words = Array.from(words);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nexports.bech32 = genBech32(\"bech32\");\nexports.bech32m = genBech32(\"bech32m\");\nexports.utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8,\n    hex: exports.hex,\n    base16: exports.base16,\n    base32: exports.base32,\n    base64: exports.base64,\n    base64url: exports.base64url,\n    base58: exports.base58,\n    base58xmr: exports.base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNjdXJlK2Jhc2VAMS4xLjkvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGtFQUFrRSxHQUNsRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0EscUJBQXFCLEdBQUdBLFdBQVcsR0FBR0EscUJBQXFCLEdBQUdBLFdBQVcsR0FBR0EsWUFBWSxHQUFHQSxlQUFlLEdBQUdBLGNBQWMsR0FBR0EsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUN4ZkEsb0JBQW9CLEdBQUcyQjtBQUN2QixZQUFZO0FBQ1o7O0NBRUMsR0FDRCxTQUFTQSxhQUFhQyxDQUFDO0lBQ25CLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixJQUN0QixNQUFNLElBQUlHLE1BQU0sQ0FBQyxlQUFlLEVBQUVILEVBQUUsQ0FBQztBQUM3QztBQUNBLFNBQVNJLFFBQVFDLENBQUM7SUFDZCxPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLE1BQU0sR0FBR0MsSUFBSTtJQUNsQixNQUFNQyxLQUFLLENBQUNOLElBQU1BO0lBQ2xCLCtDQUErQztJQUMvQyxNQUFNTyxPQUFPLENBQUNQLEdBQUdRLElBQU0sQ0FBQ0MsSUFBTVQsRUFBRVEsRUFBRUM7SUFDbEMsNkRBQTZEO0lB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UUFBUWUsTUFBTTtJQUFFSCxXQUFXWixRQUFRWSxTQUFTO0FBQ3BNO0FBQ0EsTUFBTXlJLGlCQUFpQjtBQUN2QixNQUFNaEosZ0JBQWdCLENBQUNpSixNQUFNcEo7SUFDekIsSUFBSSxPQUFPb0osU0FBUyxZQUFZLENBQUNGLE9BQU9HLGNBQWMsQ0FBQ0QsT0FDbkQsTUFBTSxJQUFJZixVQUFVYztJQUN4QixJQUFJLENBQUNySCxRQUFROUIsUUFDVCxNQUFNLElBQUlxSSxVQUFVO0lBQ3hCLE9BQU9hLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDM0csTUFBTSxDQUFDekM7QUFDL0I7QUFDQUYscUJBQXFCLEdBQUdLO0FBQ3hCTCxXQUFXLEdBQUdBLFFBQVFLLGFBQWEsRUFBRSxtQ0FBbUM7QUFDeEUsTUFBTUYsZ0JBQWdCLENBQUNtSixNQUFNbEo7SUFDekIsSUFBSSxDQUFDZ0osT0FBT0csY0FBYyxDQUFDRCxPQUN2QixNQUFNLElBQUlmLFVBQVVjO0lBQ3hCLElBQUksT0FBT2pKLFFBQVEsVUFDZixNQUFNLElBQUltSSxVQUFVO0lBQ3hCLE9BQU9hLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDdkcsTUFBTSxDQUFDM0M7QUFDL0I7QUFDQUoscUJBQXFCLEdBQUdHO0FBQ3hCSCxhQUFhLEdBQUdBLFFBQVFHLGFBQWEsRUFDckMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2N1cmUrYmFzZUAxLjEuOS9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2luZGV4LmpzPzI3YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5oZXggPSBleHBvcnRzLnV0ZjggPSBleHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IGV4cG9ydHMuYmFzZTU4Y2hlY2sgPSBleHBvcnRzLmNyZWF0ZUJhc2U1OGNoZWNrID0gZXhwb3J0cy5iYXNlNTh4bXIgPSBleHBvcnRzLmJhc2U1OHhycCA9IGV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZXhwb3J0cy5iYXNlNTggPSBleHBvcnRzLmJhc2U2NHVybG5vcGFkID0gZXhwb3J0cy5iYXNlNjR1cmwgPSBleHBvcnRzLmJhc2U2NG5vcGFkID0gZXhwb3J0cy5iYXNlNjQgPSBleHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGV4cG9ydHMuYmFzZTMyaGV4bm9wYWQgPSBleHBvcnRzLmJhc2UzMmhleCA9IGV4cG9ydHMuYmFzZTMybm9wYWQgPSBleHBvcnRzLmJhc2UzMiA9IGV4cG9ydHMuYmFzZTE2ID0gZXhwb3J0cy51dGlscyA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuLy8gVXRpbGl0aWVzXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gLypAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDsgLy8gYml0d2lzZSBwb3NpdGlvbiBpbiBjdXJyZW50IGVsZW1lbnRcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIGNvbnZlcnRSYWRpeCwgY29udmVydFJhZGl4MiwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyxcbn07XG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5iYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJub3BhZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyaGV4ID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJoZXhub3BhZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydHMuYmFzZTY0ID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U2NG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjR1cmxub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgam9pbignJykpO1xuLy8gYmFzZTU4IGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5jb25zdCBnZW5CYXNlNTggPSAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnRzLmJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0cy5iYXNlNTh4cnAgPSBnZW5CYXNlNTgoJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonKTtcbi8vIHhtciB2ZXIgaXMgZG9uZSBpbiA4LWJ5dGUgYmxvY2tzICh3aGljaCBlcXVhbHMgMTEgY2hhcnMgaW4gZGVjb2RpbmcpLiBMYXN0IChub24tZnVsbCkgYmxvY2sgcGFkZGVkIHdpdGggJzEnIHRvIHNpemUgaW4gWE1SX0JMT0NLX0xFTi5cbi8vIEJsb2NrIGVuY29kaW5nIHNpZ25pZmljYW50bHkgcmVkdWNlcyBxdWFkcmF0aWMgY29tcGxleGl0eSBvZiBiYXNlNTguXG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnRzLmJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBleHBvcnRzLmJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGV4cG9ydHMuYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBleHBvcnRzLmJhc2U1OCk7XG5leHBvcnRzLmNyZWF0ZUJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG4vLyBsZWdhY3kgZXhwb3J0LCBiYWQgbmFtZVxuZXhwb3J0cy5iYXNlNThjaGVjayA9IGV4cG9ydHMuY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gLyogQF9fUFVSRV9fICovIGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSAyICoqIDMwXSwgMzAsIDUsIGZhbHNlKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKHdvcmRzIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHdvcmRzID0gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3ByZWZpeC5sZW5ndGh9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVGcm9tQnl0ZXMocHJlZml4LCBieXRlcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlKHByZWZpeCwgdG9Xb3JkcyhieXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgICAgICBkZWNvZGVUb0J5dGVzLFxuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICB0b1dvcmRzLFxuICAgIH07XG59XG5leHBvcnRzLmJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydHMudXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnRzLmhleCA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4OiBleHBvcnRzLnV0ZjgsIGhleDogZXhwb3J0cy5oZXgsIGJhc2UxNjogZXhwb3J0cy5iYXNlMTYsIGJhc2UzMjogZXhwb3J0cy5iYXNlMzIsIGJhc2U2NDogZXhwb3J0cy5iYXNlNjQsIGJhc2U2NHVybDogZXhwb3J0cy5iYXNlNjR1cmwsIGJhc2U1ODogZXhwb3J0cy5iYXNlNTgsIGJhc2U1OHhtcjogZXhwb3J0cy5iYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9ICdJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yJztcbmNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuc3RyID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nOyAvLyBhcyBpbiBweXRob24sIGJ1dCBmb3IgYnl0ZXMgb25seVxuY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYnl0ZXMiLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiYnl0ZXNUb1N0cmluZyIsImhleCIsInV0ZjgiLCJiZWNoMzJtIiwiYmVjaDMyIiwiYmFzZTU4Y2hlY2siLCJjcmVhdGVCYXNlNThjaGVjayIsImJhc2U1OHhtciIsImJhc2U1OHhycCIsImJhc2U1OGZsaWNrciIsImJhc2U1OCIsImJhc2U2NHVybG5vcGFkIiwiYmFzZTY0dXJsIiwiYmFzZTY0bm9wYWQiLCJiYXNlNjQiLCJiYXNlMzJjcm9ja2ZvcmQiLCJiYXNlMzJoZXhub3BhZCIsImJhc2UzMmhleCIsImJhc2UzMm5vcGFkIiwiYmFzZTMyIiwiYmFzZTE2IiwidXRpbHMiLCJhc3NlcnROdW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY2hhaW4iLCJhcmdzIiwiaWQiLCJ3cmFwIiwiYiIsImMiLCJlbmNvZGUiLCJtYXAiLCJ4IiwicmVkdWNlUmlnaHQiLCJkZWNvZGUiLCJyZWR1Y2UiLCJhbHBoYWJldCIsImRpZ2l0cyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImkiLCJpbnB1dCIsImxldHRlciIsImluZGV4IiwiaW5kZXhPZiIsImpvaW4iLCJzZXBhcmF0b3IiLCJmcm9tIiwidG8iLCJzcGxpdCIsInBhZGRpbmciLCJiaXRzIiwiY2hyIiwiZGF0YSIsInB1c2giLCJlbmQiLCJzbGljZSIsIm5vcm1hbGl6ZSIsImZuIiwiY29udmVydFJhZGl4IiwicG9zIiwicmVzIiwiZm9yRWFjaCIsImQiLCJjYXJyeSIsImRvbmUiLCJkaWdpdCIsImRpZ2l0QmFzZSIsInJvdW5kZWQiLCJNYXRoIiwiZmxvb3IiLCJyZXZlcnNlIiwiZ2NkIiwicmFkaXgyY2FycnkiLCJjb252ZXJ0UmFkaXgyIiwibWFzayIsInJhZGl4IiwibnVtIiwicmFkaXgyIiwicmV2UGFkZGluZyIsInVuc2FmZVdyYXBwZXIiLCJhcHBseSIsImUiLCJjaGVja3N1bSIsImxlbiIsInNldCIsInBheWxvYWQiLCJuZXdDaGVja3N1bSIsIm9sZENoZWNrc3VtIiwicyIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsImdlbkJhc2U1OCIsImFiYyIsIlhNUl9CTE9DS19MRU4iLCJibG9jayIsInN1YmFycmF5IiwicGFkU3RhcnQiLCJibG9ja0xlbiIsImoiLCJjb25jYXQiLCJzaGEyNTYiLCJCRUNIX0FMUEhBQkVUIiwiUE9MWU1PRF9HRU5FUkFUT1JTIiwiYmVjaDMyUG9seW1vZCIsInByZSIsImNoayIsImJlY2hDaGVja3N1bSIsInByZWZpeCIsIndvcmRzIiwiZW5jb2RpbmdDb25zdCIsImNoYXJDb2RlQXQiLCJ2IiwiZ2VuQmVjaDMyIiwiZW5jb2RpbmciLCJFTkNPRElOR19DT05TVCIsIl93b3JkcyIsImZyb21Xb3JkcyIsInRvV29yZHMiLCJmcm9tV29yZHNVbnNhZmUiLCJsaW1pdCIsIlR5cGVFcnJvciIsImFjdHVhbExlbmd0aCIsImxvd2VyZWQiLCJ0b0xvd2VyQ2FzZSIsInN1bSIsInNlcEluZGV4IiwibGFzdEluZGV4T2YiLCJlbmRzV2l0aCIsImRlY29kZVVuc2FmZSIsImRlY29kZVRvQnl0ZXMiLCJlbmNvZGVGcm9tQnl0ZXMiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiQ09ERVJTIiwiY29kZXJUeXBlRXJyb3IiLCJ0eXBlIiwiaGFzT3duUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@scure+base@1.1.9/node_modules/@scure/base/lib/index.js\n");

/***/ })

};
;