"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3";
exports.ids = ["vendor-chunks/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.cjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.cjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar errors = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/errors/dist/index.node.cjs\");\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\nexports.addCodecSentinel = addCodecSentinel;\nexports.addCodecSizePrefix = addCodecSizePrefix;\nexports.addDecoderSentinel = addDecoderSentinel;\nexports.addDecoderSizePrefix = addDecoderSizePrefix;\nexports.addEncoderSentinel = addEncoderSentinel;\nexports.addEncoderSizePrefix = addEncoderSizePrefix;\nexports.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec;\nexports.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec;\nexports.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;\nexports.assertIsFixedSize = assertIsFixedSize;\nexports.assertIsVariableSize = assertIsVariableSize;\nexports.combineCodec = combineCodec;\nexports.containsBytes = containsBytes;\nexports.createCodec = createCodec;\nexports.createDecoder = createDecoder;\nexports.createEncoder = createEncoder;\nexports.fixBytes = fixBytes;\nexports.fixCodecSize = fixCodecSize;\nexports.fixDecoderSize = fixDecoderSize;\nexports.fixEncoderSize = fixEncoderSize;\nexports.getEncodedSize = getEncodedSize;\nexports.isFixedSize = isFixedSize;\nexports.isVariableSize = isVariableSize;\nexports.mergeBytes = mergeBytes;\nexports.offsetCodec = offsetCodec;\nexports.offsetDecoder = offsetDecoder;\nexports.offsetEncoder = offsetEncoder;\nexports.padBytes = padBytes;\nexports.padLeftCodec = padLeftCodec;\nexports.padLeftDecoder = padLeftDecoder;\nexports.padLeftEncoder = padLeftEncoder;\nexports.padRightCodec = padRightCodec;\nexports.padRightDecoder = padRightDecoder;\nexports.padRightEncoder = padRightEncoder;\nexports.resizeCodec = resizeCodec;\nexports.resizeDecoder = resizeDecoder;\nexports.resizeEncoder = resizeEncoder;\nexports.reverseCodec = reverseCodec;\nexports.reverseDecoder = reverseDecoder;\nexports.reverseEncoder = reverseEncoder;\nexports.transformCodec = transformCodec;\nexports.transformDecoder = transformDecoder;\nexports.transformEncoder = transformEncoder; //# sourceMappingURL=index.node.cjs.map\n //# sourceMappingURL=index.node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBRXJCLDRCQUE0QjtBQUU1QixlQUFlO0FBQ2YsSUFBSUMsYUFBYSxDQUFDQztJQUNoQixNQUFNQyxxQkFBcUJELFdBQVdFLE1BQU0sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxNQUFNO0lBQ2hFLElBQUlILG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0osV0FBV0ksTUFBTSxHQUFHSixVQUFVLENBQUMsRUFBRSxHQUFHLElBQUlLO0lBQ2pEO0lBQ0EsSUFBSUosbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSCxrQkFBa0IsQ0FBQyxFQUFFO0lBQzlCO0lBQ0EsTUFBTUssY0FBY0wsbUJBQW1CTSxNQUFNLENBQUMsQ0FBQ0MsT0FBT0wsTUFBUUssUUFBUUwsSUFBSUMsTUFBTSxFQUFFO0lBQ2xGLE1BQU1LLFNBQVMsSUFBSUosV0FBV0M7SUFDOUIsSUFBSUksU0FBUztJQUNiVCxtQkFBbUJVLE9BQU8sQ0FBQyxDQUFDUjtRQUMxQk0sT0FBT0csR0FBRyxDQUFDVCxLQUFLTztRQUNoQkEsVUFBVVAsSUFBSUMsTUFBTTtJQUN0QjtJQUNBLE9BQU9LO0FBQ1Q7QUFDQSxJQUFJSSxXQUFXLENBQUNDLE9BQU9WO0lBQ3JCLElBQUlVLE1BQU1WLE1BQU0sSUFBSUEsUUFBUSxPQUFPVTtJQUNuQyxNQUFNQyxjQUFjLElBQUlWLFdBQVdELFFBQVFZLElBQUksQ0FBQztJQUNoREQsWUFBWUgsR0FBRyxDQUFDRTtJQUNoQixPQUFPQztBQUNUO0FBQ0EsSUFBSUUsV0FBVyxDQUFDSCxPQUFPVixTQUFXUyxTQUFTQyxNQUFNVixNQUFNLElB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bEc7QUFDdkJrRyxxQkFBcUIsR0FBRzlIO0FBQ3hCOEgsbUJBQW1CLEdBQUczRztBQUN0QjJHLHFCQUFxQixHQUFHL0c7QUFDeEIrRyxxQkFBcUIsR0FBR3BIO0FBQ3hCb0gsZ0JBQWdCLEdBQUdoSTtBQUNuQmdJLG9CQUFvQixHQUFHMUM7QUFDdkIwQyxzQkFBc0IsR0FBRzNDO0FBQ3pCMkMsc0JBQXNCLEdBQUcvQztBQUN6QitDLHNCQUFzQixHQUFHekg7QUFDekJ5SCxtQkFBbUIsR0FBR3pHO0FBQ3RCeUcsc0JBQXNCLEdBQUdyRztBQUN6QnFHLGtCQUFrQixHQUFHbEo7QUFDckJrSixtQkFBbUIsR0FBR2hDO0FBQ3RCZ0MscUJBQXFCLEdBQUdqQztBQUN4QmlDLHFCQUFxQixHQUFHekM7QUFDeEJ5QyxnQkFBZ0IsR0FBR3BJO0FBQ25Cb0ksb0JBQW9CLEdBQUduQjtBQUN2Qm1CLHNCQUFzQixHQUFHckI7QUFDekJxQixzQkFBc0IsR0FBR3ZCO0FBQ3pCdUIscUJBQXFCLEdBQUdsQjtBQUN4QmtCLHVCQUF1QixHQUFHcEI7QUFDMUJvQix1QkFBdUIsR0FBR3RCO0FBQzFCc0IsbUJBQW1CLEdBQUd4QjtBQUN0QndCLHFCQUFxQixHQUFHekI7QUFDeEJ5QixxQkFBcUIsR0FBRzdCO0FBQ3hCNkIsb0JBQW9CLEdBQUdOO0FBQ3ZCTSxzQkFBc0IsR0FBR1I7QUFDekJRLHNCQUFzQixHQUFHVjtBQUN6QlUsc0JBQXNCLEdBQUdEO0FBQ3pCQyx3QkFBd0IsR0FBR0g7QUFDM0JHLHdCQUF3QixHQUFHTCxrQkFDM0IsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLmNqcz82OTk3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJ0Bzb2xhbmEvZXJyb3JzJyk7XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgbWVyZ2VCeXRlcyA9IChieXRlQXJyYXlzKSA9PiB7XG4gIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGgpO1xuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlQXJyYXlzLmxlbmd0aCA/IGJ5dGVBcnJheXNbMF0gOiBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vbkVtcHR5Qnl0ZUFycmF5c1swXTtcbiAgfVxuICBjb25zdCB0b3RhbExlbmd0aCA9IG5vbkVtcHR5Qnl0ZUFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIG5vbkVtcHR5Qnl0ZUFycmF5cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHBhZEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBieXRlcztcbiAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gIHBhZGRlZEJ5dGVzLnNldChieXRlcyk7XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn07XG52YXIgZml4Qnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4gcGFkQnl0ZXMoYnl0ZXMubGVuZ3RoIDw9IGxlbmd0aCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSwgbGVuZ3RoKTtcbmZ1bmN0aW9uIGNvbnRhaW5zQnl0ZXMoZGF0YSwgYnl0ZXMsIG9mZnNldCkge1xuICBjb25zdCBzbGljZSA9IG9mZnNldCA9PT0gMCAmJiBkYXRhLmxlbmd0aCA9PT0gYnl0ZXMubGVuZ3RoID8gZGF0YSA6IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlcy5sZW5ndGgpO1xuICBpZiAoc2xpY2UubGVuZ3RoICE9PSBieXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGJ5dGVzLmV2ZXJ5KChiLCBpKSA9PiBiID09PSBzbGljZVtpXSk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBlbmNvZGVyID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlcihlbmNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSk7XG4gICAgICBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoZGVjb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZGVjb2RlcixcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmNvZGVjLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBjb2RlYy5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBjb2RlYykpO1xuICAgICAgY29kZWMud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNGaXhlZFNpemUoY29kZWMpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gY29kZWMgJiYgdHlwZW9mIGNvZGVjLmZpeGVkU2l6ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRml4ZWRTaXplKGNvZGVjKSB7XG4gIGlmICghaXNGaXhlZFNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tYmluZUNvZGVjKGVuY29kZXIsIGRlY29kZXIpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICE9PSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIKTtcbiAgfVxuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5maXhlZFNpemUgIT09IGRlY29kZXIuZml4ZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyTWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplLFxuICAgICAgZW5jb2Rlck1heFNpemU6IGVuY29kZXIubWF4U2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5lbmNvZGVyLFxuICAgIGRlY29kZTogZGVjb2Rlci5kZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGVyLmVuY29kZSxcbiAgICByZWFkOiBkZWNvZGVyLnJlYWQsXG4gICAgd3JpdGU6IGVuY29kZXIud3JpdGVcbiAgfTtcbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsKGVuY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmIChmaW5kU2VudGluZWxJbmRleChlbmNvZGVyQnl0ZXMsIHNlbnRpbmVsKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCB7XG4gICAgICAgIGVuY29kZWRCeXRlczogZW5jb2RlckJ5dGVzLFxuICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNlbnRpbmVsLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHdyaXRlIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLmVuY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBlbmNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSArIHNlbnRpbmVsLmxlbmd0aCxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTZW50aW5lbChkZWNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjYW5kaWRhdGVCeXRlcyA9IG9mZnNldCA9PT0gMCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICBjb25zdCBzZW50aW5lbEluZGV4ID0gZmluZFNlbnRpbmVsSW5kZXgoY2FuZGlkYXRlQnl0ZXMsIHNlbnRpbmVsKTtcbiAgICBpZiAoc2VudGluZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIHJlYWRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpLCBhZGREZWNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSk7XG59XG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlcywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChzZW50aW5lbC5sZW5ndGggPT09IDEpIHJldHVybiBieXRlID09PSBzZW50aW5lbFswXTtcbiAgICByZXR1cm4gY29udGFpbnNCeXRlcyhhcnIsIHNlbnRpbmVsLCBpbmRleCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBleHBlY3RlZCwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChieXRlc0xlbmd0aCA8IGV4cGVjdGVkKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIGV4cGVjdGVkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uLCBvZmZzZXQsIGJ5dGVzTGVuZ3RoKSB7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4KGVuY29kZXIsIHByZWZpeCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBvZmZzZXQgPSBwcmVmaXgud3JpdGUoZW5jb2RlckJ5dGVzLmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyKGJpZ2ludFNpemUpO1xuICAgIG9mZnNldCA9IGRlY29kZXJPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiYWRkRGVjb2RlclNpemVQcmVmaXhcIiwgc2l6ZSwgYnl0ZXMpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGRlY29kZXIuZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IGRlY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBkZWNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBkZWNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXgoY29kZWMsIHByZWZpeCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpLCBhZGREZWNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSk7XG59XG5cbi8vIHNyYy9maXgtY29kZWMtc2l6ZS50c1xuZnVuY3Rpb24gZml4RW5jb2RlclNpemUoZW5jb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlQnl0ZUFycmF5ID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgZml4ZWRCeXRlQXJyYXkgPSB2YXJpYWJsZUJ5dGVBcnJheS5sZW5ndGggPiBmaXhlZEJ5dGVzID8gdmFyaWFibGVCeXRlQXJyYXkuc2xpY2UoMCwgZml4ZWRCeXRlcykgOiB2YXJpYWJsZUJ5dGVBcnJheTtcbiAgICAgIGJ5dGVzLnNldChmaXhlZEJ5dGVBcnJheSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBmaXhlZEJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhEZWNvZGVyU2l6ZShkZWNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJmaXhDb2RlY1NpemVcIiwgZml4ZWRCeXRlcywgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBmaXhlZEJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBmaXhlZEJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgICAgICBieXRlcyA9IGZpeEJ5dGVzKGJ5dGVzLCBkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBbdmFsdWVdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGZpeGVkQnl0ZXNdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhDb2RlY1NpemUoY29kZWMsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhmaXhFbmNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcyksIGZpeERlY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSk7XG59XG5cbi8vIHNyYy9vZmZzZXQtY29kZWMudHNcbmZ1bmN0aW9uIG9mZnNldEVuY29kZXIoZW5jb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcG9zdE9mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3UG9zdE9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0RGVjb2RlcihkZWNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgW3ZhbHVlLCBwb3N0T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3UG9zdE9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldENvZGVjKGNvZGVjLCBjb25maWcpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhvZmZzZXRFbmNvZGVyKGNvZGVjLCBjb25maWcpLCBvZmZzZXREZWNvZGVyKGNvZGVjLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIG1vZHVsbyhkaXZpZGVuZCwgZGl2aXNvcikge1xuICBpZiAoZGl2aXNvciA9PT0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xufVxuZnVuY3Rpb24gcmVzaXplRW5jb2RlcihlbmNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGVuY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBuZXdTaXplID0gcmVzaXplKGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKG5ld1NpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBuZXdTaXplLFxuICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZURlY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuZnVuY3Rpb24gcmVzaXplQ29kZWMoY29kZWMsIHJlc2l6ZSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJlc2l6ZUVuY29kZXIoY29kZWMsIHJlc2l6ZSksIHJlc2l6ZURlY29kZXIoY29kZWMsIHJlc2l6ZSkpO1xufVxuXG4vLyBzcmMvcGFkLWNvZGVjLnRzXG5mdW5jdGlvbiBwYWRMZWZ0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZExlZnRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRMZWZ0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5mdW5jdGlvbiBwYWRSaWdodENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRSaWdodEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZFJpZ2h0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5cbi8vIHNyYy9yZXZlcnNlLWNvZGVjLnRzXG5mdW5jdGlvbiBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2Uoc291cmNlLCB0YXJnZXRfV0lMTF9NVVRBVEUsIHNvdXJjZU9mZnNldCwgc291cmNlTGVuZ3RoLCB0YXJnZXRPZmZzZXQgPSAwKSB7XG4gIHdoaWxlIChzb3VyY2VPZmZzZXQgPCAtLXNvdXJjZUxlbmd0aCkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZUxlbmd0aF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZUxlbmd0aCArIHRhcmdldE9mZnNldF0gPSBsZWZ0VmFsdWU7XG4gICAgc291cmNlT2Zmc2V0Kys7XG4gIH1cbiAgaWYgKHNvdXJjZU9mZnNldCA9PT0gc291cmNlTGVuZ3RoKSB7XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZUVuY29kZXIoZW5jb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShlbmNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBieXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VEZWNvZGVyKGRlY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZGVjb2Rlcik7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCByZXZlcnNlZEJ5dGVzID0gYnl0ZXMuc2xpY2UoKTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIHJldmVyc2VkQnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZGVjb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVjb2Rlci5yZWFkKHJldmVyc2VkQnl0ZXMsIG9mZnNldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJldmVyc2VFbmNvZGVyKGNvZGVjKSwgcmV2ZXJzZURlY29kZXIoY29kZWMpKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybS1jb2RlYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcihlbmNvZGVyLCB1bm1hcCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uaXNWYXJpYWJsZVNpemUoZW5jb2RlcikgPyB7IC4uLmVuY29kZXIsIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHVubWFwKHZhbHVlKSkgfSA6IGVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4gZW5jb2Rlci53cml0ZSh1bm1hcCh2YWx1ZSksIGJ5dGVzLCBvZmZzZXQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcihkZWNvZGVyLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBbbWFwKHZhbHVlLCBieXRlcywgb2Zmc2V0KSwgbmV3T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ29kZWMoY29kZWMsIHVubWFwLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAuLi50cmFuc2Zvcm1FbmNvZGVyKGNvZGVjLCB1bm1hcCksXG4gICAgcmVhZDogbWFwID8gdHJhbnNmb3JtRGVjb2Rlcihjb2RlYywgbWFwKS5yZWFkIDogY29kZWMucmVhZFxuICB9KTtcbn1cblxuZXhwb3J0cy5hZGRDb2RlY1NlbnRpbmVsID0gYWRkQ29kZWNTZW50aW5lbDtcbmV4cG9ydHMuYWRkQ29kZWNTaXplUHJlZml4ID0gYWRkQ29kZWNTaXplUHJlZml4O1xuZXhwb3J0cy5hZGREZWNvZGVyU2VudGluZWwgPSBhZGREZWNvZGVyU2VudGluZWw7XG5leHBvcnRzLmFkZERlY29kZXJTaXplUHJlZml4ID0gYWRkRGVjb2RlclNpemVQcmVmaXg7XG5leHBvcnRzLmFkZEVuY29kZXJTZW50aW5lbCA9IGFkZEVuY29kZXJTZW50aW5lbDtcbmV4cG9ydHMuYWRkRW5jb2RlclNpemVQcmVmaXggPSBhZGRFbmNvZGVyU2l6ZVByZWZpeDtcbmV4cG9ydHMuYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyA9IGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWM7XG5leHBvcnRzLmFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyA9IGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYztcbmV4cG9ydHMuYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlID0gYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlO1xuZXhwb3J0cy5hc3NlcnRJc0ZpeGVkU2l6ZSA9IGFzc2VydElzRml4ZWRTaXplO1xuZXhwb3J0cy5hc3NlcnRJc1ZhcmlhYmxlU2l6ZSA9IGFzc2VydElzVmFyaWFibGVTaXplO1xuZXhwb3J0cy5jb21iaW5lQ29kZWMgPSBjb21iaW5lQ29kZWM7XG5leHBvcnRzLmNvbnRhaW5zQnl0ZXMgPSBjb250YWluc0J5dGVzO1xuZXhwb3J0cy5jcmVhdGVDb2RlYyA9IGNyZWF0ZUNvZGVjO1xuZXhwb3J0cy5jcmVhdGVEZWNvZGVyID0gY3JlYXRlRGVjb2RlcjtcbmV4cG9ydHMuY3JlYXRlRW5jb2RlciA9IGNyZWF0ZUVuY29kZXI7XG5leHBvcnRzLmZpeEJ5dGVzID0gZml4Qnl0ZXM7XG5leHBvcnRzLmZpeENvZGVjU2l6ZSA9IGZpeENvZGVjU2l6ZTtcbmV4cG9ydHMuZml4RGVjb2RlclNpemUgPSBmaXhEZWNvZGVyU2l6ZTtcbmV4cG9ydHMuZml4RW5jb2RlclNpemUgPSBmaXhFbmNvZGVyU2l6ZTtcbmV4cG9ydHMuZ2V0RW5jb2RlZFNpemUgPSBnZXRFbmNvZGVkU2l6ZTtcbmV4cG9ydHMuaXNGaXhlZFNpemUgPSBpc0ZpeGVkU2l6ZTtcbmV4cG9ydHMuaXNWYXJpYWJsZVNpemUgPSBpc1ZhcmlhYmxlU2l6ZTtcbmV4cG9ydHMubWVyZ2VCeXRlcyA9IG1lcmdlQnl0ZXM7XG5leHBvcnRzLm9mZnNldENvZGVjID0gb2Zmc2V0Q29kZWM7XG5leHBvcnRzLm9mZnNldERlY29kZXIgPSBvZmZzZXREZWNvZGVyO1xuZXhwb3J0cy5vZmZzZXRFbmNvZGVyID0gb2Zmc2V0RW5jb2RlcjtcbmV4cG9ydHMucGFkQnl0ZXMgPSBwYWRCeXRlcztcbmV4cG9ydHMucGFkTGVmdENvZGVjID0gcGFkTGVmdENvZGVjO1xuZXhwb3J0cy5wYWRMZWZ0RGVjb2RlciA9IHBhZExlZnREZWNvZGVyO1xuZXhwb3J0cy5wYWRMZWZ0RW5jb2RlciA9IHBhZExlZnRFbmNvZGVyO1xuZXhwb3J0cy5wYWRSaWdodENvZGVjID0gcGFkUmlnaHRDb2RlYztcbmV4cG9ydHMucGFkUmlnaHREZWNvZGVyID0gcGFkUmlnaHREZWNvZGVyO1xuZXhwb3J0cy5wYWRSaWdodEVuY29kZXIgPSBwYWRSaWdodEVuY29kZXI7XG5leHBvcnRzLnJlc2l6ZUNvZGVjID0gcmVzaXplQ29kZWM7XG5leHBvcnRzLnJlc2l6ZURlY29kZXIgPSByZXNpemVEZWNvZGVyO1xuZXhwb3J0cy5yZXNpemVFbmNvZGVyID0gcmVzaXplRW5jb2RlcjtcbmV4cG9ydHMucmV2ZXJzZUNvZGVjID0gcmV2ZXJzZUNvZGVjO1xuZXhwb3J0cy5yZXZlcnNlRGVjb2RlciA9IHJldmVyc2VEZWNvZGVyO1xuZXhwb3J0cy5yZXZlcnNlRW5jb2RlciA9IHJldmVyc2VFbmNvZGVyO1xuZXhwb3J0cy50cmFuc2Zvcm1Db2RlYyA9IHRyYW5zZm9ybUNvZGVjO1xuZXhwb3J0cy50cmFuc2Zvcm1EZWNvZGVyID0gdHJhbnNmb3JtRGVjb2RlcjtcbmV4cG9ydHMudHJhbnNmb3JtRW5jb2RlciA9IHRyYW5zZm9ybUVuY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmNqcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuY2pzLm1hcCJdLCJuYW1lcyI6WyJlcnJvcnMiLCJyZXF1aXJlIiwibWVyZ2VCeXRlcyIsImJ5dGVBcnJheXMiLCJub25FbXB0eUJ5dGVBcnJheXMiLCJmaWx0ZXIiLCJhcnIiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJ0b3RhbCIsInJlc3VsdCIsIm9mZnNldCIsImZvckVhY2giLCJzZXQiLCJwYWRCeXRlcyIsImJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJmaWxsIiwiZml4Qnl0ZXMiLCJzbGljZSIsImNvbnRhaW5zQnl0ZXMiLCJkYXRhIiwiZXZlcnkiLCJiIiwiaSIsImdldEVuY29kZWRTaXplIiwidmFsdWUiLCJlbmNvZGVyIiwiZml4ZWRTaXplIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImNyZWF0ZUVuY29kZXIiLCJPYmplY3QiLCJmcmVlemUiLCJlbmNvZGUiLCJ3cml0ZSIsImNyZWF0ZURlY29kZXIiLCJkZWNvZGVyIiwiZGVjb2RlIiwicmVhZCIsImNyZWF0ZUNvZGVjIiwiY29kZWMiLCJpc0ZpeGVkU2l6ZSIsImFzc2VydElzRml4ZWRTaXplIiwiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiaXNWYXJpYWJsZVNpemUiLCJhc3NlcnRJc1ZhcmlhYmxlU2l6ZSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJjb21iaW5lQ29kZWMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsImRlY29kZXJGaXhlZFNpemUiLCJlbmNvZGVyRml4ZWRTaXplIiwibWF4U2l6ZSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJkZWNvZGVyTWF4U2l6ZSIsImVuY29kZXJNYXhTaXplIiwiYWRkRW5jb2RlclNlbnRpbmVsIiwic2VudGluZWwiLCJlbmNvZGVyQnl0ZXMiLCJmaW5kU2VudGluZWxJbmRleCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwiLCJlbmNvZGVkQnl0ZXMiLCJoZXhFbmNvZGVkQnl0ZXMiLCJoZXhCeXRlcyIsImhleFNlbnRpbmVsIiwiYWRkRGVjb2RlclNlbnRpbmVsIiwiY2FuZGlkYXRlQnl0ZXMiLCJzZW50aW5lbEluZGV4IiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsImRlY29kZWRCeXRlcyIsImhleERlY29kZWRCeXRlcyIsInByZVNlbnRpbmVsQnl0ZXMiLCJhZGRDb2RlY1NlbnRpbmVsIiwiZmluZEluZGV4IiwiYnl0ZSIsImluZGV4Iiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImV4cGVjdGVkIiwiYnl0ZXNMZW5ndGgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiYWRkRW5jb2RlclNpemVQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhNYXhTaXplIiwiZW5jb2RlclNpemUiLCJhZGREZWNvZGVyU2l6ZVByZWZpeCIsImJpZ2ludFNpemUiLCJkZWNvZGVyT2Zmc2V0Iiwic2l6ZSIsIk51bWJlciIsImFkZENvZGVjU2l6ZVByZWZpeCIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsIm5ld09mZnNldCIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.cjs\n");

/***/ })

};
;