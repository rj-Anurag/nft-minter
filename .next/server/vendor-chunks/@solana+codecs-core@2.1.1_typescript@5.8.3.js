"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-core@2.1.1_typescript@5.8.3";
exports.ids = ["vendor-chunks/@solana+codecs-core@2.1.1_typescript@5.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.1.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.1.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.1.1_typescript@5.8.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjEuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMG5CO0FBRTFuQiw0QkFBNEI7QUFFNUIsZUFBZTtBQUNmLElBQUlZLGFBQWEsQ0FBQ0M7SUFDaEIsTUFBTUMscUJBQXFCRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsTUFBTTtJQUNoRSxJQUFJSCxtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9KLFdBQVdJLE1BQU0sR0FBR0osVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJSztJQUNqRDtJQUNBLElBQUlKLG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0gsa0JBQWtCLENBQUMsRUFBRTtJQUM5QjtJQUNBLE1BQU1LLGNBQWNMLG1CQUFtQk0sTUFBTSxDQUFDLENBQUNDLE9BQU9MLE1BQVFLLFFBQVFMLElBQUlDLE1BQU0sRUFBRTtJQUNsRixNQUFNSyxTQUFTLElBQUlKLFdBQVdDO0lBQzlCLElBQUlJLFNBQVM7SUFDYlQsbUJBQW1CVSxPQUFPLENBQUMsQ0FBQ1I7UUFDMUJNLE9BQU9HLEdBQUcsQ0FBQ1QsS0FBS087UUFDaEJBLFVBQVVQLElBQUlDLE1BQU07SUFDdEI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksV0FBVyxDQUFDQyxPQUFPVjtJQUNyQixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FB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QUFJQyxPQUFPO1FBQzFITyxPQUFPLENBQUNSLE9BQU9YLE9BQU9KLFNBQVdnQixRQUFRTyxLQUFLLENBQUNnRyxNQUFNeEcsUUFBUVgsT0FBT0o7SUFDdEU7QUFDRjtBQUNBLFNBQVN3SCxpQkFBaUIvRixPQUFPLEVBQUVnRyxHQUFHO0lBQ3BDLE9BQU9qRyxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNLENBQUNlLE9BQU9tRyxVQUFVLEdBQUd6RixRQUFRRSxJQUFJLENBQUN2QixPQUFPSjtZQUMvQyxPQUFPO2dCQUFDeUgsSUFBSTFHLE9BQU9YLE9BQU9KO2dCQUFTa0g7YUFBVTtRQUMvQztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxlQUFlN0YsS0FBSyxFQUFFMEYsS0FBSyxFQUFFRSxHQUFHO0lBQ3ZDLE9BQU83RixZQUFZO1FBQ2pCLEdBQUcwRixpQkFBaUJ6RixPQUFPMEYsTUFBTTtRQUNqQzVGLE1BQU04RixNQUFNRCxpQkFBaUIzRixPQUFPNEYsS0FBSzlGLElBQUksR0FBR0UsTUFBTUYsSUFBSTtJQUM1RDtBQUNGO0FBRXV2QixDQUN2dkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjEuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanM/ZjM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgbWVyZ2VCeXRlcyA9IChieXRlQXJyYXlzKSA9PiB7XG4gIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGgpO1xuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlQXJyYXlzLmxlbmd0aCA/IGJ5dGVBcnJheXNbMF0gOiBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vbkVtcHR5Qnl0ZUFycmF5c1swXTtcbiAgfVxuICBjb25zdCB0b3RhbExlbmd0aCA9IG5vbkVtcHR5Qnl0ZUFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIG5vbkVtcHR5Qnl0ZUFycmF5cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHBhZEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBieXRlcztcbiAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gIHBhZGRlZEJ5dGVzLnNldChieXRlcyk7XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn07XG52YXIgZml4Qnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4gcGFkQnl0ZXMoYnl0ZXMubGVuZ3RoIDw9IGxlbmd0aCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSwgbGVuZ3RoKTtcbmZ1bmN0aW9uIGNvbnRhaW5zQnl0ZXMoZGF0YSwgYnl0ZXMsIG9mZnNldCkge1xuICBjb25zdCBzbGljZSA9IG9mZnNldCA9PT0gMCAmJiBkYXRhLmxlbmd0aCA9PT0gYnl0ZXMubGVuZ3RoID8gZGF0YSA6IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlcy5sZW5ndGgpO1xuICBpZiAoc2xpY2UubGVuZ3RoICE9PSBieXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGJ5dGVzLmV2ZXJ5KChiLCBpKSA9PiBiID09PSBzbGljZVtpXSk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBlbmNvZGVyID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlcihlbmNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSk7XG4gICAgICBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoZGVjb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZGVjb2RlcixcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmNvZGVjLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBjb2RlYy5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBjb2RlYykpO1xuICAgICAgY29kZWMud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNGaXhlZFNpemUoY29kZWMpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gY29kZWMgJiYgdHlwZW9mIGNvZGVjLmZpeGVkU2l6ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRml4ZWRTaXplKGNvZGVjKSB7XG4gIGlmICghaXNGaXhlZFNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICByZXR1cm4gIWlzRml4ZWRTaXplKGNvZGVjKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIGlmICghaXNWYXJpYWJsZVNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBjb21iaW5lQ29kZWMoZW5jb2RlciwgZGVjb2Rlcikge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgIT09IGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIKTtcbiAgfVxuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5maXhlZFNpemUgIT09IGRlY29kZXIuZml4ZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2RlckZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUsXG4gICAgICBlbmNvZGVyRml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgIH0pO1xuICB9XG4gIGlmICghaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgIWlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIubWF4U2l6ZSAhPT0gZGVjb2Rlci5tYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJNYXhTaXplOiBkZWNvZGVyLm1heFNpemUsXG4gICAgICBlbmNvZGVyTWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmVuY29kZXIsXG4gICAgZGVjb2RlOiBkZWNvZGVyLmRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZXIuZW5jb2RlLFxuICAgIHJlYWQ6IGRlY29kZXIucmVhZCxcbiAgICB3cml0ZTogZW5jb2Rlci53cml0ZVxuICB9O1xufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2VudGluZWwoZW5jb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKGZpbmRTZW50aW5lbEluZGV4KGVuY29kZXJCeXRlcywgc2VudGluZWwpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCB7XG4gICAgICAgIGVuY29kZWRCeXRlczogZW5jb2RlckJ5dGVzLFxuICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNlbnRpbmVsLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHdyaXRlIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLmVuY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBlbmNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSArIHNlbnRpbmVsLmxlbmd0aCxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTZW50aW5lbChkZWNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjYW5kaWRhdGVCeXRlcyA9IG9mZnNldCA9PT0gMCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICBjb25zdCBzZW50aW5lbEluZGV4ID0gZmluZFNlbnRpbmVsSW5kZXgoY2FuZGlkYXRlQnl0ZXMsIHNlbnRpbmVsKTtcbiAgICBpZiAoc2VudGluZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCB7XG4gICAgICAgIGRlY29kZWRCeXRlczogY2FuZGlkYXRlQnl0ZXMsXG4gICAgICAgIGhleERlY29kZWRCeXRlczogaGV4Qnl0ZXMoY2FuZGlkYXRlQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByZVNlbnRpbmVsQnl0ZXMgPSBjYW5kaWRhdGVCeXRlcy5zbGljZSgwLCBzZW50aW5lbEluZGV4KTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKHByZVNlbnRpbmVsQnl0ZXMpLCBvZmZzZXQgKyBwcmVTZW50aW5lbEJ5dGVzLmxlbmd0aCArIHNlbnRpbmVsLmxlbmd0aF07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgcmVhZCB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5kZWNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICByZWFkXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTZW50aW5lbChjb2RlYywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSwgYWRkRGVjb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkpO1xufVxuZnVuY3Rpb24gZmluZFNlbnRpbmVsSW5kZXgoYnl0ZXMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBieXRlcy5maW5kSW5kZXgoKGJ5dGUsIGluZGV4LCBhcnIpID0+IHtcbiAgICBpZiAoc2VudGluZWwubGVuZ3RoID09PSAxKSByZXR1cm4gYnl0ZSA9PT0gc2VudGluZWxbMF07XG4gICAgcmV0dXJuIGNvbnRhaW5zQnl0ZXMoYXJyLCBzZW50aW5lbCwgaW5kZXgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhleEJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlcy5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBpZiAoYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGV4cGVjdGVkLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGJ5dGVzTGVuZ3RoIDwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIGV4cGVjdGVkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uLCBvZmZzZXQsIGJ5dGVzTGVuZ3RoKSB7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBvZmZzZXRcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNpemUtcHJlZml4LnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2l6ZVByZWZpeChlbmNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgb2Zmc2V0ID0gcHJlZml4LndyaXRlKGVuY29kZXJCeXRlcy5sZW5ndGgsIGJ5dGVzLCBvZmZzZXQpO1xuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBlbmNvZGVyLmZpeGVkU2l6ZSwgd3JpdGUgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZW5jb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShlbmNvZGVyKSA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGVuY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGVuY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyU2l6ZSA9IGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKTtcbiAgICAgIHJldHVybiBnZXRFbmNvZGVkU2l6ZShlbmNvZGVyU2l6ZSwgcHJlZml4KSArIGVuY29kZXJTaXplO1xuICAgIH0sXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2l6ZVByZWZpeChkZWNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgW2JpZ2ludFNpemUsIGRlY29kZXJPZmZzZXRdID0gcHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlcihiaWdpbnRTaXplKTtcbiAgICBvZmZzZXQgPSBkZWNvZGVyT2Zmc2V0O1xuICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICB9XG4gICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImFkZERlY29kZXJTaXplUHJlZml4XCIsIHNpemUsIGJ5dGVzKTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKGJ5dGVzKSwgb2Zmc2V0ICsgc2l6ZV07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBkZWNvZGVyLmZpeGVkU2l6ZSwgcmVhZCB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBkZWNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGRlY29kZXIpID8gZGVjb2Rlci5maXhlZFNpemUgOiBkZWNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZGVjb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZGVjb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LCByZWFkIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSwgYWRkRGVjb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCkpO1xufVxuXG4vLyBzcmMvZml4LWNvZGVjLXNpemUudHNcbmZ1bmN0aW9uIGZpeEVuY29kZXJTaXplKGVuY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB2YXJpYWJsZUJ5dGVBcnJheSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGZpeGVkQnl0ZUFycmF5ID0gdmFyaWFibGVCeXRlQXJyYXkubGVuZ3RoID4gZml4ZWRCeXRlcyA/IHZhcmlhYmxlQnl0ZUFycmF5LnNsaWNlKDAsIGZpeGVkQnl0ZXMpIDogdmFyaWFibGVCeXRlQXJyYXk7XG4gICAgICBieXRlcy5zZXQoZml4ZWRCeXRlQXJyYXksIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgZml4ZWRCeXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4RGVjb2RlclNpemUoZGVjb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiZml4Q29kZWNTaXplXCIsIGZpeGVkQnl0ZXMsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gZml4ZWRCeXRlcykge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZml4ZWRCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgYnl0ZXMgPSBmaXhCeXRlcyhieXRlcywgZGVjb2Rlci5maXhlZFNpemUpO1xuICAgICAgfVxuICAgICAgY29uc3QgW3ZhbHVlXSA9IGRlY29kZXIucmVhZChieXRlcywgMCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBmaXhlZEJ5dGVzXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4Q29kZWNTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZml4RW5jb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpLCBmaXhEZWNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcykpO1xufVxuXG4vLyBzcmMvb2Zmc2V0LWNvZGVjLnRzXG5mdW5jdGlvbiBvZmZzZXRFbmNvZGVyKGVuY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHBvc3RPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld1Bvc3RPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldERlY29kZXIoZGVjb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgcG9zdE9mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG5ld1Bvc3RPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXRDb2RlYyhjb2RlYywgY29uZmlnKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMob2Zmc2V0RW5jb2Rlcihjb2RlYywgY29uZmlnKSwgb2Zmc2V0RGVjb2Rlcihjb2RlYywgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgaWYgKGRpdmlzb3IgPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NpemUgPSByZXNpemUoZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAobmV3U2l6ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBuZXdTaXplLFxuICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVEZWNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUNvZGVjKGNvZGVjLCByZXNpemUpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXNpemVFbmNvZGVyKGNvZGVjLCByZXNpemUpLCByZXNpemVEZWNvZGVyKGNvZGVjLCByZXNpemUpKTtcbn1cblxuLy8gc3JjL3BhZC1jb2RlYy50c1xuZnVuY3Rpb24gcGFkTGVmdEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRMZWZ0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkTGVmdERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkUmlnaHRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRSaWdodERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuXG4vLyBzcmMvcmV2ZXJzZS1jb2RlYy50c1xuZnVuY3Rpb24gY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKHNvdXJjZSwgdGFyZ2V0X1dJTExfTVVUQVRFLCBzb3VyY2VPZmZzZXQsIHNvdXJjZUxlbmd0aCwgdGFyZ2V0T2Zmc2V0ID0gMCkge1xuICB3aGlsZSAoc291cmNlT2Zmc2V0IDwgLS1zb3VyY2VMZW5ndGgpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VMZW5ndGhdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VMZW5ndGggKyB0YXJnZXRPZmZzZXRdID0gbGVmdFZhbHVlO1xuICAgIHNvdXJjZU9mZnNldCsrO1xuICB9XG4gIGlmIChzb3VyY2VPZmZzZXQgPT09IHNvdXJjZUxlbmd0aCkge1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VFbmNvZGVyKGVuY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZW5jb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlRGVjb2RlcihkZWNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGRlY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgcmV2ZXJzZWRCeXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICByZXZlcnNlZEJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGRlY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY29kZXIucmVhZChyZXZlcnNlZEJ5dGVzLCBvZmZzZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXZlcnNlRW5jb2Rlcihjb2RlYyksIHJldmVyc2VEZWNvZGVyKGNvZGVjKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0tY29kZWMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUVuY29kZXIoZW5jb2RlciwgdW5tYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmlzVmFyaWFibGVTaXplKGVuY29kZXIpID8geyAuLi5lbmNvZGVyLCBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh1bm1hcCh2YWx1ZSkpIH0gOiBlbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IGVuY29kZXIud3JpdGUodW5tYXAodmFsdWUpLCBieXRlcywgb2Zmc2V0KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybURlY29kZXIoZGVjb2RlciwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gW21hcCh2YWx1ZSwgYnl0ZXMsIG9mZnNldCksIG5ld09mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvZGVjKGNvZGVjLCB1bm1hcCwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgLi4udHJhbnNmb3JtRW5jb2Rlcihjb2RlYywgdW5tYXApLFxuICAgIHJlYWQ6IG1hcCA/IHRyYW5zZm9ybURlY29kZXIoY29kZWMsIG1hcCkucmVhZCA6IGNvZGVjLnJlYWRcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZENvZGVjU2VudGluZWwsIGFkZENvZGVjU2l6ZVByZWZpeCwgYWRkRGVjb2RlclNlbnRpbmVsLCBhZGREZWNvZGVyU2l6ZVByZWZpeCwgYWRkRW5jb2RlclNlbnRpbmVsLCBhZGRFbmNvZGVyU2l6ZVByZWZpeCwgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UsIGFzc2VydElzRml4ZWRTaXplLCBhc3NlcnRJc1ZhcmlhYmxlU2l6ZSwgY29tYmluZUNvZGVjLCBjb250YWluc0J5dGVzLCBjcmVhdGVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRW5jb2RlciwgZml4Qnl0ZXMsIGZpeENvZGVjU2l6ZSwgZml4RGVjb2RlclNpemUsIGZpeEVuY29kZXJTaXplLCBnZXRFbmNvZGVkU2l6ZSwgaXNGaXhlZFNpemUsIGlzVmFyaWFibGVTaXplLCBtZXJnZUJ5dGVzLCBvZmZzZXRDb2RlYywgb2Zmc2V0RGVjb2Rlciwgb2Zmc2V0RW5jb2RlciwgcGFkQnl0ZXMsIHBhZExlZnRDb2RlYywgcGFkTGVmdERlY29kZXIsIHBhZExlZnRFbmNvZGVyLCBwYWRSaWdodENvZGVjLCBwYWRSaWdodERlY29kZXIsIHBhZFJpZ2h0RW5jb2RlciwgcmVzaXplQ29kZWMsIHJlc2l6ZURlY29kZXIsIHJlc2l6ZUVuY29kZXIsIHJldmVyc2VDb2RlYywgcmV2ZXJzZURlY29kZXIsIHJldmVyc2VFbmNvZGVyLCB0cmFuc2Zvcm1Db2RlYywgdHJhbnNmb3JtRGVjb2RlciwgdHJhbnNmb3JtRW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwiLCJtZXJnZUJ5dGVzIiwiYnl0ZUFycmF5cyIsIm5vbkVtcHR5Qnl0ZUFycmF5cyIsImZpbHRlciIsImFyciIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsInRvdGFsIiwicmVzdWx0Iiwib2Zmc2V0IiwiZm9yRWFjaCIsInNldCIsInBhZEJ5dGVzIiwiYnl0ZXMiLCJwYWRkZWRCeXRlcyIsImZpbGwiLCJmaXhCeXRlcyIsInNsaWNlIiwiY29udGFpbnNCeXRlcyIsImRhdGEiLCJldmVyeSIsImIiLCJpIiwiZ2V0RW5jb2RlZFNpemUiLCJ2YWx1ZSIsImVuY29kZXIiLCJmaXhlZFNpemUiLCJnZXRTaXplRnJvbVZhbHVlIiwiY3JlYXRlRW5jb2RlciIsIk9iamVjdCIsImZyZWV6ZSIsImVuY29kZSIsIndyaXRlIiwiY3JlYXRlRGVjb2RlciIsImRlY29kZXIiLCJkZWNvZGUiLCJyZWFkIiwiY3JlYXRlQ29kZWMiLCJjb2RlYyIsImlzRml4ZWRTaXplIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJpc1ZhcmlhYmxlU2l6ZSIsImFzc2VydElzVmFyaWFibGVTaXplIiwiY29tYmluZUNvZGVjIiwiZGVjb2RlckZpeGVkU2l6ZSIsImVuY29kZXJGaXhlZFNpemUiLCJtYXhTaXplIiwiZGVjb2Rlck1heFNpemUiLCJlbmNvZGVyTWF4U2l6ZSIsImFkZEVuY29kZXJTZW50aW5lbCIsInNlbnRpbmVsIiwiZW5jb2RlckJ5dGVzIiwiZmluZFNlbnRpbmVsSW5kZXgiLCJlbmNvZGVkQnl0ZXMiLCJoZXhFbmNvZGVkQnl0ZXMiLCJoZXhCeXRlcyIsImhleFNlbnRpbmVsIiwiYWRkRGVjb2RlclNlbnRpbmVsIiwiY2FuZGlkYXRlQnl0ZXMiLCJzZW50aW5lbEluZGV4IiwiZGVjb2RlZEJ5dGVzIiwiaGV4RGVjb2RlZEJ5dGVzIiwicHJlU2VudGluZWxCeXRlcyIsImFkZENvZGVjU2VudGluZWwiLCJmaW5kSW5kZXgiLCJieXRlIiwiaW5kZXgiLCJzdHIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiY29kZWNEZXNjcmlwdGlvbiIsImFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMiLCJleHBlY3RlZCIsImJ5dGVzTGVuZ3RoIiwiYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlIiwiYWRkRW5jb2RlclNpemVQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhNYXhTaXplIiwiZW5jb2RlclNpemUiLCJhZGREZWNvZGVyU2l6ZVByZWZpeCIsImJpZ2ludFNpemUiLCJkZWNvZGVyT2Zmc2V0Iiwic2l6ZSIsIk51bWJlciIsImFkZENvZGVjU2l6ZVByZWZpeCIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsIm5ld09mZnNldCIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.1.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ })

};
;