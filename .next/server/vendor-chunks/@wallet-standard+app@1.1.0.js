"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@wallet-standard+app@1.1.0";
exports.ids = ["vendor-chunks/@wallet-standard+app@1.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@wallet-standard+app@1.1.0/node_modules/@wallet-standard/app/lib/esm/wallets.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@wallet-standard+app@1.1.0/node_modules/@wallet-standard/app/lib/esm/wallets.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEPRECATED_getWallets: () => (/* binding */ DEPRECATED_getWallets),\n/* harmony export */   getWallets: () => (/* binding */ getWallets)\n/* harmony export */ });\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AppReadyEvent_detail;\nlet wallets = undefined;\nconst registeredWalletsSet = new Set();\nfunction addRegisteredWallet(wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.add(wallet);\n}\nfunction removeRegisteredWallet(wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.delete(wallet);\n}\nconst listeners = {};\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */ function getWallets() {\n    if (wallets) return wallets;\n    wallets = Object.freeze({\n        register,\n        get,\n        on\n    });\n    if (true) return wallets;\n    const api = Object.freeze({\n        register\n    });\n    try {\n        window.addEventListener(\"wallet-standard:register-wallet\", ({ detail: callback })=>callback(api));\n    } catch (error) {\n        console.error(\"wallet-standard:register-wallet event listener could not be added\\n\", error);\n    }\n    try {\n        window.dispatchEvent(new AppReadyEvent(api));\n    } catch (error) {\n        console.error(\"wallet-standard:app-ready event could not be dispatched\\n\", error);\n    }\n    return wallets;\n}\nfunction register(...wallets) {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet)=>!registeredWalletsSet.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length) return ()=>{};\n    wallets.forEach((wallet)=>addRegisteredWallet(wallet));\n    listeners[\"register\"]?.forEach((listener)=>guard(()=>listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister() {\n        wallets.forEach((wallet)=>removeRegisteredWallet(wallet));\n        listeners[\"unregister\"]?.forEach((listener)=>guard(()=>listener(...wallets)));\n    };\n}\nlet cachedWalletsArray;\nfunction get() {\n    if (!cachedWalletsArray) {\n        cachedWalletsArray = [\n            ...registeredWalletsSet\n        ];\n    }\n    return cachedWalletsArray;\n}\nfunction on(event, listener) {\n    listeners[event]?.push(listener) || (listeners[event] = [\n        listener\n    ]);\n    // Return a function that removes the event listener.\n    return function off() {\n        listeners[event] = listeners[event]?.filter((existingListener)=>listener !== existingListener);\n    };\n}\nfunction guard(callback) {\n    try {\n        callback();\n    } catch (error) {\n        console.error(error);\n    }\n}\nclass AppReadyEvent extends Event {\n    get detail() {\n        return __classPrivateFieldGet(this, _AppReadyEvent_detail, \"f\");\n    }\n    get type() {\n        return \"wallet-standard:app-ready\";\n    }\n    constructor(api){\n        super(\"wallet-standard:app-ready\", {\n            bubbles: false,\n            cancelable: false,\n            composed: false\n        });\n        _AppReadyEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _AppReadyEvent_detail, api, \"f\");\n    }\n    /** @deprecated */ preventDefault() {\n        throw new Error(\"preventDefault cannot be called\");\n    }\n    /** @deprecated */ stopImmediatePropagation() {\n        throw new Error(\"stopImmediatePropagation cannot be called\");\n    }\n    /** @deprecated */ stopPropagation() {\n        throw new Error(\"stopPropagation cannot be called\");\n    }\n}\n_AppReadyEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */ function DEPRECATED_getWallets() {\n    if (wallets) return wallets;\n    wallets = getWallets();\n    if (true) return wallets;\n    const callbacks = window.navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error(\"window.navigator.wallets is not an array\");\n        return wallets;\n    }\n    const { register } = wallets;\n    const push = (...callbacks)=>callbacks.forEach((callback)=>guard(()=>callback({\n                    register\n                })));\n    try {\n        Object.defineProperty(window.navigator, \"wallets\", {\n            value: Object.freeze({\n                push\n            })\n        });\n    } catch (error) {\n        console.error(\"window.navigator.wallets could not be set\");\n        return wallets;\n    }\n    push(...callbacks);\n    return wallets;\n} //# sourceMappingURL=wallets.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHdhbGxldC1zdGFuZGFyZCthcHBAMS4xLjAvbm9kZV9tb2R1bGVzL0B3YWxsZXQtc3RhbmRhcmQvYXBwL2xpYi9lc20vd2FsbGV0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUlBLHlCQUF5QixTQUFLLElBQUksU0FBSSxDQUFDQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ04sWUFBWUcsSUFBSUEsRUFBRUksS0FBSyxHQUFHTixNQUFNTyxHQUFHLENBQUNSO0FBQ3hGO0FBQ0EsSUFBSVMseUJBQXlCLFNBQUssSUFBSSxTQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFTSxLQUFLLEVBQUVMLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ04sVUFBVU8sU0FBU0osSUFBSUEsRUFBRUksS0FBSyxHQUFHQSxRQUFRTixNQUFNUyxHQUFHLENBQUNWLFVBQVVPLFFBQVNBO0FBQ3hHO0FBQ0Es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SSxFQUFFRSx1QkFBdUJpQixLQUFLO0lBQzdEO0lBQ0EsZ0JBQWdCLEdBQ2hCeUIsaUJBQWlCO1FBQ2IsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsZ0JBQWdCLEdBQ2hCQywyQkFBMkI7UUFDdkIsTUFBTSxJQUFJRCxNQUFNO0lBQ3BCO0lBQ0EsZ0JBQWdCLEdBQ2hCRSxrQkFBa0I7UUFDZCxNQUFNLElBQUlGLE1BQU07SUFDcEI7QUFDSjtBQUNBM0Msd0JBQXdCLElBQUk4QztBQUM1Qjs7OztDQUlDLEdBQ00sU0FBU0M7SUFDWixJQUFJOUMsU0FDQSxPQUFPQTtJQUNYQSxVQUFVVztJQUNWLElBQUksSUFBa0IsRUFDbEIsT0FBT1g7SUFDWCxNQUFNK0MsWUFBWTlCLE9BQU8rQixTQUFTLENBQUNoRCxPQUFPLElBQUksRUFBRTtJQUNoRCxJQUFJLENBQUNpRCxNQUFNQyxPQUFPLENBQUNILFlBQVk7UUFDM0J6QixRQUFRRCxLQUFLLENBQUM7UUFDZCxPQUFPckI7SUFDWDtJQUNBLE1BQU0sRUFBRWMsUUFBUSxFQUFFLEdBQUdkO0lBQ3JCLE1BQU1nQyxPQUFPLENBQUMsR0FBR2UsWUFBY0EsVUFBVXBCLE9BQU8sQ0FBQyxDQUFDUCxXQUFhUyxNQUFNLElBQU1ULFNBQVM7b0JBQUVOO2dCQUFTO0lBQy9GLElBQUk7UUFDQUYsT0FBT3VDLGNBQWMsQ0FBQ2xDLE9BQU8rQixTQUFTLEVBQUUsV0FBVztZQUMvQ3JELE9BQU9pQixPQUFPQyxNQUFNLENBQUM7Z0JBQUVtQjtZQUFLO1FBQ2hDO0lBQ0osRUFDQSxPQUFPWCxPQUFPO1FBQ1ZDLFFBQVFELEtBQUssQ0FBQztRQUNkLE9BQU9yQjtJQUNYO0lBQ0FnQyxRQUFRZTtJQUNSLE9BQU8vQztBQUNYLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2FsbGV0LXN0YW5kYXJkK2FwcEAxLjEuMC9ub2RlX21vZHVsZXMvQHdhbGxldC1zdGFuZGFyZC9hcHAvbGliL2VzbS93YWxsZXRzLmpzPzYwNmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9BcHBSZWFkeUV2ZW50X2RldGFpbDtcbmxldCB3YWxsZXRzID0gdW5kZWZpbmVkO1xuY29uc3QgcmVnaXN0ZXJlZFdhbGxldHNTZXQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBhZGRSZWdpc3RlcmVkV2FsbGV0KHdhbGxldCkge1xuICAgIGNhY2hlZFdhbGxldHNBcnJheSA9IHVuZGVmaW5lZDtcbiAgICByZWdpc3RlcmVkV2FsbGV0c1NldC5hZGQod2FsbGV0KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlZ2lzdGVyZWRXYWxsZXQod2FsbGV0KSB7XG4gICAgY2FjaGVkV2FsbGV0c0FycmF5ID0gdW5kZWZpbmVkO1xuICAgIHJlZ2lzdGVyZWRXYWxsZXRzU2V0LmRlbGV0ZSh3YWxsZXQpO1xufVxuY29uc3QgbGlzdGVuZXJzID0ge307XG4vKipcbiAqIEdldCBhbiBBUEkgZm9yIHtAbGluayBXYWxsZXRzLmdldCB8IGdldHRpbmd9LCB7QGxpbmsgV2FsbGV0cy5vbiB8IGxpc3RlbmluZyBmb3J9LCBhbmRcbiAqIHtAbGluayBXYWxsZXRzLnJlZ2lzdGVyIHwgcmVnaXN0ZXJpbmd9IHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldhbGxldCB8IFdhbGxldHN9LlxuICpcbiAqIFdoZW4gY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSAtLVxuICpcbiAqIFRoaXMgZGlzcGF0Y2hlcyBhIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldpbmRvd0FwcFJlYWR5RXZlbnR9IHRvIG5vdGlmeSBlYWNoIFdhbGxldCB0aGF0IHRoZSBhcHAgaXMgcmVhZHlcbiAqIHRvIHJlZ2lzdGVyIGl0LlxuICpcbiAqIFRoaXMgYWxzbyBhZGRzIGEgbGlzdGVuZXIgZm9yIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldpbmRvd1JlZ2lzdGVyV2FsbGV0RXZlbnR9IHRvIGxpc3RlbiBmb3IgYSBub3RpZmljYXRpb25cbiAqIGZyb20gZWFjaCBXYWxsZXQgdGhhdCB0aGUgV2FsbGV0IGlzIHJlYWR5IHRvIGJlIHJlZ2lzdGVyZWQgYnkgdGhlIGFwcC5cbiAqXG4gKiBUaGlzIGNvbWJpbmF0aW9uIG9mIGV2ZW50IGRpc3BhdGNoIGFuZCBsaXN0ZW5lciBndWFyYW50ZWVzIHRoYXQgZWFjaCBXYWxsZXQgd2lsbCBiZSByZWdpc3RlcmVkIHN5bmNocm9ub3VzbHkgYXMgc29vblxuICogYXMgdGhlIGFwcCBpcyByZWFkeSB3aGV0aGVyIHRoZSBhcHAgbG9hZHMgYmVmb3JlIG9yIGFmdGVyIGVhY2ggV2FsbGV0LlxuICpcbiAqIEByZXR1cm4gQVBJIGZvciBnZXR0aW5nLCBsaXN0ZW5pbmcgZm9yLCBhbmQgcmVnaXN0ZXJpbmcgV2FsbGV0cy5cbiAqXG4gKiBAZ3JvdXAgQXBwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXYWxsZXRzKCkge1xuICAgIGlmICh3YWxsZXRzKVxuICAgICAgICByZXR1cm4gd2FsbGV0cztcbiAgICB3YWxsZXRzID0gT2JqZWN0LmZyZWV6ZSh7IHJlZ2lzdGVyLCBnZXQsIG9uIH0pO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgY29uc3QgYXBpID0gT2JqZWN0LmZyZWV6ZSh7IHJlZ2lzdGVyIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3YWxsZXQtc3RhbmRhcmQ6cmVnaXN0ZXItd2FsbGV0JywgKHsgZGV0YWlsOiBjYWxsYmFjayB9KSA9PiBjYWxsYmFjayhhcGkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dhbGxldC1zdGFuZGFyZDpyZWdpc3Rlci13YWxsZXQgZXZlbnQgbGlzdGVuZXIgY291bGQgbm90IGJlIGFkZGVkXFxuJywgZXJyb3IpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQXBwUmVhZHlFdmVudChhcGkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dhbGxldC1zdGFuZGFyZDphcHAtcmVhZHkgZXZlbnQgY291bGQgbm90IGJlIGRpc3BhdGNoZWRcXG4nLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRzO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXIoLi4ud2FsbGV0cykge1xuICAgIC8vIEZpbHRlciBvdXQgd2FsbGV0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgLy8gVGhpcyBwcmV2ZW50cyB0aGUgc2FtZSB3YWxsZXQgZnJvbSBiZWluZyByZWdpc3RlcmVkIHR3aWNlLCBidXQgaXQgYWxzbyBwcmV2ZW50cyB3YWxsZXRzIGZyb20gYmVpbmdcbiAgICAvLyB1bnJlZ2lzdGVyZWQgYnkgcmV1c2luZyBhIHJlZmVyZW5jZSB0byB0aGUgd2FsbGV0IHRvIG9idGFpbiB0aGUgdW5yZWdpc3RlciBmdW5jdGlvbiBmb3IgaXQuXG4gICAgd2FsbGV0cyA9IHdhbGxldHMuZmlsdGVyKCh3YWxsZXQpID0+ICFyZWdpc3RlcmVkV2FsbGV0c1NldC5oYXMod2FsbGV0KSk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5ldyB3YWxsZXRzIHRvIHJlZ2lzdGVyLCBqdXN0IHJldHVybiBhIG5vLW9wIHVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGlmICghd2FsbGV0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgd2FsbGV0cy5mb3JFYWNoKCh3YWxsZXQpID0+IGFkZFJlZ2lzdGVyZWRXYWxsZXQod2FsbGV0KSk7XG4gICAgbGlzdGVuZXJzWydyZWdpc3RlciddPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gZ3VhcmQoKCkgPT4gbGlzdGVuZXIoLi4ud2FsbGV0cykpKTtcbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHVucmVnaXN0ZXJzIHRoZSByZWdpc3RlcmVkIHdhbGxldHMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHdhbGxldHMuZm9yRWFjaCgod2FsbGV0KSA9PiByZW1vdmVSZWdpc3RlcmVkV2FsbGV0KHdhbGxldCkpO1xuICAgICAgICBsaXN0ZW5lcnNbJ3VucmVnaXN0ZXInXT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGd1YXJkKCgpID0+IGxpc3RlbmVyKC4uLndhbGxldHMpKSk7XG4gICAgfTtcbn1cbmxldCBjYWNoZWRXYWxsZXRzQXJyYXk7XG5mdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKCFjYWNoZWRXYWxsZXRzQXJyYXkpIHtcbiAgICAgICAgY2FjaGVkV2FsbGV0c0FycmF5ID0gWy4uLnJlZ2lzdGVyZWRXYWxsZXRzU2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFdhbGxldHNBcnJheTtcbn1cbmZ1bmN0aW9uIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyc1tldmVudF0/LnB1c2gobGlzdGVuZXIpIHx8IChsaXN0ZW5lcnNbZXZlbnRdID0gW2xpc3RlbmVyXSk7XG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICByZXR1cm4gZnVuY3Rpb24gb2ZmKCkge1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzW2V2ZW50XT8uZmlsdGVyKChleGlzdGluZ0xpc3RlbmVyKSA9PiBsaXN0ZW5lciAhPT0gZXhpc3RpbmdMaXN0ZW5lcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGd1YXJkKGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmNsYXNzIEFwcFJlYWR5RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgZ2V0IGRldGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcFJlYWR5RXZlbnRfZGV0YWlsLCBcImZcIik7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gJ3dhbGxldC1zdGFuZGFyZDphcHAtcmVhZHknO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhcGkpIHtcbiAgICAgICAgc3VwZXIoJ3dhbGxldC1zdGFuZGFyZDphcHAtcmVhZHknLCB7XG4gICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29tcG9zZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgX0FwcFJlYWR5RXZlbnRfZGV0YWlsLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BcHBSZWFkeUV2ZW50X2RldGFpbCwgYXBpLCBcImZcIik7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZlbnREZWZhdWx0IGNhbm5vdCBiZSBjYWxsZWQnKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiBjYW5ub3QgYmUgY2FsbGVkJyk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdG9wUHJvcGFnYXRpb24gY2Fubm90IGJlIGNhbGxlZCcpO1xuICAgIH1cbn1cbl9BcHBSZWFkeUV2ZW50X2RldGFpbCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZ2V0V2FsbGV0c30gaW5zdGVhZC5cbiAqXG4gKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gREVQUkVDQVRFRF9nZXRXYWxsZXRzKCkge1xuICAgIGlmICh3YWxsZXRzKVxuICAgICAgICByZXR1cm4gd2FsbGV0cztcbiAgICB3YWxsZXRzID0gZ2V0V2FsbGV0cygpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gd2luZG93Lm5hdmlnYXRvci53YWxsZXRzIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dpbmRvdy5uYXZpZ2F0b3Iud2FsbGV0cyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHdhbGxldHM7XG4gICAgY29uc3QgcHVzaCA9ICguLi5jYWxsYmFja3MpID0+IGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gZ3VhcmQoKCkgPT4gY2FsbGJhY2soeyByZWdpc3RlciB9KSkpO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cubmF2aWdhdG9yLCAnd2FsbGV0cycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHsgcHVzaCB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3aW5kb3cubmF2aWdhdG9yLndhbGxldHMgY291bGQgbm90IGJlIHNldCcpO1xuICAgICAgICByZXR1cm4gd2FsbGV0cztcbiAgICB9XG4gICAgcHVzaCguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB3YWxsZXRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0cy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfQXBwUmVhZHlFdmVudF9kZXRhaWwiLCJ3YWxsZXRzIiwidW5kZWZpbmVkIiwicmVnaXN0ZXJlZFdhbGxldHNTZXQiLCJTZXQiLCJhZGRSZWdpc3RlcmVkV2FsbGV0Iiwid2FsbGV0IiwiY2FjaGVkV2FsbGV0c0FycmF5IiwiYWRkIiwicmVtb3ZlUmVnaXN0ZXJlZFdhbGxldCIsImRlbGV0ZSIsImxpc3RlbmVycyIsImdldFdhbGxldHMiLCJPYmplY3QiLCJmcmVlemUiLCJyZWdpc3RlciIsIm9uIiwiYXBpIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRldGFpbCIsImNhbGxiYWNrIiwiZXJyb3IiLCJjb25zb2xlIiwiZGlzcGF0Y2hFdmVudCIsIkFwcFJlYWR5RXZlbnQiLCJmaWx0ZXIiLCJsZW5ndGgiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJndWFyZCIsInVucmVnaXN0ZXIiLCJldmVudCIsInB1c2giLCJvZmYiLCJleGlzdGluZ0xpc3RlbmVyIiwiRXZlbnQiLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNvbXBvc2VkIiwicHJldmVudERlZmF1bHQiLCJFcnJvciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsIldlYWtNYXAiLCJERVBSRUNBVEVEX2dldFdhbGxldHMiLCJjYWxsYmFja3MiLCJuYXZpZ2F0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJkZWZpbmVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@wallet-standard+app@1.1.0/node_modules/@wallet-standard/app/lib/esm/wallets.js\n");

/***/ })

};
;