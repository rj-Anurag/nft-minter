"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/csv-parse@4.16.3";
exports.ids = ["vendor-chunks/csv-parse@4.16.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/ResizeableBuffer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/ResizeableBuffer.js ***!
  \********************************************************************************************/
/***/ ((module) => {

eval("\nclass ResizeableBuffer {\n    constructor(size = 100){\n        this.size = size;\n        this.length = 0;\n        this.buf = Buffer.alloc(size);\n    }\n    prepend(val) {\n        if (Buffer.isBuffer(val)) {\n            const length = this.length + val.length;\n            if (length >= this.size) {\n                this.resize();\n                if (length >= this.size) {\n                    throw Error(\"INVALID_BUFFER_STATE\");\n                }\n            }\n            const buf = this.buf;\n            this.buf = Buffer.alloc(this.size);\n            val.copy(this.buf, 0);\n            buf.copy(this.buf, val.length);\n            this.length += val.length;\n        } else {\n            const length = this.length++;\n            if (length === this.size) {\n                this.resize();\n            }\n            const buf = this.clone();\n            this.buf[0] = val;\n            buf.copy(this.buf, 1, 0, length);\n        }\n    }\n    append(val) {\n        const length = this.length++;\n        if (length === this.size) {\n            this.resize();\n        }\n        this.buf[length] = val;\n    }\n    clone() {\n        return Buffer.from(this.buf.slice(0, this.length));\n    }\n    resize() {\n        const length = this.length;\n        this.size = this.size * 2;\n        const buf = Buffer.alloc(this.size);\n        this.buf.copy(buf, 0, 0, length);\n        this.buf = buf;\n    }\n    toString(encoding) {\n        if (encoding) {\n            return this.buf.slice(0, this.length).toString(encoding);\n        } else {\n            return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n        }\n    }\n    toJSON() {\n        return this.toString(\"utf8\");\n    }\n    reset() {\n        this.length = 0;\n    }\n}\nmodule.exports = ResizeableBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY3N2LXBhcnNlQDQuMTYuMy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9SZXNpemVhYmxlQnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7QUFFQSxNQUFNQTtJQUNKQyxZQUFZQyxPQUFLLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxPQUFPQyxLQUFLLENBQUNKO0lBQzFCO0lBQ0FLLFFBQVFDLEdBQUcsRUFBQztRQUNWLElBQUdILE9BQU9JLFFBQVEsQ0FBQ0QsTUFBSztZQUN0QixNQUFNTCxTQUFTLElBQUksQ0FBQ0EsTUFBTSxHQUFHSyxJQUFJTCxNQUFNO1lBQ3ZDLElBQUdBLFVBQVUsSUFBSSxDQUFDRCxJQUFJLEVBQUM7Z0JBQ3JCLElBQUksQ0FBQ1EsTUFBTTtnQkFDWCxJQUFHUCxVQUFVLElBQUksQ0FBQ0QsSUFBSSxFQUFDO29CQUNyQixNQUFNUyxNQUFNO2dCQUNkO1lBQ0Y7WUFDQSxNQUFNUCxNQUFNLElBQUksQ0FBQ0EsR0FBRztZQUNwQixJQUFJLENBQUNBLEdBQUcsR0FBR0MsT0FBT0MsS0FBSyxDQUFDLElBQUksQ0FBQ0osSUFBSTtZQUNqQ00sSUFBSUksSUFBSSxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFO1lBQ25CQSxJQUFJUSxJQUFJLENBQUMsSUFBSSxDQUFDUixHQUFHLEVBQUVJLElBQUlMLE1BQU07WUFDN0IsSUFBSSxDQUFDQSxNQUFNLElBQUlLLElBQUlMLE1BQU07UUFDM0IsT0FBSztZQUNILE1BQU1BLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1lBQzFCLElBQUdBLFdBQVcsSUFBSSxDQUFDRCxJQUFJLEVBQUM7Z0JBQ3RCLElBQUksQ0FBQ1EsTUFBTTtZQUNiO1lBQ0EsTUFBTU4sTUFBTSxJQUFJLENBQUNTLEtBQUs7WUFDdEIsSUFBSSxDQUFDVCxHQUFHLENBQUMsRUFBRSxHQUFHSTtZQUNkSixJQUFJUSxJQUFJLENBQUMsSUFBSSxDQUFDUixHQUFHLEVBQUMsR0FBRyxHQUFHRDtRQUMxQjtJQUNGO0lBQ0FXLE9BQU9OLEdBQUcsRUFBQztRQUNULE1BQU1MLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLElBQUdBLFdBQVcsSUFBSSxDQUFDRCxJQUFJLEVBQUM7WUFDdEIsSUFBSSxDQUFDUSxNQUFNO1FBQ2I7UUFDQSxJQUFJLENBQUNOLEdBQUcsQ0FBQ0QsT0FBTyxHQUFHSztJQUNyQjtJQUNBSyxRQUFPO1FBQ0wsT0FBT1IsT0FBT1UsSUFBSSxDQUFDLElBQUksQ0FBQ1gsR0FBRyxDQUFDWSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUNiLE1BQU07SUFDbEQ7SUFDQU8sU0FBUTtRQUNOLE1BQU1QLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxHQUFHO1FBQ3hCLE1BQU1FLE1BQU1DLE9BQU9DLEtBQUssQ0FBQyxJQUFJLENBQUNKLElBQUk7UUFDbEMsSUFBSSxDQUFDRSxHQUFHLENBQUNRLElBQUksQ0FBQ1IsS0FBSSxHQUFHLEdBQUdEO1FBQ3hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtJQUNiO0lBQ0FhLFNBQVNDLFFBQVEsRUFBQztRQUNoQixJQUFHQSxVQUFTO1lBQ1YsT0FBTyxJQUFJLENBQUNkLEdBQUcsQ0FBQ1ksS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDYixNQUFNLEVBQUVjLFFBQVEsQ0FBQ0M7UUFDakQsT0FBSztZQUNILE9BQU9DLFdBQVdDLFNBQVMsQ0FBQ0osS0FBSyxDQUFDSyxJQUFJLENBQUMsSUFBSSxDQUFDakIsR0FBRyxDQUFDWSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUNiLE1BQU07UUFDdEU7SUFDRjtJQUNBbUIsU0FBUTtRQUNOLE9BQU8sSUFBSSxDQUFDTCxRQUFRLENBQUM7SUFDdkI7SUFDQU0sUUFBTztRQUNMLElBQUksQ0FBQ3BCLE1BQU0sR0FBRztJQUNoQjtBQUNGO0FBRUFxQixPQUFPQyxPQUFPLEdBQUd6QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vY3N2LXBhcnNlQDQuMTYuMy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9SZXNpemVhYmxlQnVmZmVyLmpzPzhhMjciXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmNsYXNzIFJlc2l6ZWFibGVCdWZmZXJ7XG4gIGNvbnN0cnVjdG9yKHNpemU9MTAwKXtcbiAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2Moc2l6ZSlcbiAgfVxuICBwcmVwZW5kKHZhbCl7XG4gICAgaWYoQnVmZmVyLmlzQnVmZmVyKHZhbCkpe1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGggKyB2YWwubGVuZ3RoXG4gICAgICBpZihsZW5ndGggPj0gdGhpcy5zaXplKXtcbiAgICAgICAgdGhpcy5yZXNpemUoKVxuICAgICAgICBpZihsZW5ndGggPj0gdGhpcy5zaXplKXtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSU5WQUxJRF9CVUZGRVJfU1RBVEUnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSB0aGlzLmJ1ZlxuICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2ModGhpcy5zaXplKVxuICAgICAgdmFsLmNvcHkodGhpcy5idWYsIDApXG4gICAgICBidWYuY29weSh0aGlzLmJ1ZiwgdmFsLmxlbmd0aClcbiAgICAgIHRoaXMubGVuZ3RoICs9IHZhbC5sZW5ndGhcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKytcbiAgICAgIGlmKGxlbmd0aCA9PT0gdGhpcy5zaXplKXtcbiAgICAgICAgdGhpcy5yZXNpemUoKVxuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5jbG9uZSgpXG4gICAgICB0aGlzLmJ1ZlswXSA9IHZhbFxuICAgICAgYnVmLmNvcHkodGhpcy5idWYsMSwgMCwgbGVuZ3RoKVxuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsKXtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCsrXG4gICAgaWYobGVuZ3RoID09PSB0aGlzLnNpemUpe1xuICAgICAgdGhpcy5yZXNpemUoKVxuICAgIH1cbiAgICB0aGlzLmJ1ZltsZW5ndGhdID0gdmFsXG4gIH1cbiAgY2xvbmUoKXtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpKVxuICB9XG4gIHJlc2l6ZSgpe1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgdGhpcy5zaXplID0gdGhpcy5zaXplICogMlxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0aGlzLnNpemUpXG4gICAgdGhpcy5idWYuY29weShidWYsMCwgMCwgbGVuZ3RoKVxuICAgIHRoaXMuYnVmID0gYnVmXG4gIH1cbiAgdG9TdHJpbmcoZW5jb2Rpbmcpe1xuICAgIGlmKGVuY29kaW5nKXtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkudG9TdHJpbmcoZW5jb2RpbmcpXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkpXG4gICAgfVxuICB9XG4gIHRvSlNPTigpe1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4JylcbiAgfVxuICByZXNldCgpe1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzaXplYWJsZUJ1ZmZlclxuIl0sIm5hbWVzIjpbIlJlc2l6ZWFibGVCdWZmZXIiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJsZW5ndGgiLCJidWYiLCJCdWZmZXIiLCJhbGxvYyIsInByZXBlbmQiLCJ2YWwiLCJpc0J1ZmZlciIsInJlc2l6ZSIsIkVycm9yIiwiY29weSIsImNsb25lIiwiYXBwZW5kIiwiZnJvbSIsInNsaWNlIiwidG9TdHJpbmciLCJlbmNvZGluZyIsIlVpbnQ4QXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwidG9KU09OIiwicmVzZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/ResizeableBuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/index.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/ \nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\nconst ResizeableBuffer = __webpack_require__(/*! ./ResizeableBuffer */ \"(ssr)/./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/ResizeableBuffer.js\");\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9;\nconst nl = 10 // \\n, 0x0A in hexadecimal, 10 in decimal\n;\nconst np = 12;\nconst cr = 13 // \\r, 0x0D in hexad√©cimal, 13 in decimal\n;\nconst space = 32;\nconst boms = {\n    // Note, the following are equals:\n    // Buffer.from(\"\\ufeff\")\n    // Buffer.from([239, 187, 191])\n    // Buffer.from('EFBBBF', 'hex')\n    \"utf8\": Buffer.from([\n        239,\n        187,\n        191\n    ]),\n    // Note, the following are equals:\n    // Buffer.from \"\\ufeff\", 'utf16le\n    // Buffer.from([255, 254])\n    \"utf16le\": Buffer.from([\n        255,\n        254\n    ])\n};\nclass Parser extends Transform {\n    constructor(opts = {}){\n        super({\n            ...{\n                readableObjectMode: true\n            },\n            ...opts,\n            encoding: null\n        });\n        this.__originalOptions = opts;\n        this.__normalizeOptions(opts);\n    }\n    __normalizeOptions(opts) {\n        const options = {};\n        // Merge with user options\n        for(let opt in opts){\n            options[underscore(opt)] = opts[opt];\n        }\n        // Normalize option `encoding`\n        // Note: defined first because other options depends on it\n        // to convert chars/strings into buffers.\n        if (options.encoding === undefined || options.encoding === true) {\n            options.encoding = \"utf8\";\n        } else if (options.encoding === null || options.encoding === false) {\n            options.encoding = null;\n        } else if (typeof options.encoding !== \"string\" && options.encoding !== null) {\n            throw new CsvError(\"CSV_INVALID_OPTION_ENCODING\", [\n                \"Invalid option encoding:\",\n                \"encoding must be a string or null to return a buffer,\",\n                `got ${JSON.stringify(options.encoding)}`\n            ], options);\n        }\n        // Normalize option `bom`\n        if (options.bom === undefined || options.bom === null || options.bom === false) {\n            options.bom = false;\n        } else if (options.bom !== true) {\n            throw new CsvError(\"CSV_INVALID_OPTION_BOM\", [\n                \"Invalid option bom:\",\n                \"bom must be true,\",\n                `got ${JSON.stringify(options.bom)}`\n            ], options);\n        }\n        // Normalize option `cast`\n        let fnCastField = null;\n        if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === \"\") {\n            options.cast = undefined;\n        } else if (typeof options.cast === \"function\") {\n            fnCastField = options.cast;\n            options.cast = true;\n        } else if (options.cast !== true) {\n            throw new CsvError(\"CSV_INVALID_OPTION_CAST\", [\n                \"Invalid option cast:\",\n                \"cast must be true or a function,\",\n                `got ${JSON.stringify(options.cast)}`\n            ], options);\n        }\n        // Normalize option `cast_date`\n        if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === \"\") {\n            options.cast_date = false;\n        } else if (options.cast_date === true) {\n            options.cast_date = function(value) {\n                const date = Date.parse(value);\n                return !isNaN(date) ? new Date(date) : value;\n            };\n        } else {\n            throw new CsvError(\"CSV_INVALID_OPTION_CAST_DATE\", [\n                \"Invalid option cast_date:\",\n                \"cast_date must be true or a function,\",\n                `got ${JSON.stringify(options.cast_date)}`\n            ], options);\n        }\n        // Normalize option `columns`\n        let fnFirstLineToHeaders = null;\n        if (options.columns === true) {\n            // Fields in the first line are converted as-is to columns\n            fnFirstLineToHeaders = undefined;\n        } else if (typeof options.columns === \"function\") {\n            fnFirstLineToHeaders = options.columns;\n            options.columns = true;\n        } else if (Array.isArray(options.columns)) {\n            options.columns = normalizeColumnsArray(options.columns);\n        } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n            options.columns = false;\n        } else {\n            throw new CsvError(\"CSV_INVALID_OPTION_COLUMNS\", [\n                \"Invalid option columns:\",\n                \"expect an array, a function or true,\",\n                `got ${JSON.stringify(options.columns)}`\n            ], options);\n        }\n        // Normalize option `columns_duplicates_to_array`\n        if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n            options.columns_duplicates_to_array = false;\n        } else if (options.columns_duplicates_to_array !== true) {\n            throw new CsvError(\"CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY\", [\n                \"Invalid option columns_duplicates_to_array:\",\n                \"expect an boolean,\",\n                `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n            ], options);\n        } else if (options.columns === false) {\n            throw new CsvError(\"CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY\", [\n                \"Invalid option columns_duplicates_to_array:\",\n                \"the `columns` mode must be activated.\"\n            ], options);\n        }\n        // Normalize option `comment`\n        if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === \"\") {\n            options.comment = null;\n        } else {\n            if (typeof options.comment === \"string\") {\n                options.comment = Buffer.from(options.comment, options.encoding);\n            }\n            if (!Buffer.isBuffer(options.comment)) {\n                throw new CsvError(\"CSV_INVALID_OPTION_COMMENT\", [\n                    \"Invalid option comment:\",\n                    \"comment must be a buffer or a string,\",\n                    `got ${JSON.stringify(options.comment)}`\n                ], options);\n            }\n        }\n        // Normalize option `delimiter`\n        const delimiter_json = JSON.stringify(options.delimiter);\n        if (!Array.isArray(options.delimiter)) options.delimiter = [\n            options.delimiter\n        ];\n        if (options.delimiter.length === 0) {\n            throw new CsvError(\"CSV_INVALID_OPTION_DELIMITER\", [\n                \"Invalid option delimiter:\",\n                \"delimiter must be a non empty string or buffer or array of string|buffer,\",\n                `got ${delimiter_json}`\n            ], options);\n        }\n        options.delimiter = options.delimiter.map(function(delimiter) {\n            if (delimiter === undefined || delimiter === null || delimiter === false) {\n                return Buffer.from(\",\", options.encoding);\n            }\n            if (typeof delimiter === \"string\") {\n                delimiter = Buffer.from(delimiter, options.encoding);\n            }\n            if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n                throw new CsvError(\"CSV_INVALID_OPTION_DELIMITER\", [\n                    \"Invalid option delimiter:\",\n                    \"delimiter must be a non empty string or buffer or array of string|buffer,\",\n                    `got ${delimiter_json}`\n                ], options);\n            }\n            return delimiter;\n        });\n        // Normalize option `escape`\n        if (options.escape === undefined || options.escape === true) {\n            options.escape = Buffer.from('\"', options.encoding);\n        } else if (typeof options.escape === \"string\") {\n            options.escape = Buffer.from(options.escape, options.encoding);\n        } else if (options.escape === null || options.escape === false) {\n            options.escape = null;\n        }\n        if (options.escape !== null) {\n            if (!Buffer.isBuffer(options.escape)) {\n                throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n            }\n        }\n        // Normalize option `from`\n        if (options.from === undefined || options.from === null) {\n            options.from = 1;\n        } else {\n            if (typeof options.from === \"string\" && /\\d+/.test(options.from)) {\n                options.from = parseInt(options.from);\n            }\n            if (Number.isInteger(options.from)) {\n                if (options.from < 0) {\n                    throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n                }\n            } else {\n                throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n            }\n        }\n        // Normalize option `from_line`\n        if (options.from_line === undefined || options.from_line === null) {\n            options.from_line = 1;\n        } else {\n            if (typeof options.from_line === \"string\" && /\\d+/.test(options.from_line)) {\n                options.from_line = parseInt(options.from_line);\n            }\n            if (Number.isInteger(options.from_line)) {\n                if (options.from_line <= 0) {\n                    throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n                }\n            } else {\n                throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n            }\n        }\n        // Normalize options `ignore_last_delimiters`\n        if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {\n            options.ignore_last_delimiters = false;\n        } else if (typeof options.ignore_last_delimiters === \"number\") {\n            options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n            if (options.ignore_last_delimiters === 0) {\n                options.ignore_last_delimiters = false;\n            }\n        } else if (typeof options.ignore_last_delimiters !== \"boolean\") {\n            throw new CsvError(\"CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS\", [\n                \"Invalid option `ignore_last_delimiters`:\",\n                \"the value must be a boolean value or an integer,\",\n                `got ${JSON.stringify(options.ignore_last_delimiters)}`\n            ], options);\n        }\n        if (options.ignore_last_delimiters === true && options.columns === false) {\n            throw new CsvError(\"CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS\", [\n                \"The option `ignore_last_delimiters`\",\n                \"requires the activation of the `columns` option\"\n            ], options);\n        }\n        // Normalize option `info`\n        if (options.info === undefined || options.info === null || options.info === false) {\n            options.info = false;\n        } else if (options.info !== true) {\n            throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n        }\n        // Normalize option `max_record_size`\n        if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n            options.max_record_size = 0;\n        } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {\n        // Great, nothing to do\n        } else if (typeof options.max_record_size === \"string\" && /\\d+/.test(options.max_record_size)) {\n            options.max_record_size = parseInt(options.max_record_size);\n        } else {\n            throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n        }\n        // Normalize option `objname`\n        if (options.objname === undefined || options.objname === null || options.objname === false) {\n            options.objname = undefined;\n        } else if (Buffer.isBuffer(options.objname)) {\n            if (options.objname.length === 0) {\n                throw new Error(`Invalid Option: objname must be a non empty buffer`);\n            }\n            if (options.encoding === null) {\n            // Don't call `toString`, leave objname as a buffer\n            } else {\n                options.objname = options.objname.toString(options.encoding);\n            }\n        } else if (typeof options.objname === \"string\") {\n            if (options.objname.length === 0) {\n                throw new Error(`Invalid Option: objname must be a non empty string`);\n            }\n        // Great, nothing to do\n        } else {\n            throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n        }\n        // Normalize option `on_record`\n        if (options.on_record === undefined || options.on_record === null) {\n            options.on_record = undefined;\n        } else if (typeof options.on_record !== \"function\") {\n            throw new CsvError(\"CSV_INVALID_OPTION_ON_RECORD\", [\n                \"Invalid option `on_record`:\",\n                \"expect a function,\",\n                `got ${JSON.stringify(options.on_record)}`\n            ], options);\n        }\n        // Normalize option `quote`\n        if (options.quote === null || options.quote === false || options.quote === \"\") {\n            options.quote = null;\n        } else {\n            if (options.quote === undefined || options.quote === true) {\n                options.quote = Buffer.from('\"', options.encoding);\n            } else if (typeof options.quote === \"string\") {\n                options.quote = Buffer.from(options.quote, options.encoding);\n            }\n            if (!Buffer.isBuffer(options.quote)) {\n                throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n            }\n        }\n        // Normalize option `raw`\n        if (options.raw === undefined || options.raw === null || options.raw === false) {\n            options.raw = false;\n        } else if (options.raw !== true) {\n            throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n        }\n        // Normalize option `record_delimiter`\n        if (!options.record_delimiter) {\n            options.record_delimiter = [];\n        } else if (!Array.isArray(options.record_delimiter)) {\n            options.record_delimiter = [\n                options.record_delimiter\n            ];\n        }\n        options.record_delimiter = options.record_delimiter.map(function(rd) {\n            if (typeof rd === \"string\") {\n                rd = Buffer.from(rd, options.encoding);\n            }\n            return rd;\n        });\n        // Normalize option `relax`\n        if (typeof options.relax === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.relax === undefined || options.relax === null) {\n            options.relax = false;\n        } else {\n            throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`);\n        }\n        // Normalize option `relax_column_count`\n        if (typeof options.relax_column_count === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n            options.relax_column_count = false;\n        } else {\n            throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n        }\n        if (typeof options.relax_column_count_less === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n            options.relax_column_count_less = false;\n        } else {\n            throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n        }\n        if (typeof options.relax_column_count_more === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n            options.relax_column_count_more = false;\n        } else {\n            throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n        }\n        // Normalize option `skip_empty_lines`\n        if (typeof options.skip_empty_lines === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n            options.skip_empty_lines = false;\n        } else {\n            throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n        }\n        // Normalize option `skip_lines_with_empty_values`\n        if (typeof options.skip_lines_with_empty_values === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n            options.skip_lines_with_empty_values = false;\n        } else {\n            throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`);\n        }\n        // Normalize option `skip_lines_with_error`\n        if (typeof options.skip_lines_with_error === \"boolean\") {\n        // Great, nothing to do\n        } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n            options.skip_lines_with_error = false;\n        } else {\n            throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`);\n        }\n        // Normalize option `rtrim`\n        if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n            options.rtrim = false;\n        } else if (options.rtrim !== true) {\n            throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n        }\n        // Normalize option `ltrim`\n        if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n            options.ltrim = false;\n        } else if (options.ltrim !== true) {\n            throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n        }\n        // Normalize option `trim`\n        if (options.trim === undefined || options.trim === null || options.trim === false) {\n            options.trim = false;\n        } else if (options.trim !== true) {\n            throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n        }\n        // Normalize options `trim`, `ltrim` and `rtrim`\n        if (options.trim === true && opts.ltrim !== false) {\n            options.ltrim = true;\n        } else if (options.ltrim !== true) {\n            options.ltrim = false;\n        }\n        if (options.trim === true && opts.rtrim !== false) {\n            options.rtrim = true;\n        } else if (options.rtrim !== true) {\n            options.rtrim = false;\n        }\n        // Normalize option `to`\n        if (options.to === undefined || options.to === null) {\n            options.to = -1;\n        } else {\n            if (typeof options.to === \"string\" && /\\d+/.test(options.to)) {\n                options.to = parseInt(options.to);\n            }\n            if (Number.isInteger(options.to)) {\n                if (options.to <= 0) {\n                    throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n                }\n            } else {\n                throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n            }\n        }\n        // Normalize option `to_line`\n        if (options.to_line === undefined || options.to_line === null) {\n            options.to_line = -1;\n        } else {\n            if (typeof options.to_line === \"string\" && /\\d+/.test(options.to_line)) {\n                options.to_line = parseInt(options.to_line);\n            }\n            if (Number.isInteger(options.to_line)) {\n                if (options.to_line <= 0) {\n                    throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n                }\n            } else {\n                throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n            }\n        }\n        this.info = {\n            bytes: 0,\n            comment_lines: 0,\n            empty_lines: 0,\n            invalid_field_length: 0,\n            lines: 1,\n            records: 0\n        };\n        this.options = options;\n        this.state = {\n            bomSkipped: false,\n            bufBytesStart: 0,\n            castField: fnCastField,\n            commenting: false,\n            // Current error encountered by a record\n            error: undefined,\n            enabled: options.from_line === 1,\n            escaping: false,\n            // escapeIsQuote: options.escape === options.quote,\n            escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n            // columns can be `false`, `true`, `Array`\n            expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n            field: new ResizeableBuffer(20),\n            firstLineToHeaders: fnFirstLineToHeaders,\n            needMoreDataSize: Math.max(// Skip if the remaining buffer smaller than comment\n            options.comment !== null ? options.comment.length : 0, // Skip if the remaining buffer can be delimiter\n            ...options.delimiter.map((delimiter)=>delimiter.length), // Skip if the remaining buffer can be escape sequence\n            options.quote !== null ? options.quote.length : 0),\n            previousBuf: undefined,\n            quoting: false,\n            stop: false,\n            rawBuffer: new ResizeableBuffer(100),\n            record: [],\n            recordHasError: false,\n            record_length: 0,\n            recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map((v)=>v.length)),\n            trimChars: [\n                Buffer.from(\" \", options.encoding)[0],\n                Buffer.from(\"\t\", options.encoding)[0]\n            ],\n            wasQuoting: false,\n            wasRowDelimiter: false\n        };\n    }\n    // Implementation of `Transform._transform`\n    _transform(buf, encoding, callback) {\n        if (this.state.stop === true) {\n            return;\n        }\n        const err = this.__parse(buf, false);\n        if (err !== undefined) {\n            this.state.stop = true;\n        }\n        callback(err);\n    }\n    // Implementation of `Transform._flush`\n    _flush(callback) {\n        if (this.state.stop === true) {\n            return;\n        }\n        const err = this.__parse(undefined, true);\n        callback(err);\n    }\n    // Central parser implementation\n    __parse(nextBuf, end) {\n        const { bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line } = this.options;\n        let { record_delimiter } = this.options;\n        const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;\n        let buf;\n        if (previousBuf === undefined) {\n            if (nextBuf === undefined) {\n                // Handle empty string\n                this.push(null);\n                return;\n            } else {\n                buf = nextBuf;\n            }\n        } else if (previousBuf !== undefined && nextBuf === undefined) {\n            buf = previousBuf;\n        } else {\n            buf = Buffer.concat([\n                previousBuf,\n                nextBuf\n            ]);\n        }\n        // Handle UTF BOM\n        if (bomSkipped === false) {\n            if (bom === false) {\n                this.state.bomSkipped = true;\n            } else if (buf.length < 3) {\n                // No enough data\n                if (end === false) {\n                    // Wait for more data\n                    this.state.previousBuf = buf;\n                    return;\n                }\n            } else {\n                for(let encoding in boms){\n                    if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n                        // Skip BOM\n                        let bomLength = boms[encoding].length;\n                        this.state.bufBytesStart += bomLength;\n                        buf = buf.slice(bomLength);\n                        // Renormalize original options with the new encoding\n                        this.__normalizeOptions({\n                            ...this.__originalOptions,\n                            encoding: encoding\n                        });\n                        break;\n                    }\n                }\n                this.state.bomSkipped = true;\n            }\n        }\n        const bufLen = buf.length;\n        let pos;\n        for(pos = 0; pos < bufLen; pos++){\n            // Ensure we get enough space to look ahead\n            // There should be a way to move this out of the loop\n            if (this.__needMoreData(pos, bufLen, end)) {\n                break;\n            }\n            if (this.state.wasRowDelimiter === true) {\n                this.info.lines++;\n                this.state.wasRowDelimiter = false;\n            }\n            if (to_line !== -1 && this.info.lines > to_line) {\n                this.state.stop = true;\n                this.push(null);\n                return;\n            }\n            // Auto discovery of record_delimiter, unix, mac and windows supported\n            if (this.state.quoting === false && record_delimiter.length === 0) {\n                const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n                if (record_delimiterCount) {\n                    record_delimiter = this.options.record_delimiter;\n                }\n            }\n            const chr = buf[pos];\n            if (raw === true) {\n                rawBuffer.append(chr);\n            }\n            if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n                this.state.wasRowDelimiter = true;\n            }\n            // Previous char was a valid escape char\n            // treat the current char as a regular char\n            if (this.state.escaping === true) {\n                this.state.escaping = false;\n            } else {\n                // Escape is only active inside quoted fields\n                // We are quoting, the char is an escape chr and there is a chr to escape\n                // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n                if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n                    if (escapeIsQuote) {\n                        if (this.__isQuote(buf, pos + escape.length)) {\n                            this.state.escaping = true;\n                            pos += escape.length - 1;\n                            continue;\n                        }\n                    } else {\n                        this.state.escaping = true;\n                        pos += escape.length - 1;\n                        continue;\n                    }\n                }\n                // Not currently escaping and chr is a quote\n                // TODO: need to compare bytes instead of single char\n                if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n                    if (this.state.quoting === true) {\n                        const nextChr = buf[pos + quote.length];\n                        const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);\n                        const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n                        const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n                        const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n                        // Escape a quote\n                        // Treat next char as a regular character\n                        if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                            pos += escape.length - 1;\n                        } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                            this.state.quoting = false;\n                            this.state.wasQuoting = true;\n                            pos += quote.length - 1;\n                            continue;\n                        } else if (relax === false) {\n                            const err = this.__error(new CsvError(\"CSV_INVALID_CLOSING_QUOTE\", [\n                                \"Invalid Closing Quote:\",\n                                `got \"${String.fromCharCode(nextChr)}\"`,\n                                `at line ${this.info.lines}`,\n                                \"instead of delimiter, record delimiter, trimable character\",\n                                \"(if activated) or comment\"\n                            ], this.options, this.__infoField()));\n                            if (err !== undefined) return err;\n                        } else {\n                            this.state.quoting = false;\n                            this.state.wasQuoting = true;\n                            this.state.field.prepend(quote);\n                            pos += quote.length - 1;\n                        }\n                    } else {\n                        if (this.state.field.length !== 0) {\n                            // In relax mode, treat opening quote preceded by chrs as regular\n                            if (relax === false) {\n                                const err = this.__error(new CsvError(\"INVALID_OPENING_QUOTE\", [\n                                    \"Invalid Opening Quote:\",\n                                    `a quote is found inside a field at line ${this.info.lines}`\n                                ], this.options, this.__infoField(), {\n                                    field: this.state.field\n                                }));\n                                if (err !== undefined) return err;\n                            }\n                        } else {\n                            this.state.quoting = true;\n                            pos += quote.length - 1;\n                            continue;\n                        }\n                    }\n                }\n                if (this.state.quoting === false) {\n                    let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n                    if (recordDelimiterLength !== 0) {\n                        // Do not emit comments which take a full line\n                        const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n                        if (skipCommentLine) {\n                            this.info.comment_lines++;\n                        // Skip full comment line\n                        } else {\n                            // Activate records emition if above from_line\n                            if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                                this.state.enabled = true;\n                                this.__resetField();\n                                this.__resetRecord();\n                                pos += recordDelimiterLength - 1;\n                                continue;\n                            }\n                            // Skip if line is empty and skip_empty_lines activated\n                            if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                                this.info.empty_lines++;\n                                pos += recordDelimiterLength - 1;\n                                continue;\n                            }\n                            this.info.bytes = this.state.bufBytesStart + pos;\n                            const errField = this.__onField();\n                            if (errField !== undefined) return errField;\n                            this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                            const errRecord = this.__onRecord();\n                            if (errRecord !== undefined) return errRecord;\n                            if (to !== -1 && this.info.records >= to) {\n                                this.state.stop = true;\n                                this.push(null);\n                                return;\n                            }\n                        }\n                        this.state.commenting = false;\n                        pos += recordDelimiterLength - 1;\n                        continue;\n                    }\n                    if (this.state.commenting) {\n                        continue;\n                    }\n                    const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n                    if (commentCount !== 0) {\n                        this.state.commenting = true;\n                        continue;\n                    }\n                    let delimiterLength = this.__isDelimiter(buf, pos, chr);\n                    if (delimiterLength !== 0) {\n                        this.info.bytes = this.state.bufBytesStart + pos;\n                        const errField = this.__onField();\n                        if (errField !== undefined) return errField;\n                        pos += delimiterLength - 1;\n                        continue;\n                    }\n                }\n            }\n            if (this.state.commenting === false) {\n                if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n                    const err = this.__error(new CsvError(\"CSV_MAX_RECORD_SIZE\", [\n                        \"Max Record Size:\",\n                        \"record exceed the maximum number of tolerated bytes\",\n                        `of ${max_record_size}`,\n                        `at line ${this.info.lines}`\n                    ], this.options, this.__infoField()));\n                    if (err !== undefined) return err;\n                }\n            }\n            const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr);\n            // rtrim in non quoting is handle in __onField\n            const rappend = rtrim === false || this.state.wasQuoting === false;\n            if (lappend === true && rappend === true) {\n                this.state.field.append(chr);\n            } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n                const err = this.__error(new CsvError(\"CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE\", [\n                    \"Invalid Closing Quote:\",\n                    \"found non trimable byte after quote\",\n                    `at line ${this.info.lines}`\n                ], this.options, this.__infoField()));\n                if (err !== undefined) return err;\n            }\n        }\n        if (end === true) {\n            // Ensure we are not ending in a quoting state\n            if (this.state.quoting === true) {\n                const err = this.__error(new CsvError(\"CSV_QUOTE_NOT_CLOSED\", [\n                    \"Quote Not Closed:\",\n                    `the parsing is finished with an opening quote at line ${this.info.lines}`\n                ], this.options, this.__infoField()));\n                if (err !== undefined) return err;\n            } else {\n                // Skip last line if it has no characters\n                if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n                    this.info.bytes = this.state.bufBytesStart + pos;\n                    const errField = this.__onField();\n                    if (errField !== undefined) return errField;\n                    const errRecord = this.__onRecord();\n                    if (errRecord !== undefined) return errRecord;\n                } else if (this.state.wasRowDelimiter === true) {\n                    this.info.empty_lines++;\n                } else if (this.state.commenting === true) {\n                    this.info.comment_lines++;\n                }\n            }\n        } else {\n            this.state.bufBytesStart += pos;\n            this.state.previousBuf = buf.slice(pos);\n        }\n        if (this.state.wasRowDelimiter === true) {\n            this.info.lines++;\n            this.state.wasRowDelimiter = false;\n        }\n    }\n    __onRecord() {\n        const { columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values } = this.options;\n        const { enabled, record } = this.state;\n        if (enabled === false) {\n            return this.__resetRecord();\n        }\n        // Convert the first line into column names\n        const recordLength = record.length;\n        if (columns === true) {\n            if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n                this.__resetRecord();\n                return;\n            }\n            return this.__firstLineToColumns(record);\n        }\n        if (columns === false && this.info.records === 0) {\n            this.state.expectedRecordLength = recordLength;\n        }\n        if (recordLength !== this.state.expectedRecordLength) {\n            const err = columns === false ? // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n            // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n            new CsvError(\"CSV_INCONSISTENT_RECORD_LENGTH\", [\n                \"Invalid Record Length:\",\n                `expect ${this.state.expectedRecordLength},`,\n                `got ${recordLength} on line ${this.info.lines}`\n            ], this.options, this.__infoField(), {\n                record: record\n            }) : // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n            // CSV_RECORD_INCONSISTENT_COLUMNS\n            new CsvError(\"CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH\", [\n                \"Invalid Record Length:\",\n                `columns length is ${columns.length},`,\n                `got ${recordLength} on line ${this.info.lines}`\n            ], this.options, this.__infoField(), {\n                record: record\n            });\n            if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n                this.info.invalid_field_length++;\n                this.state.error = err;\n            // Error is undefined with skip_lines_with_error\n            } else {\n                const finalErr = this.__error(err);\n                if (finalErr) return finalErr;\n            }\n        }\n        if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n            this.__resetRecord();\n            return;\n        }\n        if (this.state.recordHasError === true) {\n            this.__resetRecord();\n            this.state.recordHasError = false;\n            return;\n        }\n        this.info.records++;\n        if (from === 1 || this.info.records >= from) {\n            // With columns, records are object\n            if (columns !== false) {\n                const obj = {};\n                // Transform record array to an object\n                for(let i = 0, l = record.length; i < l; i++){\n                    if (columns[i] === undefined || columns[i].disabled) continue;\n                    // Turn duplicate columns into an array\n                    if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n                        if (Array.isArray(obj[columns[i].name])) {\n                            obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n                        } else {\n                            obj[columns[i].name] = [\n                                obj[columns[i].name],\n                                record[i]\n                            ];\n                        }\n                    } else {\n                        obj[columns[i].name] = record[i];\n                    }\n                }\n                const { objname } = this.options;\n                // Without objname (default)\n                if (objname === undefined) {\n                    if (raw === true || info === true) {\n                        const err = this.__push(Object.assign({\n                            record: obj\n                        }, raw === true ? {\n                            raw: this.state.rawBuffer.toString(encoding)\n                        } : {}, info === true ? {\n                            info: this.__infoRecord()\n                        } : {}));\n                        if (err) {\n                            return err;\n                        }\n                    } else {\n                        const err = this.__push(obj);\n                        if (err) {\n                            return err;\n                        }\n                    }\n                // With objname (default)\n                } else {\n                    if (raw === true || info === true) {\n                        const err = this.__push(Object.assign({\n                            record: [\n                                obj[objname],\n                                obj\n                            ]\n                        }, raw === true ? {\n                            raw: this.state.rawBuffer.toString(encoding)\n                        } : {}, info === true ? {\n                            info: this.__infoRecord()\n                        } : {}));\n                        if (err) {\n                            return err;\n                        }\n                    } else {\n                        const err = this.__push([\n                            obj[objname],\n                            obj\n                        ]);\n                        if (err) {\n                            return err;\n                        }\n                    }\n                }\n            // Without columns, records are array\n            } else {\n                if (raw === true || info === true) {\n                    const err = this.__push(Object.assign({\n                        record: record\n                    }, raw === true ? {\n                        raw: this.state.rawBuffer.toString(encoding)\n                    } : {}, info === true ? {\n                        info: this.__infoRecord()\n                    } : {}));\n                    if (err) {\n                        return err;\n                    }\n                } else {\n                    const err = this.__push(record);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n        }\n        this.__resetRecord();\n    }\n    __firstLineToColumns(record) {\n        const { firstLineToHeaders } = this.state;\n        try {\n            const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n            if (!Array.isArray(headers)) {\n                return this.__error(new CsvError(\"CSV_INVALID_COLUMN_MAPPING\", [\n                    \"Invalid Column Mapping:\",\n                    \"expect an array from column function,\",\n                    `got ${JSON.stringify(headers)}`\n                ], this.options, this.__infoField(), {\n                    headers: headers\n                }));\n            }\n            const normalizedHeaders = normalizeColumnsArray(headers);\n            this.state.expectedRecordLength = normalizedHeaders.length;\n            this.options.columns = normalizedHeaders;\n            this.__resetRecord();\n            return;\n        } catch (err) {\n            return err;\n        }\n    }\n    __resetRecord() {\n        if (this.options.raw === true) {\n            this.state.rawBuffer.reset();\n        }\n        this.state.error = undefined;\n        this.state.record = [];\n        this.state.record_length = 0;\n    }\n    __onField() {\n        const { cast, encoding, rtrim, max_record_size } = this.options;\n        const { enabled, wasQuoting } = this.state;\n        // Short circuit for the from_line options\n        if (enabled === false) {\n            return this.__resetField();\n        }\n        let field = this.state.field.toString(encoding);\n        if (rtrim === true && wasQuoting === false) {\n            field = field.trimRight();\n        }\n        if (cast === true) {\n            const [err, f] = this.__cast(field);\n            if (err !== undefined) return err;\n            field = f;\n        }\n        this.state.record.push(field);\n        // Increment record length if record size must not exceed a limit\n        if (max_record_size !== 0 && typeof field === \"string\") {\n            this.state.record_length += field.length;\n        }\n        this.__resetField();\n    }\n    __resetField() {\n        this.state.field.reset();\n        this.state.wasQuoting = false;\n    }\n    __push(record) {\n        const { on_record } = this.options;\n        if (on_record !== undefined) {\n            const info = this.__infoRecord();\n            try {\n                record = on_record.call(null, record, info);\n            } catch (err) {\n                return err;\n            }\n            if (record === undefined || record === null) {\n                return;\n            }\n        }\n        this.push(record);\n    }\n    // Return a tuple with the error and the casted value\n    __cast(field) {\n        const { columns, relax_column_count } = this.options;\n        const isColumns = Array.isArray(columns);\n        // Dont loose time calling cast\n        // because the final record is an object\n        // and this field can't be associated to a key present in columns\n        if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n            return [\n                undefined,\n                undefined\n            ];\n        }\n        if (this.state.castField !== null) {\n            try {\n                const info = this.__infoField();\n                return [\n                    undefined,\n                    this.state.castField.call(null, field, info)\n                ];\n            } catch (err) {\n                return [\n                    err\n                ];\n            }\n        }\n        if (this.__isFloat(field)) {\n            return [\n                undefined,\n                parseFloat(field)\n            ];\n        } else if (this.options.cast_date !== false) {\n            const info = this.__infoField();\n            return [\n                undefined,\n                this.options.cast_date.call(null, field, info)\n            ];\n        }\n        return [\n            undefined,\n            field\n        ];\n    }\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable(chr) {\n        return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n    }\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat(value) {\n        return value - parseFloat(value) + 1 >= 0 // Borrowed from jquery\n        ;\n    }\n    __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {\n        if (sourceBuf[0] !== firstByte) return 0;\n        const sourceLength = sourceBuf.length;\n        for(let i = 1; i < sourceLength; i++){\n            if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n        }\n        return sourceLength;\n    }\n    __needMoreData(i, bufLen, end) {\n        if (end) return false;\n        const { quote } = this.options;\n        const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;\n        const numOfCharLeft = bufLen - i - 1;\n        const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter\n        recordDelimiterMaxLength, // Skip if the remaining buffer can be record delimiter following the closing quote\n        // 1 is for quote.length\n        quoting ? quote.length + recordDelimiterMaxLength : 0);\n        return numOfCharLeft < requiredLength;\n    }\n    __isDelimiter(buf, pos, chr) {\n        const { delimiter, ignore_last_delimiters } = this.options;\n        if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n            return 0;\n        } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === \"number\" && this.state.record.length === ignore_last_delimiters - 1) {\n            return 0;\n        }\n        loop1: for(let i = 0; i < delimiter.length; i++){\n            const del = delimiter[i];\n            if (del[0] === chr) {\n                for(let j = 1; j < del.length; j++){\n                    if (del[j] !== buf[pos + j]) continue loop1;\n                }\n                return del.length;\n            }\n        }\n        return 0;\n    }\n    __isRecordDelimiter(chr, buf, pos) {\n        const { record_delimiter } = this.options;\n        const recordDelimiterLength = record_delimiter.length;\n        loop1: for(let i = 0; i < recordDelimiterLength; i++){\n            const rd = record_delimiter[i];\n            const rdLength = rd.length;\n            if (rd[0] !== chr) {\n                continue;\n            }\n            for(let j = 1; j < rdLength; j++){\n                if (rd[j] !== buf[pos + j]) {\n                    continue loop1;\n                }\n            }\n            return rd.length;\n        }\n        return 0;\n    }\n    __isEscape(buf, pos, chr) {\n        const { escape } = this.options;\n        if (escape === null) return false;\n        const l = escape.length;\n        if (escape[0] === chr) {\n            for(let i = 0; i < l; i++){\n                if (escape[i] !== buf[pos + i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    __isQuote(buf, pos) {\n        const { quote } = this.options;\n        if (quote === null) return false;\n        const l = quote.length;\n        for(let i = 0; i < l; i++){\n            if (quote[i] !== buf[pos + i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    __autoDiscoverRecordDelimiter(buf, pos) {\n        const { encoding } = this.options;\n        const chr = buf[pos];\n        if (chr === cr) {\n            if (buf[pos + 1] === nl) {\n                this.options.record_delimiter.push(Buffer.from(\"\\r\\n\", encoding));\n                this.state.recordDelimiterMaxLength = 2;\n                return 2;\n            } else {\n                this.options.record_delimiter.push(Buffer.from(\"\\r\", encoding));\n                this.state.recordDelimiterMaxLength = 1;\n                return 1;\n            }\n        } else if (chr === nl) {\n            this.options.record_delimiter.push(Buffer.from(\"\\n\", encoding));\n            this.state.recordDelimiterMaxLength = 1;\n            return 1;\n        }\n        return 0;\n    }\n    __error(msg) {\n        const { skip_lines_with_error } = this.options;\n        const err = typeof msg === \"string\" ? new Error(msg) : msg;\n        if (skip_lines_with_error) {\n            this.state.recordHasError = true;\n            this.emit(\"skip\", err);\n            return undefined;\n        } else {\n            return err;\n        }\n    }\n    __infoDataSet() {\n        return {\n            ...this.info,\n            columns: this.options.columns\n        };\n    }\n    __infoRecord() {\n        const { columns } = this.options;\n        return {\n            ...this.__infoDataSet(),\n            error: this.state.error,\n            header: columns === true,\n            index: this.state.record.length\n        };\n    }\n    __infoField() {\n        const { columns } = this.options;\n        const isColumns = Array.isArray(columns);\n        return {\n            ...this.__infoRecord(),\n            column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n            quoting: this.state.wasQuoting\n        };\n    }\n}\nconst parse = function() {\n    let data, options, callback;\n    for(let i in arguments){\n        const argument = arguments[i];\n        const type = typeof argument;\n        if (data === undefined && (typeof argument === \"string\" || Buffer.isBuffer(argument))) {\n            data = argument;\n        } else if (options === undefined && isObject(argument)) {\n            options = argument;\n        } else if (callback === undefined && type === \"function\") {\n            callback = argument;\n        } else {\n            throw new CsvError(\"CSV_INVALID_ARGUMENT\", [\n                \"Invalid argument:\",\n                `got ${JSON.stringify(argument)} at index ${i}`\n            ], options || {});\n        }\n    }\n    const parser = new Parser(options);\n    if (callback) {\n        const records = options === undefined || options.objname === undefined ? [] : {};\n        parser.on(\"readable\", function() {\n            let record;\n            while((record = this.read()) !== null){\n                if (options === undefined || options.objname === undefined) {\n                    records.push(record);\n                } else {\n                    records[record[0]] = record[1];\n                }\n            }\n        });\n        parser.on(\"error\", function(err) {\n            callback(err, undefined, parser.__infoDataSet());\n        });\n        parser.on(\"end\", function() {\n            callback(undefined, records, parser.__infoDataSet());\n        });\n    }\n    if (data !== undefined) {\n        // Give a chance for events to be registered later\n        if (typeof setImmediate === \"function\") {\n            setImmediate(function() {\n                parser.write(data);\n                parser.end();\n            });\n        } else {\n            parser.write(data);\n            parser.end();\n        }\n    }\n    return parser;\n};\nclass CsvError extends Error {\n    constructor(code, message, options, ...contexts){\n        if (Array.isArray(message)) message = message.join(\" \");\n        super(message);\n        if (Error.captureStackTrace !== undefined) {\n            Error.captureStackTrace(this, CsvError);\n        }\n        this.code = code;\n        for (const context of contexts){\n            for(const key in context){\n                const value = context[key];\n                this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n            }\n        }\n    }\n}\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\nconst underscore = function(str) {\n    return str.replace(/([A-Z])/g, function(_, match) {\n        return \"_\" + match.toLowerCase();\n    });\n};\nconst isObject = function(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\nconst isRecordEmpty = function(record) {\n    return record.every((field)=>field == null || field.toString && field.toString().trim() === \"\");\n};\nconst normalizeColumnsArray = function(columns) {\n    const normalizedColumns = [];\n    for(let i = 0, l = columns.length; i < l; i++){\n        const column = columns[i];\n        if (column === undefined || column === null || column === false) {\n            normalizedColumns[i] = {\n                disabled: true\n            };\n        } else if (typeof column === \"string\") {\n            normalizedColumns[i] = {\n                name: column\n            };\n        } else if (isObject(column)) {\n            if (typeof column.name !== \"string\") {\n                throw new CsvError(\"CSV_OPTION_COLUMNS_MISSING_NAME\", [\n                    \"Option columns missing name:\",\n                    `property \"name\" is required at position ${i}`,\n                    \"when column is an object literal\"\n                ]);\n            }\n            normalizedColumns[i] = column;\n        } else {\n            throw new CsvError(\"CSV_INVALID_COLUMN_DEFINITION\", [\n                \"Invalid column definition:\",\n                \"expect a string or a literal object,\",\n                `got ${JSON.stringify(column)} at position ${i}`\n            ]);\n        }\n    }\n    return normalizedColumns;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY3N2LXBhcnNlQDQuMTYuMy9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFDQTs7Ozs7QUFLQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLG1CQUFtQkQsbUJBQU9BLENBQUM7QUFFakMseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUNyRCw0R0FBNEc7QUFDNUcsMEVBQTBFO0FBQzFFLE1BQU1FLE1BQU07QUFDWixNQUFNQyxLQUFLLEdBQUcseUNBQXlDOztBQUN2RCxNQUFNQyxLQUFLO0FBQ1gsTUFBTUMsS0FBSyxHQUFHLHlDQUF5Qzs7QUFDdkQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLE9BQU87SUFDWCxrQ0FBa0M7SUFDbEMsd0JBQXdCO0lBQ3hCLCtCQUErQjtJQUMvQiwrQkFBK0I7SUFDL0IsUUFBUUMsT0FBT0MsSUFBSSxDQUFDO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDbkMsa0NBQWtDO0lBQ2xDLGlDQUFpQztJQUNqQywwQkFBMEI7SUFDMUIsV0FBV0QsT0FBT0MsSUFBSSxDQUFDO1FBQUM7UUFBSztLQUFJO0FBQ25DO0FBRUEsTUFBTUMsZUFBZVg7SUFDbkJZLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDcEIsS0FBSyxDQUFDO1lBQUMsR0FBRztnQkFBQ0Msb0JBQW9CO1lBQUksQ0FBQztZQUFFLEdBQUdELElBQUk7WUFBRUUsVUFBVTtRQUFJO1FBQzdELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdIO1FBQ3pCLElBQUksQ0FBQ0ksa0JBQWtCLENBQUNKO0lBQzFCO0lBQ0FJLG1CQUFtQkosSUFBSSxFQUFDO1FBQ3RCLE1BQU1LLFVBQVUsQ0FBQztRQUNqQiwwQkFBMEI7UUFDMUIsSUFBSSxJQUFJQyxPQUFPTixLQUFLO1lBQ2xCSyxPQUFPLENBQUNFLFdBQVdELEtBQUssR0FBR04sSUFBSSxDQUFDTSxJ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bXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3YtcGFyc2VANC4xNi4zL25vZGVfbW9kdWxlcy9jc3YtcGFyc2UvbGliL2luZGV4LmpzPzRkNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuQ1NWIFBhcnNlXG5cblBsZWFzZSBsb29rIGF0IHRoZSBbcHJvamVjdCBkb2N1bWVudGF0aW9uXShodHRwczovL2Nzdi5qcy5vcmcvcGFyc2UvKSBmb3JcbmFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4qL1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IFJlc2l6ZWFibGVCdWZmZXIgPSByZXF1aXJlKCcuL1Jlc2l6ZWFibGVCdWZmZXInKVxuXG4vLyB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaGl0ZXNwYWNlX2NoYXJhY3RlclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zL0NoYXJhY3Rlcl9DbGFzc2VzI1R5cGVzXG4vLyBcXGZcXG5cXHJcXHRcXHZcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZlxuY29uc3QgdGFiID0gOVxuY29uc3QgbmwgPSAxMCAvLyBcXG4sIDB4MEEgaW4gaGV4YWRlY2ltYWwsIDEwIGluIGRlY2ltYWxcbmNvbnN0IG5wID0gMTJcbmNvbnN0IGNyID0gMTMgLy8gXFxyLCAweDBEIGluIGhleGFkw6ljaW1hbCwgMTMgaW4gZGVjaW1hbFxuY29uc3Qgc3BhY2UgPSAzMlxuY29uc3QgYm9tcyA9IHtcbiAgLy8gTm90ZSwgdGhlIGZvbGxvd2luZyBhcmUgZXF1YWxzOlxuICAvLyBCdWZmZXIuZnJvbShcIlxcdWZlZmZcIilcbiAgLy8gQnVmZmVyLmZyb20oWzIzOSwgMTg3LCAxOTFdKVxuICAvLyBCdWZmZXIuZnJvbSgnRUZCQkJGJywgJ2hleCcpXG4gICd1dGY4JzogQnVmZmVyLmZyb20oWzIzOSwgMTg3LCAxOTFdKSxcbiAgLy8gTm90ZSwgdGhlIGZvbGxvd2luZyBhcmUgZXF1YWxzOlxuICAvLyBCdWZmZXIuZnJvbSBcIlxcdWZlZmZcIiwgJ3V0ZjE2bGVcbiAgLy8gQnVmZmVyLmZyb20oWzI1NSwgMjU0XSlcbiAgJ3V0ZjE2bGUnOiBCdWZmZXIuZnJvbShbMjU1LCAyNTRdKVxufVxuXG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pe1xuICAgIHN1cGVyKHsuLi57cmVhZGFibGVPYmplY3RNb2RlOiB0cnVlfSwgLi4ub3B0cywgZW5jb2Rpbmc6IG51bGx9KVxuICAgIHRoaXMuX19vcmlnaW5hbE9wdGlvbnMgPSBvcHRzXG4gICAgdGhpcy5fX25vcm1hbGl6ZU9wdGlvbnMob3B0cylcbiAgfVxuICBfX25vcm1hbGl6ZU9wdGlvbnMob3B0cyl7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9XG4gICAgLy8gTWVyZ2Ugd2l0aCB1c2VyIG9wdGlvbnNcbiAgICBmb3IobGV0IG9wdCBpbiBvcHRzKXtcbiAgICAgIG9wdGlvbnNbdW5kZXJzY29yZShvcHQpXSA9IG9wdHNbb3B0XVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlbmNvZGluZ2BcbiAgICAvLyBOb3RlOiBkZWZpbmVkIGZpcnN0IGJlY2F1c2Ugb3RoZXIgb3B0aW9ucyBkZXBlbmRzIG9uIGl0XG4gICAgLy8gdG8gY29udmVydCBjaGFycy9zdHJpbmdzIGludG8gYnVmZmVycy5cbiAgICBpZihvcHRpb25zLmVuY29kaW5nID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5lbmNvZGluZyA9PT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLmVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfWVsc2UgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gbnVsbCB8fCBvcHRpb25zLmVuY29kaW5nID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmVuY29kaW5nID0gbnVsbFxuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLmVuY29kaW5nICE9PSAnc3RyaW5nJyAmJiBvcHRpb25zLmVuY29kaW5nICE9PSBudWxsKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0VOQ09ESU5HJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gZW5jb2Rpbmc6JyxcbiAgICAgICAgJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbCB0byByZXR1cm4gYSBidWZmZXIsJyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuZW5jb2RpbmcpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGJvbWBcbiAgICBpZihvcHRpb25zLmJvbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYm9tID09PSBudWxsIHx8IG9wdGlvbnMuYm9tID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmJvbSA9IGZhbHNlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5ib20gIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fQk9NJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gYm9tOicsICdib20gbXVzdCBiZSB0cnVlLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvbSl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY2FzdGBcbiAgICBsZXQgZm5DYXN0RmllbGQgPSBudWxsXG4gICAgaWYob3B0aW9ucy5jYXN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0ID09PSBudWxsIHx8IG9wdGlvbnMuY2FzdCA9PT0gZmFsc2UgfHwgb3B0aW9ucy5jYXN0ID09PSAnJyl7XG4gICAgICBvcHRpb25zLmNhc3QgPSB1bmRlZmluZWRcbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5jYXN0ID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGZuQ2FzdEZpZWxkID0gb3B0aW9ucy5jYXN0XG4gICAgICBvcHRpb25zLmNhc3QgPSB0cnVlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5jYXN0ICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1QnLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBjYXN0OicsICdjYXN0IG11c3QgYmUgdHJ1ZSBvciBhIGZ1bmN0aW9uLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNhc3QpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RfZGF0ZWBcbiAgICBpZihvcHRpb25zLmNhc3RfZGF0ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdF9kYXRlID09PSBudWxsIHx8IG9wdGlvbnMuY2FzdF9kYXRlID09PSBmYWxzZSB8fCBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gJycpe1xuICAgICAgb3B0aW9ucy5jYXN0X2RhdGUgPSBmYWxzZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMuY2FzdF9kYXRlID09PSB0cnVlKXtcbiAgICAgIG9wdGlvbnMuY2FzdF9kYXRlID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBjb25zdCBkYXRlID0gRGF0ZS5wYXJzZSh2YWx1ZSlcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlKSA/IG5ldyBEYXRlKGRhdGUpIDogdmFsdWVcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1RfREFURScsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGNhc3RfZGF0ZTonLCAnY2FzdF9kYXRlIG11c3QgYmUgdHJ1ZSBvciBhIGZ1bmN0aW9uLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNhc3RfZGF0ZSl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc2BcbiAgICBsZXQgZm5GaXJzdExpbmVUb0hlYWRlcnMgPSBudWxsXG4gICAgaWYob3B0aW9ucy5jb2x1bW5zID09PSB0cnVlKXtcbiAgICAgIC8vIEZpZWxkcyBpbiB0aGUgZmlyc3QgbGluZSBhcmUgY29udmVydGVkIGFzLWlzIHRvIGNvbHVtbnNcbiAgICAgIGZuRmlyc3RMaW5lVG9IZWFkZXJzID0gdW5kZWZpbmVkXG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuY29sdW1ucyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBmbkZpcnN0TGluZVRvSGVhZGVycyA9IG9wdGlvbnMuY29sdW1uc1xuICAgICAgb3B0aW9ucy5jb2x1bW5zID0gdHJ1ZVxuICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb2x1bW5zKSl7XG4gICAgICBvcHRpb25zLmNvbHVtbnMgPSBub3JtYWxpemVDb2x1bW5zQXJyYXkob3B0aW9ucy5jb2x1bW5zKVxuICAgIH1lbHNlIGlmKG9wdGlvbnMuY29sdW1ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY29sdW1ucyA9PT0gbnVsbCB8fCBvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMuY29sdW1ucyA9IGZhbHNlXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DT0xVTU5TJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gY29sdW1uczonLFxuICAgICAgICAnZXhwZWN0IGFuIGFycmF5LCBhIGZ1bmN0aW9uIG9yIHRydWUsJyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29sdW1ucyl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5YFxuICAgIGlmKG9wdGlvbnMuY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXkgPT09IG51bGwgfHwgb3B0aW9ucy5jb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXkgPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMuY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5ID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLmNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSAhPT0gdHJ1ZSl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DT0xVTU5TX0RVUExJQ0FURVNfVE9fQVJSQVknLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBjb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXk6JyxcbiAgICAgICAgJ2V4cGVjdCBhbiBib29sZWFuLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9ZWxzZSBpZihvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0NPTFVNTlNfRFVQTElDQVRFU19UT19BUlJBWScsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheTonLFxuICAgICAgICAndGhlIGBjb2x1bW5zYCBtb2RlIG11c3QgYmUgYWN0aXZhdGVkLidcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNvbW1lbnRgXG4gICAgaWYob3B0aW9ucy5jb21tZW50ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jb21tZW50ID09PSBudWxsIHx8IG9wdGlvbnMuY29tbWVudCA9PT0gZmFsc2UgfHwgb3B0aW9ucy5jb21tZW50ID09PSAnJyl7XG4gICAgICBvcHRpb25zLmNvbW1lbnQgPSBudWxsXG4gICAgfWVsc2V7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnc3RyaW5nJyl7XG4gICAgICAgIG9wdGlvbnMuY29tbWVudCA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMuY29tbWVudCwgb3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1cbiAgICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5jb21tZW50KSl7XG4gICAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0NPTU1FTlQnLCBbXG4gICAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGNvbW1lbnQ6JyxcbiAgICAgICAgICAnY29tbWVudCBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCcsXG4gICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29tbWVudCl9YFxuICAgICAgICBdLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBkZWxpbWl0ZXJgXG4gICAgY29uc3QgZGVsaW1pdGVyX2pzb24gPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRlbGltaXRlcilcbiAgICBpZighQXJyYXkuaXNBcnJheShvcHRpb25zLmRlbGltaXRlcikpIG9wdGlvbnMuZGVsaW1pdGVyID0gW29wdGlvbnMuZGVsaW1pdGVyXVxuICAgIGlmKG9wdGlvbnMuZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9ERUxJTUlURVInLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBkZWxpbWl0ZXI6JyxcbiAgICAgICAgJ2RlbGltaXRlciBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyBvciBidWZmZXIgb3IgYXJyYXkgb2Ygc3RyaW5nfGJ1ZmZlciwnLFxuICAgICAgICBgZ290ICR7ZGVsaW1pdGVyX2pzb259YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci5tYXAoZnVuY3Rpb24oZGVsaW1pdGVyKXtcbiAgICAgIGlmKGRlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8IGRlbGltaXRlciA9PT0gbnVsbCB8fCBkZWxpbWl0ZXIgPT09IGZhbHNlKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCcsJywgb3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgZGVsaW1pdGVyID0gQnVmZmVyLmZyb20oZGVsaW1pdGVyLCBvcHRpb25zLmVuY29kaW5nKVxuICAgICAgfVxuICAgICAgaWYoICFCdWZmZXIuaXNCdWZmZXIoZGVsaW1pdGVyKSB8fCBkZWxpbWl0ZXIubGVuZ3RoID09PSAwKXtcbiAgICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fREVMSU1JVEVSJywgW1xuICAgICAgICAgICdJbnZhbGlkIG9wdGlvbiBkZWxpbWl0ZXI6JyxcbiAgICAgICAgICAnZGVsaW1pdGVyIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nIG9yIGJ1ZmZlciBvciBhcnJheSBvZiBzdHJpbmd8YnVmZmVyLCcsXG4gICAgICAgICAgYGdvdCAke2RlbGltaXRlcl9qc29ufWBcbiAgICAgICAgXSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxpbWl0ZXJcbiAgICB9KVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVzY2FwZWBcbiAgICBpZihvcHRpb25zLmVzY2FwZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZXNjYXBlID09PSB0cnVlKXtcbiAgICAgIG9wdGlvbnMuZXNjYXBlID0gQnVmZmVyLmZyb20oJ1wiJywgb3B0aW9ucy5lbmNvZGluZylcbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5lc2NhcGUgPT09ICdzdHJpbmcnKXtcbiAgICAgIG9wdGlvbnMuZXNjYXBlID0gQnVmZmVyLmZyb20ob3B0aW9ucy5lc2NhcGUsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgfWVsc2UgaWYgKG9wdGlvbnMuZXNjYXBlID09PSBudWxsIHx8IG9wdGlvbnMuZXNjYXBlID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmVzY2FwZSA9IG51bGxcbiAgICB9XG4gICAgaWYob3B0aW9ucy5lc2NhcGUgIT09IG51bGwpe1xuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmVzY2FwZSkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBlc2NhcGUgbXVzdCBiZSBhIGJ1ZmZlciwgYSBzdHJpbmcgb3IgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVzY2FwZSl9YClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZnJvbWBcbiAgICBpZihvcHRpb25zLmZyb20gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZyb20gPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5mcm9tID0gMVxuICAgIH1lbHNle1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMuZnJvbSA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy5mcm9tKSl7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IHBhcnNlSW50KG9wdGlvbnMuZnJvbSlcbiAgICAgIH1cbiAgICAgIGlmKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5mcm9tKSl7XG4gICAgICAgIGlmKG9wdGlvbnMuZnJvbSA8IDApe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGZyb20gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMuZnJvbSl9YClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGZyb20gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmZyb20pfWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGZyb21fbGluZWBcbiAgICBpZihvcHRpb25zLmZyb21fbGluZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZnJvbV9saW5lID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMuZnJvbV9saW5lID0gMVxuICAgIH1lbHNle1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMuZnJvbV9saW5lID09PSAnc3RyaW5nJyAmJiAvXFxkKy8udGVzdChvcHRpb25zLmZyb21fbGluZSkpe1xuICAgICAgICBvcHRpb25zLmZyb21fbGluZSA9IHBhcnNlSW50KG9wdGlvbnMuZnJvbV9saW5lKVxuICAgICAgfVxuICAgICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmZyb21fbGluZSkpe1xuICAgICAgICBpZihvcHRpb25zLmZyb21fbGluZSA8PSAwKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBmcm9tX2xpbmUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIDAsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMuZnJvbV9saW5lKX1gKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogZnJvbV9saW5lIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy5mcm9tX2xpbmUpfWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb25zIGBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzYFxuICAgIGlmKG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPSBmYWxzZVxuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09ICdudW1iZXInKXtcbiAgICAgIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9IE1hdGguZmxvb3Iob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzKVxuICAgICAgaWYob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSAwKXtcbiAgICAgICAgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID0gZmFsc2VcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzICE9PSAnYm9vbGVhbicpe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fSUdOT1JFX0xBU1RfREVMSU1JVEVSUycsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzYDonLFxuICAgICAgICAndGhlIHZhbHVlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlIG9yIGFuIGludGVnZXIsJyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgaWYob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSB0cnVlICYmIG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2Upe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSUdOT1JFX0xBU1RfREVMSU1JVEVSU19SRVFVSVJFU19DT0xVTU5TJywgW1xuICAgICAgICAnVGhlIG9wdGlvbiBgaWdub3JlX2xhc3RfZGVsaW1pdGVyc2AnLFxuICAgICAgICAncmVxdWlyZXMgdGhlIGFjdGl2YXRpb24gb2YgdGhlIGBjb2x1bW5zYCBvcHRpb24nXG4gICAgICBdLCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBpbmZvYFxuICAgIGlmKG9wdGlvbnMuaW5mbyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaW5mbyA9PT0gbnVsbCB8fCBvcHRpb25zLmluZm8gPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMuaW5mbyA9IGZhbHNlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5pbmZvICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGluZm8gbXVzdCBiZSB0cnVlLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmluZm8pfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYG1heF9yZWNvcmRfc2l6ZWBcbiAgICBpZihvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4X3JlY29yZF9zaXplID09PSBudWxsIHx8IG9wdGlvbnMubWF4X3JlY29yZF9zaXplID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9IDBcbiAgICB9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubWF4X3JlY29yZF9zaXplKSAmJiBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA+PSAwKXtcbiAgICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID09PSAnc3RyaW5nJyAmJiAvXFxkKy8udGVzdChvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSkpe1xuICAgICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPSBwYXJzZUludChvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSlcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IG1heF9yZWNvcmRfc2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5tYXhfcmVjb3JkX3NpemUpfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYG9iam5hbWVgXG4gICAgaWYob3B0aW9ucy5vYmpuYW1lID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vYmpuYW1lID09PSBudWxsIHx8IG9wdGlvbnMub2JqbmFtZSA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5vYmpuYW1lID0gdW5kZWZpbmVkXG4gICAgfWVsc2UgaWYoQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMub2JqbmFtZSkpe1xuICAgICAgaWYob3B0aW9ucy5vYmpuYW1lLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IG9iam5hbWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBidWZmZXJgKVxuICAgICAgfVxuICAgICAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gbnVsbCl7XG4gICAgICAgIC8vIERvbid0IGNhbGwgYHRvU3RyaW5nYCwgbGVhdmUgb2JqbmFtZSBhcyBhIGJ1ZmZlclxuICAgICAgfWVsc2V7XG4gICAgICAgIG9wdGlvbnMub2JqbmFtZSA9IG9wdGlvbnMub2JqbmFtZS50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nKVxuICAgICAgfVxuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLm9iam5hbWUgPT09ICdzdHJpbmcnKXtcbiAgICAgIGlmKG9wdGlvbnMub2JqbmFtZS5sZW5ndGggPT09IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBvYmpuYW1lIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nYClcbiAgICAgIH1cbiAgICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBvYmpuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXIsIGdvdCAke29wdGlvbnMub2JqbmFtZX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBvbl9yZWNvcmRgXG4gICAgaWYob3B0aW9ucy5vbl9yZWNvcmQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm9uX3JlY29yZCA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLm9uX3JlY29yZCA9IHVuZGVmaW5lZFxuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLm9uX3JlY29yZCAhPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9PTl9SRUNPUkQnLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBgb25fcmVjb3JkYDonLFxuICAgICAgICAnZXhwZWN0IGEgZnVuY3Rpb24sJyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMub25fcmVjb3JkKX1gXG4gICAgICBdLCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWBcbiAgICBpZihvcHRpb25zLnF1b3RlID09PSBudWxsIHx8IG9wdGlvbnMucXVvdGUgPT09IGZhbHNlIHx8IG9wdGlvbnMucXVvdGUgPT09ICcnKXtcbiAgICAgIG9wdGlvbnMucXVvdGUgPSBudWxsXG4gICAgfWVsc2V7XG4gICAgICBpZihvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gdHJ1ZSl7XG4gICAgICAgIG9wdGlvbnMucXVvdGUgPSBCdWZmZXIuZnJvbSgnXCInLCBvcHRpb25zLmVuY29kaW5nKVxuICAgICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMucXVvdGUgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgb3B0aW9ucy5xdW90ZSA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMucXVvdGUsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgICBpZighQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucXVvdGUpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcXVvdGUgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZywgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5xdW90ZSl9YClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmF3YFxuICAgIGlmKG9wdGlvbnMucmF3ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5yYXcgPT09IG51bGwgfHwgb3B0aW9ucy5yYXcgPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMucmF3ID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLnJhdyAhPT0gdHJ1ZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiByYXcgbXVzdCBiZSB0cnVlLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJhdyl9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmBcbiAgICBpZighb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKXtcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFtdXG4gICAgfWVsc2UgaWYoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSl7XG4gICAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBbb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyXVxuICAgIH1cbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubWFwKCBmdW5jdGlvbihyZCl7XG4gICAgICBpZih0eXBlb2YgcmQgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgcmQgPSBCdWZmZXIuZnJvbShyZCwgb3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1cbiAgICAgIHJldHVybiByZFxuICAgIH0pXG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVsYXhgXG4gICAgaWYodHlwZW9mIG9wdGlvbnMucmVsYXggPT09ICdib29sZWFuJyl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKG9wdGlvbnMucmVsYXggPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJlbGF4ID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMucmVsYXggPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcmVsYXggbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmVsYXgpfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlbGF4X2NvbHVtbl9jb3VudGBcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPT09ICdib29sZWFuJyl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcmVsYXhfY29sdW1uX2NvdW50IG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudCl9YClcbiAgICB9XG4gICAgaWYodHlwZW9mIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MgPT09ICdib29sZWFuJyl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MgPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcmVsYXhfY29sdW1uX2NvdW50X2xlc3MgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MpfWApXG4gICAgfVxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4X2NvbHVtbl9jb3VudF9tb3JlIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBza2lwX2VtcHR5X2xpbmVzYFxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnNraXBfZW1wdHlfbGluZXMgPT09ICdib29sZWFuJyl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnNraXBfZW1wdHlfbGluZXMgPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogc2tpcF9lbXB0eV9saW5lcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBza2lwX2xpbmVzX3dpdGhfZW1wdHlfdmFsdWVzYFxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPT09ICdib29sZWFuJyl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX2xpbmVzX3dpdGhfZW1wdHlfdmFsdWVzKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBza2lwX2xpbmVzX3dpdGhfZXJyb3JgXG4gICAgaWYodHlwZW9mIG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2Vycm9yID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lcnJvciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2Vycm9yID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2Vycm9yID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHNraXBfbGluZXNfd2l0aF9lcnJvciBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX2xpbmVzX3dpdGhfZXJyb3IpfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJ0cmltYFxuICAgIGlmKG9wdGlvbnMucnRyaW0gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJ0cmltID09PSBudWxsIHx8IG9wdGlvbnMucnRyaW0gPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMucnRyaW0gPSBmYWxzZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMucnRyaW0gIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcnRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucnRyaW0pfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGx0cmltYFxuICAgIGlmKG9wdGlvbnMubHRyaW0gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmx0cmltID09PSBudWxsIHx8IG9wdGlvbnMubHRyaW0gPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMubHRyaW0gPSBmYWxzZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMubHRyaW0gIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogbHRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubHRyaW0pfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHRyaW1gXG4gICAgaWYob3B0aW9ucy50cmltID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50cmltID09PSBudWxsIHx8IG9wdGlvbnMudHJpbSA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy50cmltID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLnRyaW0gIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogdHJpbSBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy50cmltKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9ucyBgdHJpbWAsIGBsdHJpbWAgYW5kIGBydHJpbWBcbiAgICBpZihvcHRpb25zLnRyaW0gPT09IHRydWUgJiYgb3B0cy5sdHJpbSAhPT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5sdHJpbSA9IHRydWVcbiAgICB9ZWxzZSBpZihvcHRpb25zLmx0cmltICE9PSB0cnVlKXtcbiAgICAgIG9wdGlvbnMubHRyaW0gPSBmYWxzZVxuICAgIH1cbiAgICBpZihvcHRpb25zLnRyaW0gPT09IHRydWUgJiYgb3B0cy5ydHJpbSAhPT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5ydHJpbSA9IHRydWVcbiAgICB9ZWxzZSBpZihvcHRpb25zLnJ0cmltICE9PSB0cnVlKXtcbiAgICAgIG9wdGlvbnMucnRyaW0gPSBmYWxzZVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGB0b2BcbiAgICBpZihvcHRpb25zLnRvID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50byA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnRvID0gLTFcbiAgICB9ZWxzZXtcbiAgICAgIGlmKHR5cGVvZiBvcHRpb25zLnRvID09PSAnc3RyaW5nJyAmJiAvXFxkKy8udGVzdChvcHRpb25zLnRvKSl7XG4gICAgICAgIG9wdGlvbnMudG8gPSBwYXJzZUludChvcHRpb25zLnRvKVxuICAgICAgfVxuICAgICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnRvKSl7XG4gICAgICAgIGlmKG9wdGlvbnMudG8gPD0gMCl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogdG8gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIDAsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMudG8pfWApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0byBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMudG8pfWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHRvX2xpbmVgXG4gICAgaWYob3B0aW9ucy50b19saW5lID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50b19saW5lID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMudG9fbGluZSA9IC0xXG4gICAgfWVsc2V7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucy50b19saW5lID09PSAnc3RyaW5nJyAmJiAvXFxkKy8udGVzdChvcHRpb25zLnRvX2xpbmUpKXtcbiAgICAgICAgb3B0aW9ucy50b19saW5lID0gcGFyc2VJbnQob3B0aW9ucy50b19saW5lKVxuICAgICAgfVxuICAgICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnRvX2xpbmUpKXtcbiAgICAgICAgaWYob3B0aW9ucy50b19saW5lIDw9IDApe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHRvX2xpbmUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIDAsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMudG9fbGluZSl9YClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHRvX2xpbmUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvX2xpbmUpfWApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIGJ5dGVzOiAwLFxuICAgICAgY29tbWVudF9saW5lczogMCxcbiAgICAgIGVtcHR5X2xpbmVzOiAwLFxuICAgICAgaW52YWxpZF9maWVsZF9sZW5ndGg6IDAsXG4gICAgICBsaW5lczogMSxcbiAgICAgIHJlY29yZHM6IDBcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBib21Ta2lwcGVkOiBmYWxzZSxcbiAgICAgIGJ1ZkJ5dGVzU3RhcnQ6IDAsXG4gICAgICBjYXN0RmllbGQ6IGZuQ2FzdEZpZWxkLFxuICAgICAgY29tbWVudGluZzogZmFsc2UsXG4gICAgICAvLyBDdXJyZW50IGVycm9yIGVuY291bnRlcmVkIGJ5IGEgcmVjb3JkXG4gICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgZW5hYmxlZDogb3B0aW9ucy5mcm9tX2xpbmUgPT09IDEsXG4gICAgICBlc2NhcGluZzogZmFsc2UsXG4gICAgICAvLyBlc2NhcGVJc1F1b3RlOiBvcHRpb25zLmVzY2FwZSA9PT0gb3B0aW9ucy5xdW90ZSxcbiAgICAgIGVzY2FwZUlzUXVvdGU6IEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmVzY2FwZSkgJiYgQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucXVvdGUpICYmIEJ1ZmZlci5jb21wYXJlKG9wdGlvbnMuZXNjYXBlLCBvcHRpb25zLnF1b3RlKSA9PT0gMCxcbiAgICAgIC8vIGNvbHVtbnMgY2FuIGJlIGBmYWxzZWAsIGB0cnVlYCwgYEFycmF5YFxuICAgICAgZXhwZWN0ZWRSZWNvcmRMZW5ndGg6IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb2x1bW5zKSA/IG9wdGlvbnMuY29sdW1ucy5sZW5ndGggOiB1bmRlZmluZWQsXG4gICAgICBmaWVsZDogbmV3IFJlc2l6ZWFibGVCdWZmZXIoMjApLFxuICAgICAgZmlyc3RMaW5lVG9IZWFkZXJzOiBmbkZpcnN0TGluZVRvSGVhZGVycyxcbiAgICAgIG5lZWRNb3JlRGF0YVNpemU6IE1hdGgubWF4KFxuICAgICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIHNtYWxsZXIgdGhhbiBjb21tZW50XG4gICAgICAgIG9wdGlvbnMuY29tbWVudCAhPT0gbnVsbCA/IG9wdGlvbnMuY29tbWVudC5sZW5ndGggOiAwLFxuICAgICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIGNhbiBiZSBkZWxpbWl0ZXJcbiAgICAgICAgLi4ub3B0aW9ucy5kZWxpbWl0ZXIubWFwKCAoZGVsaW1pdGVyKSA9PiBkZWxpbWl0ZXIubGVuZ3RoKSxcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIG9wdGlvbnMucXVvdGUgIT09IG51bGwgPyBvcHRpb25zLnF1b3RlLmxlbmd0aCA6IDAsXG4gICAgICApLFxuICAgICAgcHJldmlvdXNCdWY6IHVuZGVmaW5lZCxcbiAgICAgIHF1b3Rpbmc6IGZhbHNlLFxuICAgICAgc3RvcDogZmFsc2UsXG4gICAgICByYXdCdWZmZXI6IG5ldyBSZXNpemVhYmxlQnVmZmVyKDEwMCksXG4gICAgICByZWNvcmQ6IFtdLFxuICAgICAgcmVjb3JkSGFzRXJyb3I6IGZhbHNlLFxuICAgICAgcmVjb3JkX2xlbmd0aDogMCxcbiAgICAgIHJlY29yZERlbGltaXRlck1heExlbmd0aDogb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCA/IDIgOiBNYXRoLm1heCguLi5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubWFwKCAodikgPT4gdi5sZW5ndGgpKSxcbiAgICAgIHRyaW1DaGFyczogW0J1ZmZlci5mcm9tKCcgJywgb3B0aW9ucy5lbmNvZGluZylbMF0sIEJ1ZmZlci5mcm9tKCdcXHQnLCBvcHRpb25zLmVuY29kaW5nKVswXV0sXG4gICAgICB3YXNRdW90aW5nOiBmYWxzZSxcbiAgICAgIHdhc1Jvd0RlbGltaXRlcjogZmFsc2VcbiAgICB9XG4gIH1cbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgYFRyYW5zZm9ybS5fdHJhbnNmb3JtYFxuICBfdHJhbnNmb3JtKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLnN0YXRlLnN0b3AgPT09IHRydWUpe1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGVyciA9IHRoaXMuX19wYXJzZShidWYsIGZhbHNlKVxuICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMuc3RhdGUuc3RvcCA9IHRydWVcbiAgICB9XG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGBUcmFuc2Zvcm0uX2ZsdXNoYFxuICBfZmx1c2goY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc3RhdGUuc3RvcCA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgZXJyID0gdGhpcy5fX3BhcnNlKHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbiAgLy8gQ2VudHJhbCBwYXJzZXIgaW1wbGVtZW50YXRpb25cbiAgX19wYXJzZShuZXh0QnVmLCBlbmQpe1xuICAgIGNvbnN0IHtib20sIGNvbW1lbnQsIGVzY2FwZSwgZnJvbV9saW5lLCBsdHJpbSwgbWF4X3JlY29yZF9zaXplLCBxdW90ZSwgcmF3LCByZWxheCwgcnRyaW0sIHNraXBfZW1wdHlfbGluZXMsIHRvLCB0b19saW5lfSA9IHRoaXMub3B0aW9uc1xuICAgIGxldCB7cmVjb3JkX2RlbGltaXRlcn0gPSB0aGlzLm9wdGlvbnNcbiAgICBjb25zdCB7Ym9tU2tpcHBlZCwgcHJldmlvdXNCdWYsIHJhd0J1ZmZlciwgZXNjYXBlSXNRdW90ZX0gPSB0aGlzLnN0YXRlXG4gICAgbGV0IGJ1ZlxuICAgIGlmKHByZXZpb3VzQnVmID09PSB1bmRlZmluZWQpe1xuICAgICAgaWYobmV4dEJ1ZiA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0cmluZ1xuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9ZWxzZXtcbiAgICAgICAgYnVmID0gbmV4dEJ1ZlxuICAgICAgfVxuICAgIH1lbHNlIGlmKHByZXZpb3VzQnVmICE9PSB1bmRlZmluZWQgJiYgbmV4dEJ1ZiA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIGJ1ZiA9IHByZXZpb3VzQnVmXG4gICAgfWVsc2V7XG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtwcmV2aW91c0J1ZiwgbmV4dEJ1Zl0pXG4gICAgfVxuICAgIC8vIEhhbmRsZSBVVEYgQk9NXG4gICAgaWYoYm9tU2tpcHBlZCA9PT0gZmFsc2Upe1xuICAgICAgaWYoYm9tID09PSBmYWxzZSl7XG4gICAgICAgIHRoaXMuc3RhdGUuYm9tU2tpcHBlZCA9IHRydWVcbiAgICAgIH1lbHNlIGlmKGJ1Zi5sZW5ndGggPCAzKXtcbiAgICAgICAgLy8gTm8gZW5vdWdoIGRhdGFcbiAgICAgICAgaWYoZW5kID09PSBmYWxzZSl7XG4gICAgICAgICAgLy8gV2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c0J1ZiA9IGJ1ZlxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZm9yKGxldCBlbmNvZGluZyBpbiBib21zKXtcbiAgICAgICAgICBpZihib21zW2VuY29kaW5nXS5jb21wYXJlKGJ1ZiwgMCwgYm9tc1tlbmNvZGluZ10ubGVuZ3RoKSA9PT0gMCl7XG4gICAgICAgICAgICAvLyBTa2lwIEJPTVxuICAgICAgICAgICAgbGV0IGJvbUxlbmd0aCA9IGJvbXNbZW5jb2RpbmddLmxlbmd0aFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICs9IGJvbUxlbmd0aFxuICAgICAgICAgICAgYnVmID0gYnVmLnNsaWNlKGJvbUxlbmd0aClcbiAgICAgICAgICAgIC8vIFJlbm9ybWFsaXplIG9yaWdpbmFsIG9wdGlvbnMgd2l0aCB0aGUgbmV3IGVuY29kaW5nXG4gICAgICAgICAgICB0aGlzLl9fbm9ybWFsaXplT3B0aW9ucyh7Li4udGhpcy5fX29yaWdpbmFsT3B0aW9ucywgZW5jb2Rpbmc6IGVuY29kaW5nfSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuYm9tU2tpcHBlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnVmTGVuID0gYnVmLmxlbmd0aFxuICAgIGxldCBwb3NcbiAgICBmb3IocG9zID0gMDsgcG9zIDwgYnVmTGVuOyBwb3MrKyl7XG4gICAgICAvLyBFbnN1cmUgd2UgZ2V0IGVub3VnaCBzcGFjZSB0byBsb29rIGFoZWFkXG4gICAgICAvLyBUaGVyZSBzaG91bGQgYmUgYSB3YXkgdG8gbW92ZSB0aGlzIG91dCBvZiB0aGUgbG9vcFxuICAgICAgaWYodGhpcy5fX25lZWRNb3JlRGF0YShwb3MsIGJ1ZkxlbiwgZW5kKSl7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZih0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuaW5mby5saW5lcysrXG4gICAgICAgIHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmKHRvX2xpbmUgIT09IC0xICYmIHRoaXMuaW5mby5saW5lcyA+IHRvX2xpbmUpe1xuICAgICAgICB0aGlzLnN0YXRlLnN0b3AgPSB0cnVlXG4gICAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIEF1dG8gZGlzY292ZXJ5IG9mIHJlY29yZF9kZWxpbWl0ZXIsIHVuaXgsIG1hYyBhbmQgd2luZG93cyBzdXBwb3J0ZWRcbiAgICAgIGlmKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gZmFsc2UgJiYgcmVjb3JkX2RlbGltaXRlci5sZW5ndGggPT09IDApe1xuICAgICAgICBjb25zdCByZWNvcmRfZGVsaW1pdGVyQ291bnQgPSB0aGlzLl9fYXV0b0Rpc2NvdmVyUmVjb3JkRGVsaW1pdGVyKGJ1ZiwgcG9zKVxuICAgICAgICBpZihyZWNvcmRfZGVsaW1pdGVyQ291bnQpe1xuICAgICAgICAgIHJlY29yZF9kZWxpbWl0ZXIgPSB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaHIgPSBidWZbcG9zXVxuICAgICAgaWYocmF3ID09PSB0cnVlKXtcbiAgICAgICAgcmF3QnVmZmVyLmFwcGVuZChjaHIpXG4gICAgICB9XG4gICAgICBpZigoY2hyID09PSBjciB8fCBjaHIgPT09IG5sKSAmJiB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gZmFsc2UgKXtcbiAgICAgICAgdGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPSB0cnVlXG4gICAgICB9XG4gICAgICAvLyBQcmV2aW91cyBjaGFyIHdhcyBhIHZhbGlkIGVzY2FwZSBjaGFyXG4gICAgICAvLyB0cmVhdCB0aGUgY3VycmVudCBjaGFyIGFzIGEgcmVndWxhciBjaGFyXG4gICAgICBpZih0aGlzLnN0YXRlLmVzY2FwaW5nID09PSB0cnVlKXtcbiAgICAgICAgdGhpcy5zdGF0ZS5lc2NhcGluZyA9IGZhbHNlXG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gRXNjYXBlIGlzIG9ubHkgYWN0aXZlIGluc2lkZSBxdW90ZWQgZmllbGRzXG4gICAgICAgIC8vIFdlIGFyZSBxdW90aW5nLCB0aGUgY2hhciBpcyBhbiBlc2NhcGUgY2hyIGFuZCB0aGVyZSBpcyBhIGNociB0byBlc2NhcGVcbiAgICAgICAgLy8gaWYoZXNjYXBlICE9PSBudWxsICYmIHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSAmJiBjaHIgPT09IGVzY2FwZSAmJiBwb3MgKyAxIDwgYnVmTGVuKXtcbiAgICAgICAgaWYoZXNjYXBlICE9PSBudWxsICYmIHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSAmJiB0aGlzLl9faXNFc2NhcGUoYnVmLCBwb3MsIGNocikgJiYgcG9zICsgZXNjYXBlLmxlbmd0aCA8IGJ1Zkxlbil7XG4gICAgICAgICAgaWYoZXNjYXBlSXNRdW90ZSl7XG4gICAgICAgICAgICBpZih0aGlzLl9faXNRdW90ZShidWYsIHBvcytlc2NhcGUubGVuZ3RoKSl7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSB0cnVlXG4gICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5lc2NhcGluZyA9IHRydWVcbiAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IGN1cnJlbnRseSBlc2NhcGluZyBhbmQgY2hyIGlzIGEgcXVvdGVcbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjb21wYXJlIGJ5dGVzIGluc3RlYWQgb2Ygc2luZ2xlIGNoYXJcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5jb21tZW50aW5nID09PSBmYWxzZSAmJiB0aGlzLl9faXNRdW90ZShidWYsIHBvcykpe1xuICAgICAgICAgIGlmKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hyID0gYnVmW3BvcytxdW90ZS5sZW5ndGhdXG4gICAgICAgICAgICBjb25zdCBpc05leHRDaHJUcmltYWJsZSA9IHJ0cmltICYmIHRoaXMuX19pc0NoYXJUcmltYWJsZShuZXh0Q2hyKVxuICAgICAgICAgICAgY29uc3QgaXNOZXh0Q2hyQ29tbWVudCA9IGNvbW1lbnQgIT09IG51bGwgJiYgdGhpcy5fX2NvbXBhcmVCeXRlcyhjb21tZW50LCBidWYsIHBvcytxdW90ZS5sZW5ndGgsIG5leHRDaHIpXG4gICAgICAgICAgICBjb25zdCBpc05leHRDaHJEZWxpbWl0ZXIgPSB0aGlzLl9faXNEZWxpbWl0ZXIoYnVmLCBwb3MrcXVvdGUubGVuZ3RoLCBuZXh0Q2hyKVxuICAgICAgICAgICAgY29uc3QgaXNOZXh0Q2hyUmVjb3JkRGVsaW1pdGVyID0gcmVjb3JkX2RlbGltaXRlci5sZW5ndGggPT09IDAgPyB0aGlzLl9fYXV0b0Rpc2NvdmVyUmVjb3JkRGVsaW1pdGVyKGJ1ZiwgcG9zK3F1b3RlLmxlbmd0aCkgOiB0aGlzLl9faXNSZWNvcmREZWxpbWl0ZXIobmV4dENociwgYnVmLCBwb3MrcXVvdGUubGVuZ3RoKVxuICAgICAgICAgICAgLy8gRXNjYXBlIGEgcXVvdGVcbiAgICAgICAgICAgIC8vIFRyZWF0IG5leHQgY2hhciBhcyBhIHJlZ3VsYXIgY2hhcmFjdGVyXG4gICAgICAgICAgICBpZihlc2NhcGUgIT09IG51bGwgJiYgdGhpcy5fX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpICYmIHRoaXMuX19pc1F1b3RlKGJ1ZiwgcG9zICsgZXNjYXBlLmxlbmd0aCkpe1xuICAgICAgICAgICAgICBwb3MgKz0gZXNjYXBlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIH1lbHNlIGlmKCFuZXh0Q2hyIHx8IGlzTmV4dENockRlbGltaXRlciB8fCBpc05leHRDaHJSZWNvcmREZWxpbWl0ZXIgfHwgaXNOZXh0Q2hyQ29tbWVudCB8fCBpc05leHRDaHJUcmltYWJsZSl7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUucXVvdGluZyA9IGZhbHNlXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9IHRydWVcbiAgICAgICAgICAgICAgcG9zICs9IHF1b3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1lbHNlIGlmKHJlbGF4ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX0NMT1NJTkdfUVVPVEUnLCBbXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBDbG9zaW5nIFF1b3RlOicsXG4gICAgICAgICAgICAgICAgICBgZ290IFwiJHtTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaHIpfVwiYCxcbiAgICAgICAgICAgICAgICAgIGBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiBkZWxpbWl0ZXIsIHJlY29yZCBkZWxpbWl0ZXIsIHRyaW1hYmxlIGNoYXJhY3RlcicsXG4gICAgICAgICAgICAgICAgICAnKGlmIGFjdGl2YXRlZCkgb3IgY29tbWVudCcsXG4gICAgICAgICAgICAgICAgXSwgdGhpcy5vcHRpb25zLCB0aGlzLl9faW5mb0ZpZWxkKCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSB0cnVlXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuZmllbGQucHJlcGVuZChxdW90ZSlcbiAgICAgICAgICAgICAgcG9zICs9IHF1b3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoICE9PSAwKXtcbiAgICAgICAgICAgICAgLy8gSW4gcmVsYXggbW9kZSwgdHJlYXQgb3BlbmluZyBxdW90ZSBwcmVjZWRlZCBieSBjaHJzIGFzIHJlZ3VsYXJcbiAgICAgICAgICAgICAgaWYoIHJlbGF4ID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgICAgICAgIG5ldyBDc3ZFcnJvcignSU5WQUxJRF9PUEVOSU5HX1FVT1RFJywgW1xuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBPcGVuaW5nIFF1b3RlOicsXG4gICAgICAgICAgICAgICAgICAgIGBhIHF1b3RlIGlzIGZvdW5kIGluc2lkZSBhIGZpZWxkIGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLnN0YXRlLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUucXVvdGluZyA9IHRydWVcbiAgICAgICAgICAgICAgcG9zICs9IHF1b3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5zdGF0ZS5xdW90aW5nID09PSBmYWxzZSl7XG4gICAgICAgICAgbGV0IHJlY29yZERlbGltaXRlckxlbmd0aCA9IHRoaXMuX19pc1JlY29yZERlbGltaXRlcihjaHIsIGJ1ZiwgcG9zKVxuICAgICAgICAgIGlmKHJlY29yZERlbGltaXRlckxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICAvLyBEbyBub3QgZW1pdCBjb21tZW50cyB3aGljaCB0YWtlIGEgZnVsbCBsaW5lXG4gICAgICAgICAgICBjb25zdCBza2lwQ29tbWVudExpbmUgPSB0aGlzLnN0YXRlLmNvbW1lbnRpbmcgJiYgKHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gZmFsc2UgJiYgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID09PSAwICYmIHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgaWYoc2tpcENvbW1lbnRMaW5lKXtcbiAgICAgICAgICAgICAgdGhpcy5pbmZvLmNvbW1lbnRfbGluZXMrK1xuICAgICAgICAgICAgICAvLyBTa2lwIGZ1bGwgY29tbWVudCBsaW5lXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgLy8gQWN0aXZhdGUgcmVjb3JkcyBlbWl0aW9uIGlmIGFib3ZlIGZyb21fbGluZVxuICAgICAgICAgICAgICBpZih0aGlzLnN0YXRlLmVuYWJsZWQgPT09IGZhbHNlICYmIHRoaXMuaW5mby5saW5lcyArICh0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gdHJ1ZSA/IDE6IDApID49IGZyb21fbGluZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNldEZpZWxkKClcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKVxuICAgICAgICAgICAgICAgIHBvcyArPSByZWNvcmREZWxpbWl0ZXJMZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTa2lwIGlmIGxpbmUgaXMgZW1wdHkgYW5kIHNraXBfZW1wdHlfbGluZXMgYWN0aXZhdGVkXG4gICAgICAgICAgICAgIGlmKHNraXBfZW1wdHlfbGluZXMgPT09IHRydWUgJiYgdGhpcy5zdGF0ZS53YXNRdW90aW5nID09PSBmYWxzZSAmJiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IDAgJiYgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggPT09IDApe1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5lbXB0eV9saW5lcysrXG4gICAgICAgICAgICAgICAgcG9zICs9IHJlY29yZERlbGltaXRlckxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9IHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArIHBvcztcbiAgICAgICAgICAgICAgY29uc3QgZXJyRmllbGQgPSB0aGlzLl9fb25GaWVsZCgpXG4gICAgICAgICAgICAgIGlmKGVyckZpZWxkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJGaWVsZFxuICAgICAgICAgICAgICB0aGlzLmluZm8uYnl0ZXMgPSB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKyBwb3MgKyByZWNvcmREZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IGVyclJlY29yZCA9IHRoaXMuX19vblJlY29yZCgpXG4gICAgICAgICAgICAgIGlmKGVyclJlY29yZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyUmVjb3JkXG4gICAgICAgICAgICAgIGlmKHRvICE9PSAtMSAmJiB0aGlzLmluZm8ucmVjb3JkcyA+PSB0byl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdG9wID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgcG9zICs9IHJlY29yZERlbGltaXRlckxlbmd0aCAtIDFcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuc3RhdGUuY29tbWVudGluZyl7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb21tZW50Q291bnQgPSBjb21tZW50ID09PSBudWxsID8gMCA6IHRoaXMuX19jb21wYXJlQnl0ZXMoY29tbWVudCwgYnVmLCBwb3MsIGNocilcbiAgICAgICAgICBpZihjb21tZW50Q291bnQgIT09IDApe1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb21tZW50aW5nID0gdHJ1ZVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGRlbGltaXRlckxlbmd0aCA9IHRoaXMuX19pc0RlbGltaXRlcihidWYsIHBvcywgY2hyKVxuICAgICAgICAgIGlmKGRlbGltaXRlckxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICB0aGlzLmluZm8uYnl0ZXMgPSB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKyBwb3M7XG4gICAgICAgICAgICBjb25zdCBlcnJGaWVsZCA9IHRoaXMuX19vbkZpZWxkKClcbiAgICAgICAgICAgIGlmKGVyckZpZWxkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJGaWVsZFxuICAgICAgICAgICAgcG9zICs9IGRlbGltaXRlckxlbmd0aCAtIDFcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgaWYobWF4X3JlY29yZF9zaXplICE9PSAwICYmIHRoaXMuc3RhdGUucmVjb3JkX2xlbmd0aCArIHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoID4gbWF4X3JlY29yZF9zaXplKXtcbiAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9NQVhfUkVDT1JEX1NJWkUnLCBbXG4gICAgICAgICAgICAgICdNYXggUmVjb3JkIFNpemU6JyxcbiAgICAgICAgICAgICAgJ3JlY29yZCBleGNlZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRvbGVyYXRlZCBieXRlcycsXG4gICAgICAgICAgICAgIGBvZiAke21heF9yZWNvcmRfc2l6ZX1gLFxuICAgICAgICAgICAgICBgYXQgbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgICAgXSwgdGhpcy5vcHRpb25zLCB0aGlzLl9faW5mb0ZpZWxkKCkpXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhcHBlbmQgPSBsdHJpbSA9PT0gZmFsc2UgfHwgdGhpcy5zdGF0ZS5xdW90aW5nID09PSB0cnVlIHx8IHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoICE9PSAwIHx8ICF0aGlzLl9faXNDaGFyVHJpbWFibGUoY2hyKVxuICAgICAgLy8gcnRyaW0gaW4gbm9uIHF1b3RpbmcgaXMgaGFuZGxlIGluIF9fb25GaWVsZFxuICAgICAgY29uc3QgcmFwcGVuZCA9IHJ0cmltID09PSBmYWxzZSB8fCB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IGZhbHNlXG4gICAgICBpZiggbGFwcGVuZCA9PT0gdHJ1ZSAmJiByYXBwZW5kID09PSB0cnVlICl7XG4gICAgICAgIHRoaXMuc3RhdGUuZmllbGQuYXBwZW5kKGNocilcbiAgICAgIH1lbHNlIGlmKHJ0cmltID09PSB0cnVlICYmICF0aGlzLl9faXNDaGFyVHJpbWFibGUoY2hyKSl7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9OT05fVFJJTUFCTEVfQ0hBUl9BRlRFUl9DTE9TSU5HX1FVT1RFJywgW1xuICAgICAgICAgICAgJ0ludmFsaWQgQ2xvc2luZyBRdW90ZTonLFxuICAgICAgICAgICAgJ2ZvdW5kIG5vbiB0cmltYWJsZSBieXRlIGFmdGVyIHF1b3RlJyxcbiAgICAgICAgICAgIGBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgXSwgdGhpcy5vcHRpb25zLCB0aGlzLl9faW5mb0ZpZWxkKCkpXG4gICAgICAgIClcbiAgICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZW5kID09PSB0cnVlKXtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhcmUgbm90IGVuZGluZyBpbiBhIHF1b3Rpbmcgc3RhdGVcbiAgICAgIGlmKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSl7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9RVU9URV9OT1RfQ0xPU0VEJywgW1xuICAgICAgICAgICAgJ1F1b3RlIE5vdCBDbG9zZWQ6JyxcbiAgICAgICAgICAgIGB0aGUgcGFyc2luZyBpcyBmaW5pc2hlZCB3aXRoIGFuIG9wZW5pbmcgcXVvdGUgYXQgbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpKVxuICAgICAgICApXG4gICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyXG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gU2tpcCBsYXN0IGxpbmUgaWYgaXQgaGFzIG5vIGNoYXJhY3RlcnNcbiAgICAgICAgaWYodGhpcy5zdGF0ZS53YXNRdW90aW5nID09PSB0cnVlIHx8IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCAhPT0gMCB8fCB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zO1xuICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKVxuICAgICAgICAgIGlmKGVyckZpZWxkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJGaWVsZFxuICAgICAgICAgIGNvbnN0IGVyclJlY29yZCA9IHRoaXMuX19vblJlY29yZCgpXG4gICAgICAgICAgaWYoZXJyUmVjb3JkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJSZWNvcmRcbiAgICAgICAgfWVsc2UgaWYodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUpe1xuICAgICAgICAgIHRoaXMuaW5mby5lbXB0eV9saW5lcysrXG4gICAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUuY29tbWVudGluZyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgdGhpcy5pbmZvLmNvbW1lbnRfbGluZXMrK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKz0gcG9zXG4gICAgICB0aGlzLnN0YXRlLnByZXZpb3VzQnVmID0gYnVmLnNsaWNlKHBvcylcbiAgICB9XG4gICAgaWYodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUpe1xuICAgICAgdGhpcy5pbmZvLmxpbmVzKytcbiAgICAgIHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID0gZmFsc2VcbiAgICB9XG4gIH1cbiAgX19vblJlY29yZCgpe1xuICAgIGNvbnN0IHtjb2x1bW5zLCBjb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXksIGVuY29kaW5nLCBpbmZvLCBmcm9tLCByZWxheF9jb2x1bW5fY291bnQsIHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzLCByZWxheF9jb2x1bW5fY291bnRfbW9yZSwgcmF3LCBza2lwX2xpbmVzX3dpdGhfZW1wdHlfdmFsdWVzfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IHtlbmFibGVkLCByZWNvcmR9ID0gdGhpcy5zdGF0ZVxuICAgIGlmKGVuYWJsZWQgPT09IGZhbHNlKXtcbiAgICAgIHJldHVybiB0aGlzLl9fcmVzZXRSZWNvcmQoKVxuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBmaXJzdCBsaW5lIGludG8gY29sdW1uIG5hbWVzXG4gICAgY29uc3QgcmVjb3JkTGVuZ3RoID0gcmVjb3JkLmxlbmd0aFxuICAgIGlmKGNvbHVtbnMgPT09IHRydWUpe1xuICAgICAgaWYoc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyA9PT0gdHJ1ZSAmJiBpc1JlY29yZEVtcHR5KHJlY29yZCkpe1xuICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fZmlyc3RMaW5lVG9Db2x1bW5zKHJlY29yZClcbiAgICB9XG4gICAgaWYoY29sdW1ucyA9PT0gZmFsc2UgJiYgdGhpcy5pbmZvLnJlY29yZHMgPT09IDApe1xuICAgICAgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCA9IHJlY29yZExlbmd0aFxuICAgIH1cbiAgICBpZihyZWNvcmRMZW5ndGggIT09IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpe1xuICAgICAgY29uc3QgZXJyID0gY29sdW1ucyA9PT0gZmFsc2UgP1xuICAgICAgICAvLyBUb2RvOiByZW5hbWUgQ1NWX0lOQ09OU0lTVEVOVF9SRUNPUkRfTEVOR1RIIHRvXG4gICAgICAgIC8vIENTVl9SRUNPUkRfSU5DT05TSVNURU5UX0ZJRUxEU19MRU5HVEhcbiAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfSU5DT05TSVNURU5UX1JFQ09SRF9MRU5HVEgnLCBbXG4gICAgICAgICAgJ0ludmFsaWQgUmVjb3JkIExlbmd0aDonLFxuICAgICAgICAgIGBleHBlY3QgJHt0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RofSxgLFxuICAgICAgICAgIGBnb3QgJHtyZWNvcmRMZW5ndGh9IG9uIGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgXSwgdGhpcy5vcHRpb25zLCB0aGlzLl9faW5mb0ZpZWxkKCksIHtcbiAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgfSlcbiAgICAgIDpcbiAgICAgICAgLy8gVG9kbzogcmVuYW1lIENTVl9SRUNPUkRfRE9OVF9NQVRDSF9DT0xVTU5TX0xFTkdUSCB0b1xuICAgICAgICAvLyBDU1ZfUkVDT1JEX0lOQ09OU0lTVEVOVF9DT0xVTU5TXG4gICAgICAgIG5ldyBDc3ZFcnJvcignQ1NWX1JFQ09SRF9ET05UX01BVENIX0NPTFVNTlNfTEVOR1RIJywgW1xuICAgICAgICAgICdJbnZhbGlkIFJlY29yZCBMZW5ndGg6JyxcbiAgICAgICAgICBgY29sdW1ucyBsZW5ndGggaXMgJHtjb2x1bW5zLmxlbmd0aH0sYCwgLy8gcmVuYW1lIGNvbHVtbnNcbiAgICAgICAgICBgZ290ICR7cmVjb3JkTGVuZ3RofSBvbiBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgIH0pXG4gICAgICBpZihyZWxheF9jb2x1bW5fY291bnQgPT09IHRydWUgfHxcbiAgICAgICAgKHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSB0cnVlICYmIHJlY29yZExlbmd0aCA8IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpIHx8XG4gICAgICAgIChyZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gdHJ1ZSAmJiByZWNvcmRMZW5ndGggPiB0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RoKSApe1xuICAgICAgICB0aGlzLmluZm8uaW52YWxpZF9maWVsZF9sZW5ndGgrK1xuICAgICAgICB0aGlzLnN0YXRlLmVycm9yID0gZXJyXG4gICAgICAvLyBFcnJvciBpcyB1bmRlZmluZWQgd2l0aCBza2lwX2xpbmVzX3dpdGhfZXJyb3JcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zdCBmaW5hbEVyciA9IHRoaXMuX19lcnJvcihlcnIpXG4gICAgICAgIGlmKGZpbmFsRXJyKSByZXR1cm4gZmluYWxFcnJcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyA9PT0gdHJ1ZSAmJiBpc1JlY29yZEVtcHR5KHJlY29yZCkpe1xuICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZih0aGlzLnN0YXRlLnJlY29yZEhhc0Vycm9yID09PSB0cnVlKXtcbiAgICAgIHRoaXMuX19yZXNldFJlY29yZCgpXG4gICAgICB0aGlzLnN0YXRlLnJlY29yZEhhc0Vycm9yID0gZmFsc2VcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmluZm8ucmVjb3JkcysrXG4gICAgaWYoZnJvbSA9PT0gMSB8fCB0aGlzLmluZm8ucmVjb3JkcyA+PSBmcm9tKXtcbiAgICAgIC8vIFdpdGggY29sdW1ucywgcmVjb3JkcyBhcmUgb2JqZWN0XG4gICAgICBpZihjb2x1bW5zICE9PSBmYWxzZSl7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgICAgIC8vIFRyYW5zZm9ybSByZWNvcmQgYXJyYXkgdG8gYW4gb2JqZWN0XG4gICAgICAgIGZvcihsZXQgaSA9IDAsIGwgPSByZWNvcmQubGVuZ3RoOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgICBpZihjb2x1bW5zW2ldID09PSB1bmRlZmluZWQgfHwgY29sdW1uc1tpXS5kaXNhYmxlZCkgY29udGludWVcbiAgICAgICAgICAvLyBUdXJuIGR1cGxpY2F0ZSBjb2x1bW5zIGludG8gYW4gYXJyYXlcbiAgICAgICAgICBpZiAoY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5ID09PSB0cnVlICYmIG9ialtjb2x1bW5zW2ldLm5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtjb2x1bW5zW2ldLm5hbWVdKSkge1xuICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IG9ialtjb2x1bW5zW2ldLm5hbWVdLmNvbmNhdChyZWNvcmRbaV0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IFtvYmpbY29sdW1uc1tpXS5uYW1lXSwgcmVjb3JkW2ldXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IHJlY29yZFtpXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7b2JqbmFtZX0gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgLy8gV2l0aG91dCBvYmpuYW1lIChkZWZhdWx0KVxuICAgICAgICBpZihvYmpuYW1lID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgIGlmKHJhdyA9PT0gdHJ1ZSB8fCBpbmZvID09PSB0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHtyZWNvcmQ6IG9ian0sXG4gICAgICAgICAgICAgIChyYXcgPT09IHRydWUgPyB7cmF3OiB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZyl9OiB7fSksXG4gICAgICAgICAgICAgIChpbmZvID09PSB0cnVlID8ge2luZm86IHRoaXMuX19pbmZvUmVjb3JkKCl9OiB7fSlcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChvYmopXG4gICAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBXaXRoIG9iam5hbWUgKGRlZmF1bHQpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGlmKHJhdyA9PT0gdHJ1ZSB8fCBpbmZvID09PSB0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHtyZWNvcmQ6IFtvYmpbb2JqbmFtZV0sIG9ial19LFxuICAgICAgICAgICAgICByYXcgPT09IHRydWUgPyB7cmF3OiB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZyl9OiB7fSxcbiAgICAgICAgICAgICAgaW5mbyA9PT0gdHJ1ZSA/IHtpbmZvOiB0aGlzLl9faW5mb1JlY29yZCgpfToge31cbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChbb2JqW29iam5hbWVdLCBvYmpdKVxuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgLy8gV2l0aG91dCBjb2x1bW5zLCByZWNvcmRzIGFyZSBhcnJheVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKHJhdyA9PT0gdHJ1ZSB8fCBpbmZvID09PSB0cnVlKXtcbiAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge3JlY29yZDogcmVjb3JkfSxcbiAgICAgICAgICAgIHJhdyA9PT0gdHJ1ZSA/IHtyYXc6IHRoaXMuc3RhdGUucmF3QnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKX06IHt9LFxuICAgICAgICAgICAgaW5mbyA9PT0gdHJ1ZSA/IHtpbmZvOiB0aGlzLl9faW5mb1JlY29yZCgpfToge31cbiAgICAgICAgICApKVxuICAgICAgICAgIGlmKGVycil7XG4gICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChyZWNvcmQpXG4gICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgIHJldHVybiBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX3Jlc2V0UmVjb3JkKClcbiAgfVxuICBfX2ZpcnN0TGluZVRvQ29sdW1ucyhyZWNvcmQpe1xuICAgIGNvbnN0IHtmaXJzdExpbmVUb0hlYWRlcnN9ID0gdGhpcy5zdGF0ZVxuICAgIHRyeXtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBmaXJzdExpbmVUb0hlYWRlcnMgPT09IHVuZGVmaW5lZCA/IHJlY29yZCA6IGZpcnN0TGluZVRvSGVhZGVycy5jYWxsKG51bGwsIHJlY29yZClcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KGhlYWRlcnMpKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lcnJvcihcbiAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX0NPTFVNTl9NQVBQSU5HJywgW1xuICAgICAgICAgICAgJ0ludmFsaWQgQ29sdW1uIE1hcHBpbmc6JyxcbiAgICAgICAgICAgICdleHBlY3QgYW4gYXJyYXkgZnJvbSBjb2x1bW4gZnVuY3Rpb24sJyxcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShoZWFkZXJzKX1gXG4gICAgICAgICAgXSwgdGhpcy5vcHRpb25zLCB0aGlzLl9faW5mb0ZpZWxkKCksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBub3JtYWxpemVDb2x1bW5zQXJyYXkoaGVhZGVycylcbiAgICAgIHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGggPSBub3JtYWxpemVkSGVhZGVycy5sZW5ndGhcbiAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID0gbm9ybWFsaXplZEhlYWRlcnNcbiAgICAgIHRoaXMuX19yZXNldFJlY29yZCgpXG4gICAgICByZXR1cm5cbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIHJldHVybiBlcnJcbiAgICB9XG4gIH1cbiAgX19yZXNldFJlY29yZCgpe1xuICAgIGlmKHRoaXMub3B0aW9ucy5yYXcgPT09IHRydWUpe1xuICAgICAgdGhpcy5zdGF0ZS5yYXdCdWZmZXIucmVzZXQoKVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLmVycm9yID0gdW5kZWZpbmVkXG4gICAgdGhpcy5zdGF0ZS5yZWNvcmQgPSBbXVxuICAgIHRoaXMuc3RhdGUucmVjb3JkX2xlbmd0aCA9IDBcbiAgfVxuICBfX29uRmllbGQoKXtcbiAgICBjb25zdCB7Y2FzdCwgZW5jb2RpbmcsIHJ0cmltLCBtYXhfcmVjb3JkX3NpemV9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3Qge2VuYWJsZWQsIHdhc1F1b3Rpbmd9ID0gdGhpcy5zdGF0ZVxuICAgIC8vIFNob3J0IGNpcmN1aXQgZm9yIHRoZSBmcm9tX2xpbmUgb3B0aW9uc1xuICAgIGlmKGVuYWJsZWQgPT09IGZhbHNlKXtcbiAgICAgIHJldHVybiB0aGlzLl9fcmVzZXRGaWVsZCgpXG4gICAgfVxuICAgIGxldCBmaWVsZCA9IHRoaXMuc3RhdGUuZmllbGQudG9TdHJpbmcoZW5jb2RpbmcpXG4gICAgaWYocnRyaW0gPT09IHRydWUgJiYgd2FzUXVvdGluZyA9PT0gZmFsc2Upe1xuICAgICAgZmllbGQgPSBmaWVsZC50cmltUmlnaHQoKVxuICAgIH1cbiAgICBpZihjYXN0ID09PSB0cnVlKXtcbiAgICAgIGNvbnN0IFtlcnIsIGZdID0gdGhpcy5fX2Nhc3QoZmllbGQpXG4gICAgICBpZihlcnIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclxuICAgICAgZmllbGQgPSBmXG4gICAgfVxuICAgIHRoaXMuc3RhdGUucmVjb3JkLnB1c2goZmllbGQpXG4gICAgLy8gSW5jcmVtZW50IHJlY29yZCBsZW5ndGggaWYgcmVjb3JkIHNpemUgbXVzdCBub3QgZXhjZWVkIGEgbGltaXRcbiAgICBpZihtYXhfcmVjb3JkX3NpemUgIT09IDAgJiYgdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyl7XG4gICAgICB0aGlzLnN0YXRlLnJlY29yZF9sZW5ndGggKz0gZmllbGQubGVuZ3RoXG4gICAgfVxuICAgIHRoaXMuX19yZXNldEZpZWxkKClcbiAgfVxuICBfX3Jlc2V0RmllbGQoKXtcbiAgICB0aGlzLnN0YXRlLmZpZWxkLnJlc2V0KClcbiAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSBmYWxzZVxuICB9XG4gIF9fcHVzaChyZWNvcmQpe1xuICAgIGNvbnN0IHtvbl9yZWNvcmR9ID0gdGhpcy5vcHRpb25zXG4gICAgaWYob25fcmVjb3JkICE9PSB1bmRlZmluZWQpe1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX19pbmZvUmVjb3JkKClcbiAgICAgIHRyeXtcbiAgICAgICAgcmVjb3JkID0gb25fcmVjb3JkLmNhbGwobnVsbCwgcmVjb3JkLCBpbmZvKVxuICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgIHJldHVybiBlcnJcbiAgICAgIH1cbiAgICAgIGlmKHJlY29yZCA9PT0gdW5kZWZpbmVkIHx8IHJlY29yZCA9PT0gbnVsbCl7IHJldHVybiB9XG4gICAgfVxuICAgIHRoaXMucHVzaChyZWNvcmQpXG4gIH1cbiAgLy8gUmV0dXJuIGEgdHVwbGUgd2l0aCB0aGUgZXJyb3IgYW5kIHRoZSBjYXN0ZWQgdmFsdWVcbiAgX19jYXN0KGZpZWxkKXtcbiAgICBjb25zdCB7Y29sdW1ucywgcmVsYXhfY29sdW1uX2NvdW50fSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IGlzQ29sdW1ucyA9IEFycmF5LmlzQXJyYXkoY29sdW1ucylcbiAgICAvLyBEb250IGxvb3NlIHRpbWUgY2FsbGluZyBjYXN0XG4gICAgLy8gYmVjYXVzZSB0aGUgZmluYWwgcmVjb3JkIGlzIGFuIG9iamVjdFxuICAgIC8vIGFuZCB0aGlzIGZpZWxkIGNhbid0IGJlIGFzc29jaWF0ZWQgdG8gYSBrZXkgcHJlc2VudCBpbiBjb2x1bW5zXG4gICAgaWYoIGlzQ29sdW1ucyA9PT0gdHJ1ZSAmJiByZWxheF9jb2x1bW5fY291bnQgJiYgdGhpcy5vcHRpb25zLmNvbHVtbnMubGVuZ3RoIDw9IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCApe1xuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICB9XG4gICAgaWYodGhpcy5zdGF0ZS5jYXN0RmllbGQgIT09IG51bGwpe1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5fX2luZm9GaWVsZCgpXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLnN0YXRlLmNhc3RGaWVsZC5jYWxsKG51bGwsIGZpZWxkLCBpbmZvKV1cbiAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICByZXR1cm4gW2Vycl1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYodGhpcy5fX2lzRmxvYXQoZmllbGQpKXtcbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBwYXJzZUZsb2F0KGZpZWxkKV1cbiAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMuY2FzdF9kYXRlICE9PSBmYWxzZSl7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5fX2luZm9GaWVsZCgpXG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3RfZGF0ZS5jYWxsKG51bGwsIGZpZWxkLCBpbmZvKV1cbiAgICB9XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGZpZWxkXVxuICB9XG4gIC8vIEhlbHBlciB0byB0ZXN0IGlmIGEgY2hhcmFjdGVyIGlzIGEgc3BhY2Ugb3IgYSBsaW5lIGRlbGltaXRlclxuICBfX2lzQ2hhclRyaW1hYmxlKGNocil7XG4gICAgcmV0dXJuIGNociA9PT0gc3BhY2UgfHwgY2hyID09PSB0YWIgfHwgY2hyID09PSBjciB8fCBjaHIgPT09IG5sIHx8IGNociA9PT0gbnBcbiAgfVxuICAvLyBLZWVwIGl0IGluIGNhc2Ugd2UgaW1wbGVtZW50IHRoZSBgY2FzdF9pbnRgIG9wdGlvblxuICAvLyBfX2lzSW50KHZhbHVlKXtcbiAgLy8gICAvLyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludCh2YWx1ZSkpXG4gIC8vICAgLy8gcmV0dXJuICFpc05hTiggcGFyc2VJbnQoIG9iaiApICk7XG4gIC8vICAgcmV0dXJuIC9eKFxcLXxcXCspP1sxLTldWzAtOV0qJC8udGVzdCh2YWx1ZSlcbiAgLy8gfVxuICBfX2lzRmxvYXQodmFsdWUpe1xuICAgIHJldHVybiAodmFsdWUgLSBwYXJzZUZsb2F0KCB2YWx1ZSApICsgMSkgPj0gMCAvLyBCb3Jyb3dlZCBmcm9tIGpxdWVyeVxuICB9XG4gIF9fY29tcGFyZUJ5dGVzKHNvdXJjZUJ1ZiwgdGFyZ2V0QnVmLCB0YXJnZXRQb3MsIGZpcnN0Qnl0ZSl7XG4gICAgaWYoc291cmNlQnVmWzBdICE9PSBmaXJzdEJ5dGUpIHJldHVybiAwXG4gICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlQnVmLmxlbmd0aFxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzb3VyY2VMZW5ndGg7IGkrKyl7XG4gICAgICBpZihzb3VyY2VCdWZbaV0gIT09IHRhcmdldEJ1Zlt0YXJnZXRQb3MraV0pIHJldHVybiAwXG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VMZW5ndGhcbiAgfVxuICBfX25lZWRNb3JlRGF0YShpLCBidWZMZW4sIGVuZCl7XG4gICAgaWYoZW5kKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCB7cXVvdGV9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3Qge3F1b3RpbmcsIG5lZWRNb3JlRGF0YVNpemUsIHJlY29yZERlbGltaXRlck1heExlbmd0aH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgbnVtT2ZDaGFyTGVmdCA9IGJ1ZkxlbiAtIGkgLSAxXG4gICAgY29uc3QgcmVxdWlyZWRMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIG5lZWRNb3JlRGF0YVNpemUsXG4gICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIHNtYWxsZXIgdGhhbiByZWNvcmQgZGVsaW1pdGVyXG4gICAgICByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgsXG4gICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIGNhbiBiZSByZWNvcmQgZGVsaW1pdGVyIGZvbGxvd2luZyB0aGUgY2xvc2luZyBxdW90ZVxuICAgICAgLy8gMSBpcyBmb3IgcXVvdGUubGVuZ3RoXG4gICAgICBxdW90aW5nID8gKHF1b3RlLmxlbmd0aCArIHJlY29yZERlbGltaXRlck1heExlbmd0aCkgOiAwLFxuICAgIClcbiAgICByZXR1cm4gbnVtT2ZDaGFyTGVmdCA8IHJlcXVpcmVkTGVuZ3RoXG4gIH1cbiAgX19pc0RlbGltaXRlcihidWYsIHBvcywgY2hyKXtcbiAgICBjb25zdCB7ZGVsaW1pdGVyLCBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzfSA9IHRoaXMub3B0aW9uc1xuICAgIGlmKGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IHRydWUgJiYgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID09PSB0aGlzLm9wdGlvbnMuY29sdW1ucy5sZW5ndGggLSAxKXtcbiAgICAgIHJldHVybiAwXG4gICAgfWVsc2UgaWYoaWdub3JlX2xhc3RfZGVsaW1pdGVycyAhPT0gZmFsc2UgJiYgdHlwZW9mIGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09ICdudW1iZXInICYmIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gaWdub3JlX2xhc3RfZGVsaW1pdGVycyAtIDEpe1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgbG9vcDE6IGZvcihsZXQgaSA9IDA7IGkgPCBkZWxpbWl0ZXIubGVuZ3RoOyBpKyspe1xuICAgICAgY29uc3QgZGVsID0gZGVsaW1pdGVyW2ldXG4gICAgICBpZihkZWxbMF0gPT09IGNocil7XG4gICAgICAgIGZvcihsZXQgaiA9IDE7IGogPCBkZWwubGVuZ3RoOyBqKyspe1xuICAgICAgICAgIGlmKGRlbFtqXSAhPT0gYnVmW3BvcytqXSkgY29udGludWUgbG9vcDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG4gIF9faXNSZWNvcmREZWxpbWl0ZXIoY2hyLCBidWYsIHBvcyl7XG4gICAgY29uc3Qge3JlY29yZF9kZWxpbWl0ZXJ9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3QgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoID0gcmVjb3JkX2RlbGltaXRlci5sZW5ndGhcbiAgICBsb29wMTogZm9yKGxldCBpID0gMDsgaSA8IHJlY29yZERlbGltaXRlckxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IHJkID0gcmVjb3JkX2RlbGltaXRlcltpXVxuICAgICAgY29uc3QgcmRMZW5ndGggPSByZC5sZW5ndGhcbiAgICAgIGlmKHJkWzBdICE9PSBjaHIpe1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZm9yKGxldCBqID0gMTsgaiA8IHJkTGVuZ3RoOyBqKyspe1xuICAgICAgICBpZihyZFtqXSAhPT0gYnVmW3BvcytqXSl7XG4gICAgICAgICAgY29udGludWUgbG9vcDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJkLmxlbmd0aFxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG4gIF9faXNFc2NhcGUoYnVmLCBwb3MsIGNocil7XG4gICAgY29uc3Qge2VzY2FwZX0gPSB0aGlzLm9wdGlvbnNcbiAgICBpZihlc2NhcGUgPT09IG51bGwpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGwgPSBlc2NhcGUubGVuZ3RoXG4gICAgaWYoZXNjYXBlWzBdID09PSBjaHIpe1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGlmKGVzY2FwZVtpXSAhPT0gYnVmW3BvcytpXSl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIF9faXNRdW90ZShidWYsIHBvcyl7XG4gICAgY29uc3Qge3F1b3RlfSA9IHRoaXMub3B0aW9uc1xuICAgIGlmKHF1b3RlID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBsID0gcXVvdGUubGVuZ3RoXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICBpZihxdW90ZVtpXSAhPT0gYnVmW3BvcytpXSl7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIF9fYXV0b0Rpc2NvdmVyUmVjb3JkRGVsaW1pdGVyKGJ1ZiwgcG9zKXtcbiAgICBjb25zdCB7ZW5jb2Rpbmd9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3QgY2hyID0gYnVmW3Bvc11cbiAgICBpZihjaHIgPT09IGNyKXtcbiAgICAgIGlmKGJ1Zltwb3MrMV0gPT09IG5sKXtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIucHVzaChCdWZmZXIuZnJvbSgnXFxyXFxuJywgZW5jb2RpbmcpKVxuICAgICAgICB0aGlzLnN0YXRlLnJlY29yZERlbGltaXRlck1heExlbmd0aCA9IDJcbiAgICAgICAgcmV0dXJuIDJcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlci5wdXNoKEJ1ZmZlci5mcm9tKCdcXHInLCBlbmNvZGluZykpXG4gICAgICAgIHRoaXMuc3RhdGUucmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoID0gMVxuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgIH1lbHNlIGlmKGNociA9PT0gbmwpe1xuICAgICAgdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIucHVzaChCdWZmZXIuZnJvbSgnXFxuJywgZW5jb2RpbmcpKVxuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGggPSAxXG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG4gIF9fZXJyb3IobXNnKXtcbiAgICBjb25zdCB7c2tpcF9saW5lc193aXRoX2Vycm9yfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IGVyciA9IHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKG1zZykgOiBtc2dcbiAgICBpZihza2lwX2xpbmVzX3dpdGhfZXJyb3Ipe1xuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRIYXNFcnJvciA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnc2tpcCcsIGVycilcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBlcnJcbiAgICB9XG4gIH1cbiAgX19pbmZvRGF0YVNldCgpe1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmluZm8sXG4gICAgICBjb2x1bW5zOiB0aGlzLm9wdGlvbnMuY29sdW1uc1xuICAgIH1cbiAgfVxuICBfX2luZm9SZWNvcmQoKXtcbiAgICBjb25zdCB7Y29sdW1uc30gPSB0aGlzLm9wdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5fX2luZm9EYXRhU2V0KCksXG4gICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgIGhlYWRlcjogY29sdW1ucyA9PT0gdHJ1ZSxcbiAgICAgIGluZGV4OiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGgsXG4gICAgfVxuICB9XG4gIF9faW5mb0ZpZWxkKCl7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3QgaXNDb2x1bW5zID0gQXJyYXkuaXNBcnJheShjb2x1bW5zKVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLl9faW5mb1JlY29yZCgpLFxuICAgICAgY29sdW1uOiBpc0NvbHVtbnMgPT09IHRydWUgP1xuICAgICAgICAoIGNvbHVtbnMubGVuZ3RoID4gdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID9cbiAgICAgICAgICBjb2x1bW5zW3RoaXMuc3RhdGUucmVjb3JkLmxlbmd0aF0ubmFtZSA6XG4gICAgICAgICAgbnVsbFxuICAgICAgICApIDpcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoLFxuICAgICAgcXVvdGluZzogdGhpcy5zdGF0ZS53YXNRdW90aW5nLFxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uKCl7XG4gIGxldCBkYXRhLCBvcHRpb25zLCBjYWxsYmFja1xuICBmb3IobGV0IGkgaW4gYXJndW1lbnRzKXtcbiAgICBjb25zdCBhcmd1bWVudCA9IGFyZ3VtZW50c1tpXVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnRcbiAgICBpZihkYXRhID09PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKGFyZ3VtZW50KSkpe1xuICAgICAgZGF0YSA9IGFyZ3VtZW50XG4gICAgfWVsc2UgaWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KGFyZ3VtZW50KSl7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRcbiAgICB9ZWxzZSBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudFxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9BUkdVTUVOVCcsIFtcbiAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQ6JyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KGFyZ3VtZW50KX0gYXQgaW5kZXggJHtpfWBcbiAgICAgIF0sIG9wdGlvbnMgfHwge30pXG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucylcbiAgaWYoY2FsbGJhY2spe1xuICAgIGNvbnN0IHJlY29yZHMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vYmpuYW1lID09PSB1bmRlZmluZWQgPyBbXSA6IHt9XG4gICAgcGFyc2VyLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICBsZXQgcmVjb3JkXG4gICAgICB3aGlsZSgocmVjb3JkID0gdGhpcy5yZWFkKCkpICE9PSBudWxsKXtcbiAgICAgICAgaWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub2JqbmFtZSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZWNvcmRzW3JlY29yZFswXV0gPSByZWNvcmRbMV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgICBjYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgcGFyc2VyLl9faW5mb0RhdGFTZXQoKSlcbiAgICB9KVxuICAgIHBhcnNlci5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVjb3JkcywgcGFyc2VyLl9faW5mb0RhdGFTZXQoKSlcbiAgICB9KVxuICB9XG4gIGlmKGRhdGEgIT09IHVuZGVmaW5lZCl7XG4gICAgLy8gR2l2ZSBhIGNoYW5jZSBmb3IgZXZlbnRzIHRvIGJlIHJlZ2lzdGVyZWQgbGF0ZXJcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpe1xuICAgICAgICBwYXJzZXIud3JpdGUoZGF0YSlcbiAgICAgICAgcGFyc2VyLmVuZCgpXG4gICAgICB9KVxuICAgIH1lbHNle1xuICAgICAgcGFyc2VyLndyaXRlKGRhdGEpXG4gICAgICBwYXJzZXIuZW5kKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlclxufVxuXG5jbGFzcyBDc3ZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgb3B0aW9ucywgLi4uY29udGV4dHMpIHtcbiAgICBpZihBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSBtZXNzYWdlID0gbWVzc2FnZS5qb2luKCcgJylcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSB1bmRlZmluZWQpe1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3N2RXJyb3IpXG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICBmb3IoY29uc3QgY29udGV4dCBvZiBjb250ZXh0cyl7XG4gICAgICBmb3IoY29uc3Qga2V5IGluIGNvbnRleHQpe1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRba2V5XVxuICAgICAgICB0aGlzW2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUudG9TdHJpbmcob3B0aW9ucy5lbmNvZGluZykgOiB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxucGFyc2UuUGFyc2VyID0gUGFyc2VyXG5cbnBhcnNlLkNzdkVycm9yID0gQ3N2RXJyb3JcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuXG5jb25zdCB1bmRlcnNjb3JlID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKF8sIG1hdGNoKXtcbiAgICByZXR1cm4gJ18nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxuICB9KVxufVxuXG5jb25zdCBpc09iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG9iaikpXG59XG5cbmNvbnN0IGlzUmVjb3JkRW1wdHkgPSBmdW5jdGlvbihyZWNvcmQpe1xuICByZXR1cm4gcmVjb3JkLmV2ZXJ5KCAoZmllbGQpID0+IGZpZWxkID09IG51bGwgfHwgZmllbGQudG9TdHJpbmcgJiYgZmllbGQudG9TdHJpbmcoKS50cmltKCkgPT09ICcnIClcbn1cblxuY29uc3Qgbm9ybWFsaXplQ29sdW1uc0FycmF5ID0gZnVuY3Rpb24oY29sdW1ucyl7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2x1bW5zID0gW107XG4gIGZvcihsZXQgaSA9IDAsIGwgPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpXVxuICAgIGlmKGNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IGZhbHNlKXtcbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0geyBkaXNhYmxlZDogdHJ1ZSB9XG4gICAgfWVsc2UgaWYodHlwZW9mIGNvbHVtbiA9PT0gJ3N0cmluZycpe1xuICAgICAgbm9ybWFsaXplZENvbHVtbnNbaV0gPSB7IG5hbWU6IGNvbHVtbiB9XG4gICAgfWVsc2UgaWYoaXNPYmplY3QoY29sdW1uKSl7XG4gICAgICBpZih0eXBlb2YgY29sdW1uLm5hbWUgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfT1BUSU9OX0NPTFVNTlNfTUlTU0lOR19OQU1FJywgW1xuICAgICAgICAgICdPcHRpb24gY29sdW1ucyBtaXNzaW5nIG5hbWU6JyxcbiAgICAgICAgICBgcHJvcGVydHkgXCJuYW1lXCIgaXMgcmVxdWlyZWQgYXQgcG9zaXRpb24gJHtpfWAsXG4gICAgICAgICAgJ3doZW4gY29sdW1uIGlzIGFuIG9iamVjdCBsaXRlcmFsJ1xuICAgICAgICBdKVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplZENvbHVtbnNbaV0gPSBjb2x1bW5cbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfQ09MVU1OX0RFRklOSVRJT04nLCBbXG4gICAgICAgICdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOicsXG4gICAgICAgICdleHBlY3QgYSBzdHJpbmcgb3IgYSBsaXRlcmFsIG9iamVjdCwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkoY29sdW1uKX0gYXQgcG9zaXRpb24gJHtpfWBcbiAgICAgIF0pXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkQ29sdW1ucztcbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwiUmVzaXplYWJsZUJ1ZmZlciIsInRhYiIsIm5sIiwibnAiLCJjciIsInNwYWNlIiwiYm9tcyIsIkJ1ZmZlciIsImZyb20iLCJQYXJzZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJlbmNvZGluZyIsIl9fb3JpZ2luYWxPcHRpb25zIiwiX19ub3JtYWxpemVPcHRpb25zIiwib3B0aW9ucyIsIm9wdCIsInVuZGVyc2NvcmUiLCJ1bmRlZmluZWQiLCJDc3ZFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJib20iLCJmbkNhc3RGaWVsZCIsImNhc3QiLCJjYXN0X2RhdGUiLCJ2YWx1ZSIsImRhdGUiLCJEYXRlIiwicGFyc2UiLCJpc05hTiIsImZuRmlyc3RMaW5lVG9IZWFkZXJzIiwiY29sdW1ucyIsIkFycmF5IiwiaXNBcnJheSIsIm5vcm1hbGl6ZUNvbHVtbnNBcnJheSIsImNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSIsImNvbW1lbnQiLCJpc0J1ZmZlciIsImRlbGltaXRlcl9qc29uIiwiZGVsaW1pdGVyIiwibGVuZ3RoIiwibWFwIiwiZXNjYXBlIiwiRXJyb3IiLCJ0ZXN0IiwicGFyc2VJbnQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJmcm9tX2xpbmUiLCJpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzIiwiTWF0aCIsImZsb29yIiwiaW5mbyIsIm1heF9yZWNvcmRfc2l6ZSIsIm9iam5hbWUiLCJ0b1N0cmluZyIsIm9uX3JlY29yZCIsInF1b3RlIiwicmF3IiwicmVjb3JkX2RlbGltaXRlciIsInJkIiwicmVsYXgiLCJyZWxheF9jb2x1bW5fY291bnQiLCJyZWxheF9jb2x1bW5fY291bnRfbGVzcyIsInJlbGF4X2NvbHVtbl9jb3VudF9tb3JlIiwic2tpcF9lbXB0eV9saW5lcyIsInNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMiLCJza2lwX2xpbmVzX3dpdGhfZXJyb3IiLCJydHJpbSIsImx0cmltIiwidHJpbSIsInRvIiwidG9fbGluZSIsImJ5dGVzIiwiY29tbWVudF9saW5lcyIsImVtcHR5X2xpbmVzIiwiaW52YWxpZF9maWVsZF9sZW5ndGgiLCJsaW5lcyIsInJlY29yZHMiLCJzdGF0ZSIsImJvbVNraXBwZWQiLCJidWZCeXRlc1N0YXJ0IiwiY2FzdEZpZWxkIiwiY29tbWVudGluZyIsImVycm9yIiwiZW5hYmxlZCIsImVzY2FwaW5nIiwiZXNjYXBlSXNRdW90ZSIsImNvbXBhcmUiLCJleHBlY3RlZFJlY29yZExlbmd0aCIsImZpZWxkIiwiZmlyc3RMaW5lVG9IZWFkZXJzIiwibmVlZE1vcmVEYXRhU2l6ZSIsIm1heCIsInByZXZpb3VzQnVmIiwicXVvdGluZyIsInN0b3AiLCJyYXdCdWZmZXIiLCJyZWNvcmQiLCJyZWNvcmRIYXNFcnJvciIsInJlY29yZF9sZW5ndGgiLCJyZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgiLCJ2IiwidHJpbUNoYXJzIiwid2FzUXVvdGluZyIsIndhc1Jvd0RlbGltaXRlciIsIl90cmFuc2Zvcm0iLCJidWYiLCJjYWxsYmFjayIsImVyciIsIl9fcGFyc2UiLCJfZmx1c2giLCJuZXh0QnVmIiwiZW5kIiwicHVzaCIsImNvbmNhdCIsImJvbUxlbmd0aCIsInNsaWNlIiwiYnVmTGVuIiwicG9zIiwiX19uZWVkTW9yZURhdGEiLCJyZWNvcmRfZGVsaW1pdGVyQ291bnQiLCJfX2F1dG9EaXNjb3ZlclJlY29yZERlbGltaXRlciIsImNociIsImFwcGVuZCIsIl9faXNFc2NhcGUiLCJfX2lzUXVvdGUiLCJuZXh0Q2hyIiwiaXNOZXh0Q2hyVHJpbWFibGUiLCJfX2lzQ2hhclRyaW1hYmxlIiwiaXNOZXh0Q2hyQ29tbWVudCIsIl9fY29tcGFyZUJ5dGVzIiwiaXNOZXh0Q2hyRGVsaW1pdGVyIiwiX19pc0RlbGltaXRlciIsImlzTmV4dENoclJlY29yZERlbGltaXRlciIsIl9faXNSZWNvcmREZWxpbWl0ZXIiLCJfX2Vycm9yIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiX19pbmZvRmllbGQiLCJwcmVwZW5kIiwicmVjb3JkRGVsaW1pdGVyTGVuZ3RoIiwic2tpcENvbW1lbnRMaW5lIiwiX19yZXNldEZpZWxkIiwiX19yZXNldFJlY29yZCIsImVyckZpZWxkIiwiX19vbkZpZWxkIiwiZXJyUmVjb3JkIiwiX19vblJlY29yZCIsImNvbW1lbnRDb3VudCIsImRlbGltaXRlckxlbmd0aCIsImxhcHBlbmQiLCJyYXBwZW5kIiwicmVjb3JkTGVuZ3RoIiwiaXNSZWNvcmRFbXB0eSIsIl9fZmlyc3RMaW5lVG9Db2x1bW5zIiwiZmluYWxFcnIiLCJvYmoiLCJpIiwibCIsImRpc2FibGVkIiwibmFtZSIsIl9fcHVzaCIsIk9iamVjdCIsImFzc2lnbiIsIl9faW5mb1JlY29yZCIsImhlYWRlcnMiLCJjYWxsIiwibm9ybWFsaXplZEhlYWRlcnMiLCJyZXNldCIsInRyaW1SaWdodCIsImYiLCJfX2Nhc3QiLCJpc0NvbHVtbnMiLCJfX2lzRmxvYXQiLCJwYXJzZUZsb2F0Iiwic291cmNlQnVmIiwidGFyZ2V0QnVmIiwidGFyZ2V0UG9zIiwiZmlyc3RCeXRlIiwic291cmNlTGVuZ3RoIiwibnVtT2ZDaGFyTGVmdCIsInJlcXVpcmVkTGVuZ3RoIiwibG9vcDEiLCJkZWwiLCJqIiwicmRMZW5ndGgiLCJtc2ciLCJlbWl0IiwiX19pbmZvRGF0YVNldCIsImhlYWRlciIsImluZGV4IiwiY29sdW1uIiwiZGF0YSIsImFyZ3VtZW50cyIsImFyZ3VtZW50IiwidHlwZSIsImlzT2JqZWN0IiwicGFyc2VyIiwib24iLCJyZWFkIiwic2V0SW1tZWRpYXRlIiwid3JpdGUiLCJjb2RlIiwibWVzc2FnZSIsImNvbnRleHRzIiwiam9pbiIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29udGV4dCIsImtleSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzdHIiLCJyZXBsYWNlIiwiXyIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJldmVyeSIsIm5vcm1hbGl6ZWRDb2x1bW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/csv-parse@4.16.3/node_modules/csv-parse/lib/index.js\n");

/***/ })

};
;