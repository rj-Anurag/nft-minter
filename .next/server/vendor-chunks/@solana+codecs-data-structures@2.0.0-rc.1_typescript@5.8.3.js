"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-data-structures@2.0.0-rc.1_typescript@5.8.3";
exports.ids = ["vendor-chunks/@solana+codecs-data-structures@2.0.0-rc.1_typescript@5.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-data-structures@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-data-structures/dist/index.node.cjs":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-data-structures@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-data-structures/dist/index.node.cjs ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar codecsCore = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.node.cjs\");\nvar codecsNumbers = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/.pnpm/@solana+codecs-numbers@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-numbers/dist/index.node.cjs\");\nvar errors = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/errors/dist/index.node.cjs\");\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n    if (expected !== actual) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction maxCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction sumCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n    return codecsCore.isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n    return codecsCore.isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n    const size = config.size ?? codecsNumbers.getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n    return codecsCore.createEncoder({\n        ...fixedSize !== null ? {\n            fixedSize\n        } : {\n            getSizeFromValue: (array)=>{\n                const prefixSize = typeof size === \"object\" ? codecsCore.getEncodedSize(array.length, size) : 0;\n                return prefixSize + [\n                    ...array\n                ].reduce((all, value)=>all + codecsCore.getEncodedSize(value, item), 0);\n            },\n            maxSize\n        },\n        write: (array, bytes, offset)=>{\n            if (typeof size === \"number\") {\n                assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n            }\n            if (typeof size === \"object\") {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach((value)=>{\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getArrayDecoder(item, config = {}) {\n    const size = config.size ?? codecsNumbers.getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n    return codecsCore.createDecoder({\n        ...fixedSize !== null ? {\n            fixedSize\n        } : {\n            maxSize\n        },\n        read: (bytes, offset)=>{\n            const array = [];\n            if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n                return [\n                    array,\n                    offset\n                ];\n            }\n            if (size === \"remainder\") {\n                while(offset < bytes.length){\n                    const [value, newOffset2] = item.read(bytes, offset);\n                    offset = newOffset2;\n                    array.push(value);\n                }\n                return [\n                    array,\n                    offset\n                ];\n            }\n            const [resolvedSize, newOffset] = typeof size === \"number\" ? [\n                size,\n                offset\n            ] : size.read(bytes, offset);\n            offset = newOffset;\n            for(let i = 0; i < resolvedSize; i += 1){\n                const [value, newOffset2] = item.read(bytes, offset);\n                offset = newOffset2;\n                array.push(value);\n            }\n            return [\n                array,\n                offset\n            ];\n        }\n    });\n}\nfunction getArrayCodec(item, config = {}) {\n    return codecsCore.combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n    if (typeof size !== \"number\") return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return codecsCore.createEncoder({\n        fixedSize: size,\n        write (value, bytes, offset) {\n            const bytesToAdd = [];\n            for(let i = 0; i < size; i += 1){\n                let byte = 0;\n                for(let j = 0; j < 8; j += 1){\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n            bytes.set(bytesToAdd, offset);\n            return size;\n        }\n    });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return codecsCore.createDecoder({\n        fixedSize: size,\n        read (bytes, offset) {\n            codecsCore.assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n            const booleans = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n            slice.forEach((byte)=>{\n                for(let i = 0; i < 8; i += 1){\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 128));\n                        byte <<= 1;\n                    }\n                }\n            });\n            return [\n                booleans,\n                offset + size\n            ];\n        }\n    });\n}\nfunction getBitArrayCodec(size, config = {}) {\n    return codecsCore.combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n    return codecsCore.transformEncoder(config.size ?? codecsNumbers.getU8Encoder(), (value)=>value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n    return codecsCore.transformDecoder(config.size ?? codecsNumbers.getU8Decoder(), (value)=>Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n    return codecsCore.combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n    return codecsCore.createEncoder({\n        getSizeFromValue: (value)=>value.length,\n        write: (value, bytes, offset)=>{\n            bytes.set(value, offset);\n            return offset + value.length;\n        }\n    });\n}\nfunction getBytesDecoder() {\n    return codecsCore.createDecoder({\n        read: (bytes, offset)=>{\n            const slice = bytes.slice(offset);\n            return [\n                slice,\n                offset + slice.length\n            ];\n        }\n    });\n}\nfunction getBytesCodec() {\n    return codecsCore.combineCodec(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = ()=>codecsCore.createDecoder({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nfunction getConstantEncoder(constant) {\n    return codecsCore.createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset)=>{\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        }\n    });\n}\nfunction getConstantDecoder(constant) {\n    return codecsCore.createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset)=>{\n            const base16 = getBase16Decoder();\n            if (!codecsCore.containsBytes(bytes, constant, offset)) {\n                throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset\n                });\n            }\n            return [\n                void 0,\n                offset + constant.length\n            ];\n        }\n    });\n}\nfunction getConstantCodec(constant) {\n    return codecsCore.combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n    return codecsCore.createEncoder({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>items.map((item, index)=>codecsCore.getEncodedSize(value[index], item)).reduce((all, one)=>all + one, 0),\n            maxSize\n        } : {\n            fixedSize\n        },\n        write: (value, bytes, offset)=>{\n            assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n            items.forEach((item, index)=>{\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getTupleDecoder(items) {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n    return codecsCore.createDecoder({\n        ...fixedSize === null ? {\n            maxSize\n        } : {\n            fixedSize\n        },\n        read: (bytes, offset)=>{\n            const values = [];\n            items.forEach((item)=>{\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [\n                values,\n                offset\n            ];\n        }\n    });\n}\nfunction getTupleCodec(items) {\n    return codecsCore.combineCodec(getTupleEncoder(items), getTupleDecoder(items));\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n    const fixedSize = getUnionFixedSize(variants);\n    const write = (variant, bytes, offset)=>{\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n    if (fixedSize !== null) {\n        return codecsCore.createEncoder({\n            fixedSize,\n            write\n        });\n    }\n    const maxSize = getUnionMaxSize(variants);\n    return codecsCore.createEncoder({\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (variant)=>{\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return codecsCore.getEncodedSize(variant, variants[index]);\n        },\n        write\n    });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n    const fixedSize = getUnionFixedSize(variants);\n    const read = (bytes, offset)=>{\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n    if (fixedSize !== null) {\n        return codecsCore.createDecoder({\n            fixedSize,\n            read\n        });\n    }\n    const maxSize = getUnionMaxSize(variants);\n    return codecsCore.createDecoder({\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n    return codecsCore.combineCodec(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));\n}\nfunction assertValidVariantIndex(variants, index) {\n    if (typeof variants[index] === \"undefined\") {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index\n        });\n    }\n}\nfunction getUnionFixedSize(variants) {\n    if (variants.length === 0) return 0;\n    if (!codecsCore.isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every((variant)=>codecsCore.isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n    return maxCodecSizes(variants.map((variant)=>getMaxSize(variant)));\n}\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? codecsNumbers.getU8Encoder();\n    return getUnionEncoder(variants.map(([, variant], index)=>codecsCore.transformEncoder(getTupleEncoder([\n            prefix,\n            variant\n        ]), (value)=>[\n                index,\n                value\n            ])), (value)=>getVariantDiscriminator(variants, value[discriminatorProperty]));\n}\nfunction getDiscriminatedUnionDecoder(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? codecsNumbers.getU8Decoder();\n    return getUnionDecoder(variants.map(([discriminator, variant])=>codecsCore.transformDecoder(getTupleDecoder([\n            prefix,\n            variant\n        ]), ([, value])=>({\n                [discriminatorProperty]: discriminator,\n                ...value\n            }))), (bytes, offset)=>Number(prefix.read(bytes, offset)[0]));\n}\nfunction getDiscriminatedUnionCodec(variants, config = {}) {\n    return codecsCore.combineCodec(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n    const discriminator = variants.findIndex(([key])=>discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key])=>key)\n        });\n    }\n    return discriminator;\n}\nvar getDataEnumEncoder = getDiscriminatedUnionEncoder;\nvar getDataEnumDecoder = getDiscriminatedUnionDecoder;\nvar getDataEnumCodec = getDiscriminatedUnionCodec;\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter((v)=>typeof v === \"number\"))\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues = [\n        .../* @__PURE__ */ new Set([\n            ...enumKeys,\n            ...enumValues.filter((v)=>typeof v === \"string\")\n        ])\n    ];\n    return {\n        enumKeys,\n        enumRecord,\n        enumValues,\n        numericalValues,\n        stringValues\n    };\n}\nfunction getEnumIndexFromVariant({ enumKeys, enumValues, variant }) {\n    const valueIndex = findLastIndex(enumValues, (value)=>value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex((key)=>key === variant);\n}\nfunction getEnumIndexFromDiscriminator({ discriminator, enumKeys, enumValues, useValuesAsDiscriminators }) {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, (value)=>value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while(l--){\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\nfunction formatNumericalValues(values) {\n    if (values.length === 0) return \"\";\n    let range = [\n        values[0],\n        values[0]\n    ];\n    const ranges = [];\n    for(let index = 1; index < values.length; index++){\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [\n                value,\n                value\n            ];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(\", \");\n}\n// src/enum.ts\nfunction getEnumEncoder(constructor, config = {}) {\n    const prefix = config.size ?? codecsNumbers.getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v)=>typeof v === \"string\")\n        });\n    }\n    return codecsCore.transformEncoder(prefix, (variant)=>{\n        const index = getEnumIndexFromVariant({\n            enumKeys,\n            enumValues,\n            variant\n        });\n        if (index < 0) {\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant\n            });\n        }\n        return useValuesAsDiscriminators ? enumValues[index] : index;\n    });\n}\nfunction getEnumDecoder(constructor, config = {}) {\n    const prefix = config.size ?? codecsNumbers.getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) {\n        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v)=>typeof v === \"string\")\n        });\n    }\n    return codecsCore.transformDecoder(prefix, (value)=>{\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [\n                ...Array(enumKeys.length).keys()\n            ];\n            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators\n            });\n        }\n        return enumValues[index];\n    });\n}\nfunction getEnumCodec(constructor, config = {}) {\n    return codecsCore.combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nvar getScalarEnumEncoder = getEnumEncoder;\nvar getScalarEnumDecoder = getEnumDecoder;\nvar getScalarEnumCodec = getEnumCodec;\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n    return codecsCore.transformEncoder(getTupleEncoder([\n        ...prefixedEncoders,\n        encoder\n    ]), (value)=>[\n            ...prefixedEncoders.map(()=>void 0),\n            value\n        ]);\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n    return codecsCore.transformDecoder(getTupleDecoder([\n        ...prefixedDecoders,\n        decoder\n    ]), (tuple)=>tuple[tuple.length - 1]);\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n    return codecsCore.combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n    return codecsCore.transformEncoder(getTupleEncoder([\n        encoder,\n        ...suffixedEncoders\n    ]), (value)=>[\n            value,\n            ...suffixedEncoders.map(()=>void 0)\n        ]);\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n    return codecsCore.transformDecoder(getTupleDecoder([\n        decoder,\n        ...suffixedDecoders\n    ]), (tuple)=>tuple[0]);\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n    return codecsCore.combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getMapEncoder(key, value, config = {}) {\n    return codecsCore.transformEncoder(getArrayEncoder(getTupleEncoder([\n        key,\n        value\n    ]), config), (map)=>[\n            ...map.entries()\n        ]);\n}\nfunction getMapDecoder(key, value, config = {}) {\n    return codecsCore.transformDecoder(getArrayDecoder(getTupleDecoder([\n        key,\n        value\n    ]), config), (entries)=>new Map(entries));\n}\nfunction getMapCodec(key, value, config = {}) {\n    return codecsCore.combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n    return codecsCore.createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset)=>offset\n    });\n}\nfunction getUnitDecoder() {\n    return codecsCore.createDecoder({\n        fixedSize: 0,\n        read: (_bytes, offset)=>[\n                void 0,\n                offset\n            ]\n    });\n}\nfunction getUnitCodec() {\n    return codecsCore.combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n// src/nullable.ts\nfunction getNullableEncoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return codecsCore.transformEncoder(getUnitEncoder(), (_boolean)=>void 0);\n        }\n        return getBooleanEncoder({\n            size: config.prefix ?? codecsNumbers.getU8Encoder()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            codecsCore.assertIsFixedSize(item);\n            return codecsCore.fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n    return getUnionEncoder([\n        codecsCore.transformEncoder(getTupleEncoder([\n            prefix,\n            noneValue\n        ]), (_value)=>[\n                false,\n                void 0\n            ]),\n        codecsCore.transformEncoder(getTupleEncoder([\n            prefix,\n            item\n        ]), (value)=>[\n                true,\n                value\n            ])\n    ], (variant)=>Number(variant !== null));\n}\nfunction getNullableDecoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return codecsCore.transformDecoder(getUnitDecoder(), ()=>false);\n        }\n        return getBooleanDecoder({\n            size: config.prefix ?? codecsNumbers.getU8Decoder()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            codecsCore.assertIsFixedSize(item);\n            return codecsCore.fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n    return getUnionDecoder([\n        codecsCore.transformDecoder(getTupleDecoder([\n            prefix,\n            noneValue\n        ]), ()=>null),\n        codecsCore.transformDecoder(getTupleDecoder([\n            prefix,\n            item\n        ]), ([, value])=>value)\n    ], (bytes, offset)=>{\n        if (config.prefix === null && !config.noneValue) {\n            return Number(offset < bytes.length);\n        }\n        if (config.prefix === null && config.noneValue != null) {\n            const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n            return codecsCore.containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n        }\n        return Number(prefix.read(bytes, offset)[0]);\n    });\n}\nfunction getNullableCodec(item, config = {}) {\n    return codecsCore.combineCodec(getNullableEncoder(item, config), getNullableDecoder(item, config));\n}\nfunction getSetEncoder(item, config = {}) {\n    return codecsCore.transformEncoder(getArrayEncoder(item, config), (set)=>[\n            ...set\n        ]);\n}\nfunction getSetDecoder(item, config = {}) {\n    return codecsCore.transformDecoder(getArrayDecoder(item, config), (entries)=>new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n    return codecsCore.combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n    return codecsCore.createEncoder({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>fields.map(([key, codec])=>codecsCore.getEncodedSize(value[key], codec)).reduce((all, one)=>all + one, 0),\n            maxSize\n        } : {\n            fixedSize\n        },\n        write: (struct, bytes, offset)=>{\n            fields.forEach(([key, codec])=>{\n                offset = codec.write(struct[key], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getStructDecoder(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n    return codecsCore.createDecoder({\n        ...fixedSize === null ? {\n            maxSize\n        } : {\n            fixedSize\n        },\n        read: (bytes, offset)=>{\n            const struct = {};\n            fields.forEach(([key, codec])=>{\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key] = value;\n            });\n            return [\n                struct,\n                offset\n            ];\n        }\n    });\n}\nfunction getStructCodec(fields) {\n    return codecsCore.combineCodec(getStructEncoder(fields), getStructDecoder(fields));\n}\nexports.assertValidNumberOfItemsForCodec = assertValidNumberOfItemsForCodec;\nexports.getArrayCodec = getArrayCodec;\nexports.getArrayDecoder = getArrayDecoder;\nexports.getArrayEncoder = getArrayEncoder;\nexports.getBitArrayCodec = getBitArrayCodec;\nexports.getBitArrayDecoder = getBitArrayDecoder;\nexports.getBitArrayEncoder = getBitArrayEncoder;\nexports.getBooleanCodec = getBooleanCodec;\nexports.getBooleanDecoder = getBooleanDecoder;\nexports.getBooleanEncoder = getBooleanEncoder;\nexports.getBytesCodec = getBytesCodec;\nexports.getBytesDecoder = getBytesDecoder;\nexports.getBytesEncoder = getBytesEncoder;\nexports.getConstantCodec = getConstantCodec;\nexports.getConstantDecoder = getConstantDecoder;\nexports.getConstantEncoder = getConstantEncoder;\nexports.getDataEnumCodec = getDataEnumCodec;\nexports.getDataEnumDecoder = getDataEnumDecoder;\nexports.getDataEnumEncoder = getDataEnumEncoder;\nexports.getDiscriminatedUnionCodec = getDiscriminatedUnionCodec;\nexports.getDiscriminatedUnionDecoder = getDiscriminatedUnionDecoder;\nexports.getDiscriminatedUnionEncoder = getDiscriminatedUnionEncoder;\nexports.getEnumCodec = getEnumCodec;\nexports.getEnumDecoder = getEnumDecoder;\nexports.getEnumEncoder = getEnumEncoder;\nexports.getHiddenPrefixCodec = getHiddenPrefixCodec;\nexports.getHiddenPrefixDecoder = getHiddenPrefixDecoder;\nexports.getHiddenPrefixEncoder = getHiddenPrefixEncoder;\nexports.getHiddenSuffixCodec = getHiddenSuffixCodec;\nexports.getHiddenSuffixDecoder = getHiddenSuffixDecoder;\nexports.getHiddenSuffixEncoder = getHiddenSuffixEncoder;\nexports.getMapCodec = getMapCodec;\nexports.getMapDecoder = getMapDecoder;\nexports.getMapEncoder = getMapEncoder;\nexports.getNullableCodec = getNullableCodec;\nexports.getNullableDecoder = getNullableDecoder;\nexports.getNullableEncoder = getNullableEncoder;\nexports.getScalarEnumCodec = getScalarEnumCodec;\nexports.getScalarEnumDecoder = getScalarEnumDecoder;\nexports.getScalarEnumEncoder = getScalarEnumEncoder;\nexports.getSetCodec = getSetCodec;\nexports.getSetDecoder = getSetDecoder;\nexports.getSetEncoder = getSetEncoder;\nexports.getStructCodec = getStructCodec;\nexports.getStructDecoder = getStructDecoder;\nexports.getStructEncoder = getStructEncoder;\nexports.getTupleCodec = getTupleCodec;\nexports.getTupleDecoder = getTupleDecoder;\nexports.getTupleEncoder = getTupleEncoder;\nexports.getUnionCodec = getUnionCodec;\nexports.getUnionDecoder = getUnionDecoder;\nexports.getUnionEncoder = getUnionEncoder;\nexports.getUnitCodec = getUnitCodec;\nexports.getUnitDecoder = getUnitDecoder;\nexports.getUnitEncoder = getUnitEncoder; //# sourceMappingURL=index.node.cjs.map\n //# sourceMappingURL=index.node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzQDIuMC4wLXJjLjFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzL2Rpc3QvaW5kZXgubm9kZS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUN6QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzVCLElBQUlFLFNBQVNGLG1CQUFPQSxDQUFDO0FBRXJCLGVBQWU7QUFDZixTQUFTRyxpQ0FBaUNDLGdCQUFnQixFQUFFQyxRQUFRLEVBQUVDLE1BQU07SUFDMUUsSUFBSUQsYUFBYUMsUUFBUTtRQUN2QixNQUFNLElBQUlKLE9BQU9LLFdBQVcsQ0FBQ0wsT0FBT00sNkNBQTZDLEVBQUU7WUFDakZGO1lBQ0FGO1lBQ0FDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0ksY0FBY0MsS0FBSztJQUMxQixPQUFPQSxNQUFNQyxNQUFNLENBQ2pCLENBQUNDLEtBQUtDLE9BQVNELFFBQVEsUUFBUUMsU0FBUyxPQUFPLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0gsS0FBS0MsT0FDcEU7QUFFSjtBQUNBLFNBQVNHLGNBQWNOLEtBQUs7SUFDMUIsT0FBT0EsTUFBTUMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE9BQVNELFFBQVEsUUFBUUMsU0FBUyxPQUFPLE9BQU9ELE1BQU1DLE1BQU07QUFDeEY7QUFDQSxTQUFTSSxhQUFhQyxLQUFLO0lBQ3pCLE9BQU9uQixXQUFXb0IsV0FBVyxDQUFDRCxTQUFTQSxNQUFNRSxTQUFTLEdBQUc7QUFDM0Q7QUFDQSxTQUFTQyxXQUFXSCxLQUFLO0lBQ3ZCLE9BQU9uQixXQUFXb0IsV0FBVyxDQUFDRCxTQUFTQSxNQUFNRSxTQUFTLEdBQUdGLE1BQU1JLE9BQU8sSUFBSTtBQUM1RTtBQUVBLGVBQWU7QUFDZixTQUFTQyxnQkFBZ0JDLElB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NEYsb0NBQW9DLEdBQUc3RjtBQUN2QzZGLG9DQUFvQyxHQUFHbEc7QUFDdkNrRyxvQkFBb0IsR0FBR2hEO0FBQ3ZCZ0Qsc0JBQXNCLEdBQUdyRDtBQUN6QnFELHNCQUFzQixHQUFHMUQ7QUFDekIwRCw0QkFBNEIsR0FBR3JDO0FBQy9CcUMsOEJBQThCLEdBQUd6QztBQUNqQ3lDLDhCQUE4QixHQUFHNUM7QUFDakM0Qyw0QkFBNEIsR0FBRy9CO0FBQy9CK0IsOEJBQThCLEdBQUdqQztBQUNqQ2lDLDhCQUE4QixHQUFHbkM7QUFDakNtQyxtQkFBbUIsR0FBRzFCO0FBQ3RCMEIscUJBQXFCLEdBQUc1QjtBQUN4QjRCLHFCQUFxQixHQUFHN0I7QUFDeEI2Qix3QkFBd0IsR0FBR1Y7QUFDM0JVLDBCQUEwQixHQUFHZjtBQUM3QmUsMEJBQTBCLEdBQUdwQjtBQUM3Qm9CLDBCQUEwQixHQUFHN0M7QUFDN0I2Qyw0QkFBNEIsR0FBRzlDO0FBQy9COEMsNEJBQTRCLEdBQUcvQztBQUMvQitDLG1CQUFtQixHQUFHUDtBQUN0Qk8scUJBQXFCLEdBQUdSO0FBQ3hCUSxxQkFBcUIsR0FBR1Q7QUFDeEJTLHNCQUFzQixHQUFHRDtBQUN6QkMsd0JBQXdCLEdBQUdGO0FBQzNCRSx3QkFBd0IsR0FBR047QUFDM0JNLHFCQUFxQixHQUFHbkg7QUFDeEJtSCx1QkFBdUIsR0FBR3RIO0FBQzFCc0gsdUJBQXVCLEdBQUczSDtBQUMxQjJILHFCQUFxQixHQUFHekc7QUFDeEJ5Ryx1QkFBdUIsR0FBRzNHO0FBQzFCMkcsdUJBQXVCLEdBQUdsSDtBQUMxQmtILG9CQUFvQixHQUFHckI7QUFDdkJxQixzQkFBc0IsR0FBR3RCO0FBQ3pCc0Isc0JBQXNCLEdBQUd6QixnQkFDekIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzQDIuMC4wLXJjLjFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzL2Rpc3QvaW5kZXgubm9kZS5janM/YWRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjb2RlY3NDb3JlID0gcmVxdWlyZSgnQHNvbGFuYS9jb2RlY3MtY29yZScpO1xudmFyIGNvZGVjc051bWJlcnMgPSByZXF1aXJlKCdAc29sYW5hL2NvZGVjcy1udW1iZXJzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnQHNvbGFuYS9lcnJvcnMnKTtcblxuLy8gc3JjL2FycmF5LnRzXG5mdW5jdGlvbiBhc3NlcnRWYWxpZE51bWJlck9mSXRlbXNGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChleHBlY3RlZCAhPT0gYWN0dWFsKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TLCB7XG4gICAgICBhY3R1YWwsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgZXhwZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbWF4Q29kZWNTaXplcyhzaXplcykge1xuICByZXR1cm4gc2l6ZXMucmVkdWNlKFxuICAgIChhbGwsIHNpemUpID0+IGFsbCA9PT0gbnVsbCB8fCBzaXplID09PSBudWxsID8gbnVsbCA6IE1hdGgubWF4KGFsbCwgc2l6ZSksXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gc3VtQ29kZWNTaXplcyhzaXplcykge1xuICByZXR1cm4gc2l6ZXMucmVkdWNlKChhbGwsIHNpemUpID0+IGFsbCA9PT0gbnVsbCB8fCBzaXplID09PSBudWxsID8gbnVsbCA6IGFsbCArIHNpemUsIDApO1xufVxuZnVuY3Rpb24gZ2V0Rml4ZWRTaXplKGNvZGVjKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmlzRml4ZWRTaXplKGNvZGVjKSA/IGNvZGVjLmZpeGVkU2l6ZSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRNYXhTaXplKGNvZGVjKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmlzRml4ZWRTaXplKGNvZGVjKSA/IGNvZGVjLmZpeGVkU2l6ZSA6IGNvZGVjLm1heFNpemUgPz8gbnVsbDtcbn1cblxuLy8gc3JjL2FycmF5LnRzXG5mdW5jdGlvbiBnZXRBcnJheUVuY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgY29uc3Qgc2l6ZSA9IGNvbmZpZy5zaXplID8/IGNvZGVjc051bWJlcnMuZ2V0VTMyRW5jb2RlcigpO1xuICBjb25zdCBmaXhlZFNpemUgPSBjb21wdXRlQXJyYXlMaWtlQ29kZWNTaXplKHNpemUsIGdldEZpeGVkU2l6ZShpdGVtKSk7XG4gIGNvbnN0IG1heFNpemUgPSBjb21wdXRlQXJyYXlMaWtlQ29kZWNTaXplKHNpemUsIGdldE1heFNpemUoaXRlbSkpID8/IHZvaWQgMDtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplICE9PSBudWxsID8geyBmaXhlZFNpemUgfSA6IHtcbiAgICAgIGdldFNpemVGcm9tVmFsdWU6IChhcnJheSkgPT4ge1xuICAgICAgICBjb25zdCBwcmVmaXhTaXplID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgPyBjb2RlY3NDb3JlLmdldEVuY29kZWRTaXplKGFycmF5Lmxlbmd0aCwgc2l6ZSkgOiAwO1xuICAgICAgICByZXR1cm4gcHJlZml4U2l6ZSArIFsuLi5hcnJheV0ucmVkdWNlKChhbGwsIHZhbHVlKSA9PiBhbGwgKyBjb2RlY3NDb3JlLmdldEVuY29kZWRTaXplKHZhbHVlLCBpdGVtKSwgMCk7XG4gICAgICB9LFxuICAgICAgbWF4U2l6ZVxuICAgIH0sXG4gICAgd3JpdGU6IChhcnJheSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGFzc2VydFZhbGlkTnVtYmVyT2ZJdGVtc0ZvckNvZGVjKFwiYXJyYXlcIiwgc2l6ZSwgYXJyYXkubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvZmZzZXQgPSBzaXplLndyaXRlKGFycmF5Lmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBhcnJheS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBvZmZzZXQgPSBpdGVtLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlEZWNvZGVyKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHNpemUgPSBjb25maWcuc2l6ZSA/PyBjb2RlY3NOdW1iZXJzLmdldFUzMkRlY29kZXIoKTtcbiAgY29uc3QgaXRlbVNpemUgPSBnZXRGaXhlZFNpemUoaXRlbSk7XG4gIGNvbnN0IGZpeGVkU2l6ZSA9IGNvbXB1dGVBcnJheUxpa2VDb2RlY1NpemUoc2l6ZSwgaXRlbVNpemUpO1xuICBjb25zdCBtYXhTaXplID0gY29tcHV0ZUFycmF5TGlrZUNvZGVjU2l6ZShzaXplLCBnZXRNYXhTaXplKGl0ZW0pKSA/PyB2b2lkIDA7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmZpeGVkU2l6ZSAhPT0gbnVsbCA/IHsgZml4ZWRTaXplIH0gOiB7IG1heFNpemUgfSxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIiAmJiBieXRlcy5zbGljZShvZmZzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW2FycmF5LCBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgaWYgKHNpemUgPT09IFwicmVtYWluZGVyXCIpIHtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0Ml0gPSBpdGVtLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0MjtcbiAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5LCBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgY29uc3QgW3Jlc29sdmVkU2l6ZSwgbmV3T2Zmc2V0XSA9IHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiID8gW3NpemUsIG9mZnNldF0gOiBzaXplLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0Ml0gPSBpdGVtLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCA9IG5ld09mZnNldDI7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthcnJheSwgb2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlDb2RlYyhpdGVtLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0QXJyYXlFbmNvZGVyKGl0ZW0sIGNvbmZpZyksIGdldEFycmF5RGVjb2RlcihpdGVtLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBcnJheUxpa2VDb2RlY1NpemUoc2l6ZSwgaXRlbVNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiKSByZXR1cm4gbnVsbDtcbiAgaWYgKHNpemUgPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gaXRlbVNpemUgPT09IG51bGwgPyBudWxsIDogaXRlbVNpemUgKiBzaXplO1xufVxuZnVuY3Rpb24gZ2V0Qml0QXJyYXlFbmNvZGVyKHNpemUsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHBhcnNlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiYm9vbGVhblwiID8geyBiYWNrd2FyZDogY29uZmlnIH0gOiBjb25maWc7XG4gIGNvbnN0IGJhY2t3YXJkID0gcGFyc2VkQ29uZmlnLmJhY2t3YXJkID8/IGZhbHNlO1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IHNpemUsXG4gICAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgIGNvbnN0IGJ5dGVzVG9BZGQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIGxldCBieXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBmZWF0dXJlID0gTnVtYmVyKHZhbHVlW2kgKiA4ICsgal0gPz8gMCk7XG4gICAgICAgICAgYnl0ZSB8PSBmZWF0dXJlIDw8IChiYWNrd2FyZCA/IGogOiA3IC0gaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2t3YXJkKSB7XG4gICAgICAgICAgYnl0ZXNUb0FkZC51bnNoaWZ0KGJ5dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVzVG9BZGQucHVzaChieXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnl0ZXMuc2V0KGJ5dGVzVG9BZGQsIG9mZnNldCk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Qml0QXJyYXlEZWNvZGVyKHNpemUsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHBhcnNlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiYm9vbGVhblwiID8geyBiYWNrd2FyZDogY29uZmlnIH0gOiBjb25maWc7XG4gIGNvbnN0IGJhY2t3YXJkID0gcGFyc2VkQ29uZmlnLmJhY2t3YXJkID8/IGZhbHNlO1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IHNpemUsXG4gICAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb2RlY3NDb3JlLmFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJiaXRBcnJheVwiLCBzaXplLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGJvb2xlYW5zID0gW107XG4gICAgICBsZXQgc2xpY2UgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgICAgc2xpY2UgPSBiYWNrd2FyZCA/IHNsaWNlLnJldmVyc2UoKSA6IHNsaWNlO1xuICAgICAgc2xpY2UuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChiYWNrd2FyZCkge1xuICAgICAgICAgICAgYm9vbGVhbnMucHVzaChCb29sZWFuKGJ5dGUgJiAxKSk7XG4gICAgICAgICAgICBieXRlID4+PSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib29sZWFucy5wdXNoKEJvb2xlYW4oYnl0ZSAmIDEyOCkpO1xuICAgICAgICAgICAgYnl0ZSA8PD0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtib29sZWFucywgb2Zmc2V0ICsgc2l6ZV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEJpdEFycmF5Q29kZWMoc2l6ZSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldEJpdEFycmF5RW5jb2RlcihzaXplLCBjb25maWcpLCBnZXRCaXRBcnJheURlY29kZXIoc2l6ZSwgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuRW5jb2Rlcihjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29kZWNzQ29yZS50cmFuc2Zvcm1FbmNvZGVyKGNvbmZpZy5zaXplID8/IGNvZGVjc051bWJlcnMuZ2V0VThFbmNvZGVyKCksICh2YWx1ZSkgPT4gdmFsdWUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuRGVjb2Rlcihjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29kZWNzQ29yZS50cmFuc2Zvcm1EZWNvZGVyKGNvbmZpZy5zaXplID8/IGNvZGVjc051bWJlcnMuZ2V0VThEZWNvZGVyKCksICh2YWx1ZSkgPT4gTnVtYmVyKHZhbHVlKSA9PT0gMSk7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuQ29kZWMoY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldEJvb2xlYW5FbmNvZGVyKGNvbmZpZyksIGdldEJvb2xlYW5EZWNvZGVyKGNvbmZpZykpO1xufVxuZnVuY3Rpb24gZ2V0Qnl0ZXNFbmNvZGVyKCkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVFbmNvZGVyKHtcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHZhbHVlLmxlbmd0aCxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBieXRlcy5zZXQodmFsdWUsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCeXRlc0RlY29kZXIoKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBzbGljZSA9IGJ5dGVzLnNsaWNlKG9mZnNldCk7XG4gICAgICByZXR1cm4gW3NsaWNlLCBvZmZzZXQgKyBzbGljZS5sZW5ndGhdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCeXRlc0NvZGVjKCkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0Qnl0ZXNFbmNvZGVyKCksIGdldEJ5dGVzRGVjb2RlcigpKTtcbn1cbnZhciBnZXRCYXNlMTZEZWNvZGVyID0gKCkgPT4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHtcbiAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBieXRlcy5zbGljZShvZmZzZXQpLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xuICAgIHJldHVybiBbdmFsdWUsIGJ5dGVzLmxlbmd0aF07XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0Q29uc3RhbnRFbmNvZGVyKGNvbnN0YW50KSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogY29uc3RhbnQubGVuZ3RoLFxuICAgIHdyaXRlOiAoXywgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYnl0ZXMuc2V0KGNvbnN0YW50LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGNvbnN0YW50Lmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q29uc3RhbnREZWNvZGVyKGNvbnN0YW50KSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogY29uc3RhbnQubGVuZ3RoLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBiYXNlMTYgPSBnZXRCYXNlMTZEZWNvZGVyKCk7XG4gICAgICBpZiAoIWNvZGVjc0NvcmUuY29udGFpbnNCeXRlcyhieXRlcywgY29uc3RhbnQsIG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQsIHtcbiAgICAgICAgICBjb25zdGFudCxcbiAgICAgICAgICBkYXRhOiBieXRlcyxcbiAgICAgICAgICBoZXhDb25zdGFudDogYmFzZTE2LmRlY29kZShjb25zdGFudCksXG4gICAgICAgICAgaGV4RGF0YTogYmFzZTE2LmRlY29kZShieXRlcyksXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2b2lkIDAsIG9mZnNldCArIGNvbnN0YW50Lmxlbmd0aF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENvbnN0YW50Q29kZWMoY29uc3RhbnQpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldENvbnN0YW50RW5jb2Rlcihjb25zdGFudCksIGdldENvbnN0YW50RGVjb2Rlcihjb25zdGFudCkpO1xufVxuZnVuY3Rpb24gZ2V0VHVwbGVFbmNvZGVyKGl0ZW1zKSB7XG4gIGNvbnN0IGZpeGVkU2l6ZSA9IHN1bUNvZGVjU2l6ZXMoaXRlbXMubWFwKGdldEZpeGVkU2l6ZSkpO1xuICBjb25zdCBtYXhTaXplID0gc3VtQ29kZWNTaXplcyhpdGVtcy5tYXAoZ2V0TWF4U2l6ZSkpID8/IHZvaWQgMDtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplID09PSBudWxsID8ge1xuICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiBjb2RlY3NDb3JlLmdldEVuY29kZWRTaXplKHZhbHVlW2luZGV4XSwgaXRlbSkpLnJlZHVjZSgoYWxsLCBvbmUpID0+IGFsbCArIG9uZSwgMCksXG4gICAgICBtYXhTaXplXG4gICAgfSA6IHsgZml4ZWRTaXplIH0sXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0VmFsaWROdW1iZXJPZkl0ZW1zRm9yQ29kZWMoXCJ0dXBsZVwiLCBpdGVtcy5sZW5ndGgsIHZhbHVlLmxlbmd0aCk7XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBvZmZzZXQgPSBpdGVtLndyaXRlKHZhbHVlW2luZGV4XSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFR1cGxlRGVjb2RlcihpdGVtcykge1xuICBjb25zdCBmaXhlZFNpemUgPSBzdW1Db2RlY1NpemVzKGl0ZW1zLm1hcChnZXRGaXhlZFNpemUpKTtcbiAgY29uc3QgbWF4U2l6ZSA9IHN1bUNvZGVjU2l6ZXMoaXRlbXMubWFwKGdldE1heFNpemUpKSA/PyB2b2lkIDA7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmZpeGVkU2l6ZSA9PT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDogeyBmaXhlZFNpemUgfSxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IFtuZXdWYWx1ZSwgbmV3T2Zmc2V0XSA9IGl0ZW0ucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgdmFsdWVzLnB1c2gobmV3VmFsdWUpO1xuICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbdmFsdWVzLCBvZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUdXBsZUNvZGVjKGl0ZW1zKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNvbWJpbmVDb2RlYyhcbiAgICBnZXRUdXBsZUVuY29kZXIoaXRlbXMpLFxuICAgIGdldFR1cGxlRGVjb2RlcihpdGVtcylcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFVuaW9uRW5jb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tVmFsdWUpIHtcbiAgY29uc3QgZml4ZWRTaXplID0gZ2V0VW5pb25GaXhlZFNpemUodmFyaWFudHMpO1xuICBjb25zdCB3cml0ZSA9ICh2YXJpYW50LCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEZyb21WYWx1ZSh2YXJpYW50KTtcbiAgICBhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCh2YXJpYW50cywgaW5kZXgpO1xuICAgIHJldHVybiB2YXJpYW50c1tpbmRleF0ud3JpdGUodmFyaWFudCwgYnl0ZXMsIG9mZnNldCk7XG4gIH07XG4gIGlmIChmaXhlZFNpemUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVFbmNvZGVyKHsgZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBtYXhTaXplID0gZ2V0VW5pb25NYXhTaXplKHZhcmlhbnRzKTtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhcmlhbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhGcm9tVmFsdWUodmFyaWFudCk7XG4gICAgICBhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCh2YXJpYW50cywgaW5kZXgpO1xuICAgICAgcmV0dXJuIGNvZGVjc0NvcmUuZ2V0RW5jb2RlZFNpemUodmFyaWFudCwgdmFyaWFudHNbaW5kZXhdKTtcbiAgICB9LFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VW5pb25EZWNvZGVyKHZhcmlhbnRzLCBnZXRJbmRleEZyb21CeXRlcykge1xuICBjb25zdCBmaXhlZFNpemUgPSBnZXRVbmlvbkZpeGVkU2l6ZSh2YXJpYW50cyk7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhGcm9tQnl0ZXMoYnl0ZXMsIG9mZnNldCk7XG4gICAgYXNzZXJ0VmFsaWRWYXJpYW50SW5kZXgodmFyaWFudHMsIGluZGV4KTtcbiAgICByZXR1cm4gdmFyaWFudHNbaW5kZXhdLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gIH07XG4gIGlmIChmaXhlZFNpemUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHsgZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IG1heFNpemUgPSBnZXRVbmlvbk1heFNpemUodmFyaWFudHMpO1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHsgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBnZXRVbmlvbkNvZGVjKHZhcmlhbnRzLCBnZXRJbmRleEZyb21WYWx1ZSwgZ2V0SW5kZXhGcm9tQnl0ZXMpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKFxuICAgIGdldFVuaW9uRW5jb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tVmFsdWUpLFxuICAgIGdldFVuaW9uRGVjb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tQnl0ZXMpXG4gICk7XG59XG5mdW5jdGlvbiBhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCh2YXJpYW50cywgaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiB2YXJpYW50c1tpbmRleF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIG1heFJhbmdlOiB2YXJpYW50cy5sZW5ndGggLSAxLFxuICAgICAgbWluUmFuZ2U6IDAsXG4gICAgICB2YXJpYW50OiBpbmRleFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRVbmlvbkZpeGVkU2l6ZSh2YXJpYW50cykge1xuICBpZiAodmFyaWFudHMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKCFjb2RlY3NDb3JlLmlzRml4ZWRTaXplKHZhcmlhbnRzWzBdKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHZhcmlhbnRTaXplID0gdmFyaWFudHNbMF0uZml4ZWRTaXplO1xuICBjb25zdCBzYW1lU2l6ZWRWYXJpYW50cyA9IHZhcmlhbnRzLmV2ZXJ5KCh2YXJpYW50KSA9PiBjb2RlY3NDb3JlLmlzRml4ZWRTaXplKHZhcmlhbnQpICYmIHZhcmlhbnQuZml4ZWRTaXplID09PSB2YXJpYW50U2l6ZSk7XG4gIHJldHVybiBzYW1lU2l6ZWRWYXJpYW50cyA/IHZhcmlhbnRTaXplIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVuaW9uTWF4U2l6ZSh2YXJpYW50cykge1xuICByZXR1cm4gbWF4Q29kZWNTaXplcyh2YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IGdldE1heFNpemUodmFyaWFudCkpKTtcbn1cblxuLy8gc3JjL2Rpc2NyaW1pbmF0ZWQtdW5pb24udHNcbmZ1bmN0aW9uIGdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXIodmFyaWFudHMsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JQcm9wZXJ0eSA9IGNvbmZpZy5kaXNjcmltaW5hdG9yID8/IFwiX19raW5kXCI7XG4gIGNvbnN0IHByZWZpeCA9IGNvbmZpZy5zaXplID8/IGNvZGVjc051bWJlcnMuZ2V0VThFbmNvZGVyKCk7XG4gIHJldHVybiBnZXRVbmlvbkVuY29kZXIoXG4gICAgdmFyaWFudHMubWFwKFxuICAgICAgKFssIHZhcmlhbnRdLCBpbmRleCkgPT4gY29kZWNzQ29yZS50cmFuc2Zvcm1FbmNvZGVyKGdldFR1cGxlRW5jb2RlcihbcHJlZml4LCB2YXJpYW50XSksICh2YWx1ZSkgPT4gW2luZGV4LCB2YWx1ZV0pXG4gICAgKSxcbiAgICAodmFsdWUpID0+IGdldFZhcmlhbnREaXNjcmltaW5hdG9yKHZhcmlhbnRzLCB2YWx1ZVtkaXNjcmltaW5hdG9yUHJvcGVydHldKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2Rlcih2YXJpYW50cywgY29uZmlnID0ge30pIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvclByb3BlcnR5ID0gY29uZmlnLmRpc2NyaW1pbmF0b3IgPz8gXCJfX2tpbmRcIjtcbiAgY29uc3QgcHJlZml4ID0gY29uZmlnLnNpemUgPz8gY29kZWNzTnVtYmVycy5nZXRVOERlY29kZXIoKTtcbiAgcmV0dXJuIGdldFVuaW9uRGVjb2RlcihcbiAgICB2YXJpYW50cy5tYXAoXG4gICAgICAoW2Rpc2NyaW1pbmF0b3IsIHZhcmlhbnRdKSA9PiBjb2RlY3NDb3JlLnRyYW5zZm9ybURlY29kZXIoZ2V0VHVwbGVEZWNvZGVyKFtwcmVmaXgsIHZhcmlhbnRdKSwgKFssIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgW2Rpc2NyaW1pbmF0b3JQcm9wZXJ0eV06IGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9KSlcbiAgICApLFxuICAgIChieXRlcywgb2Zmc2V0KSA9PiBOdW1iZXIocHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldClbMF0pXG4gICk7XG59XG5mdW5jdGlvbiBnZXREaXNjcmltaW5hdGVkVW5pb25Db2RlYyh2YXJpYW50cywgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKFxuICAgIGdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXIodmFyaWFudHMsIGNvbmZpZyksXG4gICAgZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2Rlcih2YXJpYW50cywgY29uZmlnKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0VmFyaWFudERpc2NyaW1pbmF0b3IodmFyaWFudHMsIGRpc2NyaW1pbmF0b3JWYWx1ZSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yID0gdmFyaWFudHMuZmluZEluZGV4KChba2V5XSkgPT4gZGlzY3JpbWluYXRvclZhbHVlID09PSBrZXkpO1xuICBpZiAoZGlzY3JpbWluYXRvciA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIHtcbiAgICAgIHZhbHVlOiBkaXNjcmltaW5hdG9yVmFsdWUsXG4gICAgICB2YXJpYW50czogdmFyaWFudHMubWFwKChba2V5XSkgPT4ga2V5KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkaXNjcmltaW5hdG9yO1xufVxudmFyIGdldERhdGFFbnVtRW5jb2RlciA9IGdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXI7XG52YXIgZ2V0RGF0YUVudW1EZWNvZGVyID0gZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2RlcjtcbnZhciBnZXREYXRhRW51bUNvZGVjID0gZ2V0RGlzY3JpbWluYXRlZFVuaW9uQ29kZWM7XG5cbi8vIHNyYy9lbnVtLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGdldEVudW1TdGF0cyhjb25zdHJ1Y3Rvcikge1xuICBjb25zdCBudW1lcmljYWxWYWx1ZXMgPSBbXG4gICAgLi4ubmV3IFNldChPYmplY3QudmFsdWVzKGNvbnN0cnVjdG9yKS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSlcbiAgXS5zb3J0KCk7XG4gIGNvbnN0IGVudW1SZWNvcmQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY29uc3RydWN0b3IpLnNsaWNlKG51bWVyaWNhbFZhbHVlcy5sZW5ndGgpKTtcbiAgY29uc3QgZW51bUtleXMgPSBPYmplY3Qua2V5cyhlbnVtUmVjb3JkKTtcbiAgY29uc3QgZW51bVZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bVJlY29yZCk7XG4gIGNvbnN0IHN0cmluZ1ZhbHVlcyA9IFtcbiAgICAuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZW51bUtleXMsIC4uLmVudW1WYWx1ZXMuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIildKVxuICBdO1xuICByZXR1cm4geyBlbnVtS2V5cywgZW51bVJlY29yZCwgZW51bVZhbHVlcywgbnVtZXJpY2FsVmFsdWVzLCBzdHJpbmdWYWx1ZXMgfTtcbn1cbmZ1bmN0aW9uIGdldEVudW1JbmRleEZyb21WYXJpYW50KHtcbiAgZW51bUtleXMsXG4gIGVudW1WYWx1ZXMsXG4gIHZhcmlhbnRcbn0pIHtcbiAgY29uc3QgdmFsdWVJbmRleCA9IGZpbmRMYXN0SW5kZXgoZW51bVZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdmFyaWFudCk7XG4gIGlmICh2YWx1ZUluZGV4ID49IDApIHJldHVybiB2YWx1ZUluZGV4O1xuICByZXR1cm4gZW51bUtleXMuZmluZEluZGV4KChrZXkpID0+IGtleSA9PT0gdmFyaWFudCk7XG59XG5mdW5jdGlvbiBnZXRFbnVtSW5kZXhGcm9tRGlzY3JpbWluYXRvcih7XG4gIGRpc2NyaW1pbmF0b3IsXG4gIGVudW1LZXlzLFxuICBlbnVtVmFsdWVzLFxuICB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzXG59KSB7XG4gIGlmICghdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycykge1xuICAgIHJldHVybiBkaXNjcmltaW5hdG9yID49IDAgJiYgZGlzY3JpbWluYXRvciA8IGVudW1LZXlzLmxlbmd0aCA/IGRpc2NyaW1pbmF0b3IgOiAtMTtcbiAgfVxuICByZXR1cm4gZmluZExhc3RJbmRleChlbnVtVmFsdWVzLCAodmFsdWUpID0+IHZhbHVlID09PSBkaXNjcmltaW5hdG9yKTtcbn1cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbbF0sIGwsIGFycmF5KSkgcmV0dXJuIGw7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtZXJpY2FsVmFsdWVzKHZhbHVlcykge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gIGxldCByYW5nZSA9IFt2YWx1ZXNbMF0sIHZhbHVlc1swXV07XG4gIGNvbnN0IHJhbmdlcyA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgdmFsdWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICBpZiAocmFuZ2VbMV0gKyAxID09PSB2YWx1ZSkge1xuICAgICAgcmFuZ2VbMV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2VbMF0gPT09IHJhbmdlWzFdID8gYCR7cmFuZ2VbMF19YCA6IGAke3JhbmdlWzBdfS0ke3JhbmdlWzFdfWApO1xuICAgICAgcmFuZ2UgPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9XG4gIH1cbiAgcmFuZ2VzLnB1c2gocmFuZ2VbMF0gPT09IHJhbmdlWzFdID8gYCR7cmFuZ2VbMF19YCA6IGAke3JhbmdlWzBdfS0ke3JhbmdlWzFdfWApO1xuICByZXR1cm4gcmFuZ2VzLmpvaW4oXCIsIFwiKTtcbn1cblxuLy8gc3JjL2VudW0udHNcbmZ1bmN0aW9uIGdldEVudW1FbmNvZGVyKGNvbnN0cnVjdG9yLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBwcmVmaXggPSBjb25maWcuc2l6ZSA/PyBjb2RlY3NOdW1iZXJzLmdldFU4RW5jb2RlcigpO1xuICBjb25zdCB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID0gY29uZmlnLnVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnMgPz8gZmFsc2U7XG4gIGNvbnN0IHsgZW51bUtleXMsIGVudW1WYWx1ZXMsIG51bWVyaWNhbFZhbHVlcywgc3RyaW5nVmFsdWVzIH0gPSBnZXRFbnVtU3RhdHMoY29uc3RydWN0b3IpO1xuICBpZiAodXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyAmJiBlbnVtVmFsdWVzLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Tb2xhbmFFcnJvcihlcnJvcnMuU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUywge1xuICAgICAgc3RyaW5nVmFsdWVzOiBlbnVtVmFsdWVzLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRW5jb2RlcihwcmVmaXgsICh2YXJpYW50KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRFbnVtSW5kZXhGcm9tVmFyaWFudCh7IGVudW1LZXlzLCBlbnVtVmFsdWVzLCB2YXJpYW50IH0pO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCwge1xuICAgICAgICBmb3JtYXR0ZWROdW1lcmljYWxWYWx1ZXM6IGZvcm1hdE51bWVyaWNhbFZhbHVlcyhudW1lcmljYWxWYWx1ZXMpLFxuICAgICAgICBudW1lcmljYWxWYWx1ZXMsXG4gICAgICAgIHN0cmluZ1ZhbHVlcyxcbiAgICAgICAgdmFyaWFudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID8gZW51bVZhbHVlc1tpbmRleF0gOiBpbmRleDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFbnVtRGVjb2Rlcihjb25zdHJ1Y3RvciwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgcHJlZml4ID0gY29uZmlnLnNpemUgPz8gY29kZWNzTnVtYmVycy5nZXRVOERlY29kZXIoKTtcbiAgY29uc3QgdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyA9IGNvbmZpZy51c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID8/IGZhbHNlO1xuICBjb25zdCB7IGVudW1LZXlzLCBlbnVtVmFsdWVzLCBudW1lcmljYWxWYWx1ZXMgfSA9IGdldEVudW1TdGF0cyhjb25zdHJ1Y3Rvcik7XG4gIGlmICh1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzICYmIGVudW1WYWx1ZXMuc29tZSgodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNvbGFuYUVycm9yKGVycm9ycy5TT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTLCB7XG4gICAgICBzdHJpbmdWYWx1ZXM6IGVudW1WYWx1ZXMuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29kZWNzQ29yZS50cmFuc2Zvcm1EZWNvZGVyKHByZWZpeCwgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvciA9IE51bWJlcih2YWx1ZSk7XG4gICAgY29uc3QgaW5kZXggPSBnZXRFbnVtSW5kZXhGcm9tRGlzY3JpbWluYXRvcih7XG4gICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgZW51bUtleXMsXG4gICAgICBlbnVtVmFsdWVzLFxuICAgICAgdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9yc1xuICAgIH0pO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGNvbnN0IHZhbGlkRGlzY3JpbWluYXRvcnMgPSB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID8gbnVtZXJpY2FsVmFsdWVzIDogWy4uLkFycmF5KGVudW1LZXlzLmxlbmd0aCkua2V5cygpXTtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuU29sYW5hRXJyb3IoZXJyb3JzLlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLCB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIGZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnM6IGZvcm1hdE51bWVyaWNhbFZhbHVlcyh2YWxpZERpc2NyaW1pbmF0b3JzKSxcbiAgICAgICAgdmFsaWREaXNjcmltaW5hdG9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFbnVtQ29kZWMoY29uc3RydWN0b3IsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNvbWJpbmVDb2RlYyhnZXRFbnVtRW5jb2Rlcihjb25zdHJ1Y3RvciwgY29uZmlnKSwgZ2V0RW51bURlY29kZXIoY29uc3RydWN0b3IsIGNvbmZpZykpO1xufVxudmFyIGdldFNjYWxhckVudW1FbmNvZGVyID0gZ2V0RW51bUVuY29kZXI7XG52YXIgZ2V0U2NhbGFyRW51bURlY29kZXIgPSBnZXRFbnVtRGVjb2RlcjtcbnZhciBnZXRTY2FsYXJFbnVtQ29kZWMgPSBnZXRFbnVtQ29kZWM7XG5mdW5jdGlvbiBnZXRIaWRkZW5QcmVmaXhFbmNvZGVyKGVuY29kZXIsIHByZWZpeGVkRW5jb2RlcnMpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRUdXBsZUVuY29kZXIoWy4uLnByZWZpeGVkRW5jb2RlcnMsIGVuY29kZXJdKSxcbiAgICAodmFsdWUpID0+IFsuLi5wcmVmaXhlZEVuY29kZXJzLm1hcCgoKSA9PiB2b2lkIDApLCB2YWx1ZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEhpZGRlblByZWZpeERlY29kZXIoZGVjb2RlciwgcHJlZml4ZWREZWNvZGVycykge1xuICByZXR1cm4gY29kZWNzQ29yZS50cmFuc2Zvcm1EZWNvZGVyKFxuICAgIGdldFR1cGxlRGVjb2RlcihbLi4ucHJlZml4ZWREZWNvZGVycywgZGVjb2Rlcl0pLFxuICAgICh0dXBsZSkgPT4gdHVwbGVbdHVwbGUubGVuZ3RoIC0gMV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEhpZGRlblByZWZpeENvZGVjKGNvZGVjLCBwcmVmaXhlZENvZGVjcykge1xuICByZXR1cm4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0SGlkZGVuUHJlZml4RW5jb2Rlcihjb2RlYywgcHJlZml4ZWRDb2RlY3MpLCBnZXRIaWRkZW5QcmVmaXhEZWNvZGVyKGNvZGVjLCBwcmVmaXhlZENvZGVjcykpO1xufVxuZnVuY3Rpb24gZ2V0SGlkZGVuU3VmZml4RW5jb2RlcihlbmNvZGVyLCBzdWZmaXhlZEVuY29kZXJzKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLnRyYW5zZm9ybUVuY29kZXIoXG4gICAgZ2V0VHVwbGVFbmNvZGVyKFtlbmNvZGVyLCAuLi5zdWZmaXhlZEVuY29kZXJzXSksXG4gICAgKHZhbHVlKSA9PiBbdmFsdWUsIC4uLnN1ZmZpeGVkRW5jb2RlcnMubWFwKCgpID0+IHZvaWQgMCldXG4gICk7XG59XG5mdW5jdGlvbiBnZXRIaWRkZW5TdWZmaXhEZWNvZGVyKGRlY29kZXIsIHN1ZmZpeGVkRGVjb2RlcnMpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRGVjb2RlcihcbiAgICBnZXRUdXBsZURlY29kZXIoW2RlY29kZXIsIC4uLnN1ZmZpeGVkRGVjb2RlcnNdKSxcbiAgICAodHVwbGUpID0+IHR1cGxlWzBdXG4gICk7XG59XG5mdW5jdGlvbiBnZXRIaWRkZW5TdWZmaXhDb2RlYyhjb2RlYywgc3VmZml4ZWRDb2RlY3MpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldEhpZGRlblN1ZmZpeEVuY29kZXIoY29kZWMsIHN1ZmZpeGVkQ29kZWNzKSwgZ2V0SGlkZGVuU3VmZml4RGVjb2Rlcihjb2RlYywgc3VmZml4ZWRDb2RlY3MpKTtcbn1cbmZ1bmN0aW9uIGdldE1hcEVuY29kZXIoa2V5LCB2YWx1ZSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRBcnJheUVuY29kZXIoZ2V0VHVwbGVFbmNvZGVyKFtrZXksIHZhbHVlXSksIGNvbmZpZyksXG4gICAgKG1hcCkgPT4gWy4uLm1hcC5lbnRyaWVzKCldXG4gICk7XG59XG5mdW5jdGlvbiBnZXRNYXBEZWNvZGVyKGtleSwgdmFsdWUsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLnRyYW5zZm9ybURlY29kZXIoXG4gICAgZ2V0QXJyYXlEZWNvZGVyKGdldFR1cGxlRGVjb2Rlcihba2V5LCB2YWx1ZV0pLCBjb25maWcpLFxuICAgIChlbnRyaWVzKSA9PiBuZXcgTWFwKGVudHJpZXMpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRNYXBDb2RlYyhrZXksIHZhbHVlLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0TWFwRW5jb2RlcihrZXksIHZhbHVlLCBjb25maWcpLCBnZXRNYXBEZWNvZGVyKGtleSwgdmFsdWUsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gZ2V0VW5pdEVuY29kZXIoKSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLmNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogMCxcbiAgICB3cml0ZTogKF92YWx1ZSwgX2J5dGVzLCBvZmZzZXQpID0+IG9mZnNldFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFVuaXREZWNvZGVyKCkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IDAsXG4gICAgcmVhZDogKF9ieXRlcywgb2Zmc2V0KSA9PiBbdm9pZCAwLCBvZmZzZXRdXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VW5pdENvZGVjKCkge1xuICByZXR1cm4gY29kZWNzQ29yZS5jb21iaW5lQ29kZWMoZ2V0VW5pdEVuY29kZXIoKSwgZ2V0VW5pdERlY29kZXIoKSk7XG59XG5cbi8vIHNyYy9udWxsYWJsZS50c1xuZnVuY3Rpb24gZ2V0TnVsbGFibGVFbmNvZGVyKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHByZWZpeCA9ICgoKSA9PiB7XG4gICAgaWYgKGNvbmZpZy5wcmVmaXggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2RlY3NDb3JlLnRyYW5zZm9ybUVuY29kZXIoZ2V0VW5pdEVuY29kZXIoKSwgKF9ib29sZWFuKSA9PiB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkVuY29kZXIoeyBzaXplOiBjb25maWcucHJlZml4ID8/IGNvZGVjc051bWJlcnMuZ2V0VThFbmNvZGVyKCkgfSk7XG4gIH0pKCk7XG4gIGNvbnN0IG5vbmVWYWx1ZSA9ICgoKSA9PiB7XG4gICAgaWYgKGNvbmZpZy5ub25lVmFsdWUgPT09IFwiemVyb2VzXCIpIHtcbiAgICAgIGNvZGVjc0NvcmUuYXNzZXJ0SXNGaXhlZFNpemUoaXRlbSk7XG4gICAgICByZXR1cm4gY29kZWNzQ29yZS5maXhFbmNvZGVyU2l6ZShnZXRVbml0RW5jb2RlcigpLCBpdGVtLmZpeGVkU2l6ZSk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLm5vbmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIGdldFVuaXRFbmNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRDb25zdGFudEVuY29kZXIoY29uZmlnLm5vbmVWYWx1ZSk7XG4gIH0pKCk7XG4gIHJldHVybiBnZXRVbmlvbkVuY29kZXIoXG4gICAgW1xuICAgICAgY29kZWNzQ29yZS50cmFuc2Zvcm1FbmNvZGVyKGdldFR1cGxlRW5jb2RlcihbcHJlZml4LCBub25lVmFsdWVdKSwgKF92YWx1ZSkgPT4gW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgdm9pZCAwXG4gICAgICBdKSxcbiAgICAgIGNvZGVjc0NvcmUudHJhbnNmb3JtRW5jb2RlcihnZXRUdXBsZUVuY29kZXIoW3ByZWZpeCwgaXRlbV0pLCAodmFsdWUpID0+IFt0cnVlLCB2YWx1ZV0pXG4gICAgXSxcbiAgICAodmFyaWFudCkgPT4gTnVtYmVyKHZhcmlhbnQgIT09IG51bGwpXG4gICk7XG59XG5mdW5jdGlvbiBnZXROdWxsYWJsZURlY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgcHJlZml4ID0gKCgpID0+IHtcbiAgICBpZiAoY29uZmlnLnByZWZpeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRGVjb2RlcihnZXRVbml0RGVjb2RlcigpLCAoKSA9PiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCb29sZWFuRGVjb2Rlcih7IHNpemU6IGNvbmZpZy5wcmVmaXggPz8gY29kZWNzTnVtYmVycy5nZXRVOERlY29kZXIoKSB9KTtcbiAgfSkoKTtcbiAgY29uc3Qgbm9uZVZhbHVlID0gKCgpID0+IHtcbiAgICBpZiAoY29uZmlnLm5vbmVWYWx1ZSA9PT0gXCJ6ZXJvZXNcIikge1xuICAgICAgY29kZWNzQ29yZS5hc3NlcnRJc0ZpeGVkU2l6ZShpdGVtKTtcbiAgICAgIHJldHVybiBjb2RlY3NDb3JlLmZpeERlY29kZXJTaXplKGdldFVuaXREZWNvZGVyKCksIGl0ZW0uZml4ZWRTaXplKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubm9uZVZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0VW5pdERlY29kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldENvbnN0YW50RGVjb2Rlcihjb25maWcubm9uZVZhbHVlKTtcbiAgfSkoKTtcbiAgcmV0dXJuIGdldFVuaW9uRGVjb2RlcihcbiAgICBbXG4gICAgICBjb2RlY3NDb3JlLnRyYW5zZm9ybURlY29kZXIoZ2V0VHVwbGVEZWNvZGVyKFtwcmVmaXgsIG5vbmVWYWx1ZV0pLCAoKSA9PiBudWxsKSxcbiAgICAgIGNvZGVjc0NvcmUudHJhbnNmb3JtRGVjb2RlcihnZXRUdXBsZURlY29kZXIoW3ByZWZpeCwgaXRlbV0pLCAoWywgdmFsdWVdKSA9PiB2YWx1ZSlcbiAgICBdLFxuICAgIChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoY29uZmlnLnByZWZpeCA9PT0gbnVsbCAmJiAhY29uZmlnLm5vbmVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKG9mZnNldCA8IGJ5dGVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnByZWZpeCA9PT0gbnVsbCAmJiBjb25maWcubm9uZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgemVyb1ZhbHVlID0gY29uZmlnLm5vbmVWYWx1ZSA9PT0gXCJ6ZXJvZXNcIiA/IG5ldyBVaW50OEFycmF5KG5vbmVWYWx1ZS5maXhlZFNpemUpLmZpbGwoMCkgOiBjb25maWcubm9uZVZhbHVlO1xuICAgICAgICByZXR1cm4gY29kZWNzQ29yZS5jb250YWluc0J5dGVzKGJ5dGVzLCB6ZXJvVmFsdWUsIG9mZnNldCkgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOdW1iZXIocHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldClbMF0pO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE51bGxhYmxlQ29kZWMoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKFxuICAgIGdldE51bGxhYmxlRW5jb2RlcihpdGVtLCBjb25maWcpLFxuICAgIGdldE51bGxhYmxlRGVjb2RlcihpdGVtLCBjb25maWcpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRTZXRFbmNvZGVyKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb2RlY3NDb3JlLnRyYW5zZm9ybUVuY29kZXIoZ2V0QXJyYXlFbmNvZGVyKGl0ZW0sIGNvbmZpZyksIChzZXQpID0+IFsuLi5zZXRdKTtcbn1cbmZ1bmN0aW9uIGdldFNldERlY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUudHJhbnNmb3JtRGVjb2RlcihnZXRBcnJheURlY29kZXIoaXRlbSwgY29uZmlnKSwgKGVudHJpZXMpID0+IG5ldyBTZXQoZW50cmllcykpO1xufVxuZnVuY3Rpb24gZ2V0U2V0Q29kZWMoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKGdldFNldEVuY29kZXIoaXRlbSwgY29uZmlnKSwgZ2V0U2V0RGVjb2RlcihpdGVtLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIGdldFN0cnVjdEVuY29kZXIoZmllbGRzKSB7XG4gIGNvbnN0IGZpZWxkQ29kZWNzID0gZmllbGRzLm1hcCgoWywgY29kZWNdKSA9PiBjb2RlYyk7XG4gIGNvbnN0IGZpeGVkU2l6ZSA9IHN1bUNvZGVjU2l6ZXMoZmllbGRDb2RlY3MubWFwKGdldEZpeGVkU2l6ZSkpO1xuICBjb25zdCBtYXhTaXplID0gc3VtQ29kZWNTaXplcyhmaWVsZENvZGVjcy5tYXAoZ2V0TWF4U2l6ZSkpID8/IHZvaWQgMDtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplID09PSBudWxsID8ge1xuICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBmaWVsZHMubWFwKChba2V5LCBjb2RlY10pID0+IGNvZGVjc0NvcmUuZ2V0RW5jb2RlZFNpemUodmFsdWVba2V5XSwgY29kZWMpKS5yZWR1Y2UoKGFsbCwgb25lKSA9PiBhbGwgKyBvbmUsIDApLFxuICAgICAgbWF4U2l6ZVxuICAgIH0gOiB7IGZpeGVkU2l6ZSB9LFxuICAgIHdyaXRlOiAoc3RydWN0LCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBmaWVsZHMuZm9yRWFjaCgoW2tleSwgY29kZWNdKSA9PiB7XG4gICAgICAgIG9mZnNldCA9IGNvZGVjLndyaXRlKHN0cnVjdFtrZXldLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0RGVjb2RlcihmaWVsZHMpIHtcbiAgY29uc3QgZmllbGRDb2RlY3MgPSBmaWVsZHMubWFwKChbLCBjb2RlY10pID0+IGNvZGVjKTtcbiAgY29uc3QgZml4ZWRTaXplID0gc3VtQ29kZWNTaXplcyhmaWVsZENvZGVjcy5tYXAoZ2V0Rml4ZWRTaXplKSk7XG4gIGNvbnN0IG1heFNpemUgPSBzdW1Db2RlY1NpemVzKGZpZWxkQ29kZWNzLm1hcChnZXRNYXhTaXplKSkgPz8gdm9pZCAwO1xuICByZXR1cm4gY29kZWNzQ29yZS5jcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5maXhlZFNpemUgPT09IG51bGwgPyB7IG1heFNpemUgfSA6IHsgZml4ZWRTaXplIH0sXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IHt9O1xuICAgICAgZmllbGRzLmZvckVhY2goKFtrZXksIGNvZGVjXSkgPT4ge1xuICAgICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBjb2RlYy5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgIHN0cnVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbc3RydWN0LCBvZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdHJ1Y3RDb2RlYyhmaWVsZHMpIHtcbiAgcmV0dXJuIGNvZGVjc0NvcmUuY29tYmluZUNvZGVjKFxuICAgIGdldFN0cnVjdEVuY29kZXIoZmllbGRzKSxcbiAgICBnZXRTdHJ1Y3REZWNvZGVyKGZpZWxkcylcbiAgKTtcbn1cblxuZXhwb3J0cy5hc3NlcnRWYWxpZE51bWJlck9mSXRlbXNGb3JDb2RlYyA9IGFzc2VydFZhbGlkTnVtYmVyT2ZJdGVtc0ZvckNvZGVjO1xuZXhwb3J0cy5nZXRBcnJheUNvZGVjID0gZ2V0QXJyYXlDb2RlYztcbmV4cG9ydHMuZ2V0QXJyYXlEZWNvZGVyID0gZ2V0QXJyYXlEZWNvZGVyO1xuZXhwb3J0cy5nZXRBcnJheUVuY29kZXIgPSBnZXRBcnJheUVuY29kZXI7XG5leHBvcnRzLmdldEJpdEFycmF5Q29kZWMgPSBnZXRCaXRBcnJheUNvZGVjO1xuZXhwb3J0cy5nZXRCaXRBcnJheURlY29kZXIgPSBnZXRCaXRBcnJheURlY29kZXI7XG5leHBvcnRzLmdldEJpdEFycmF5RW5jb2RlciA9IGdldEJpdEFycmF5RW5jb2RlcjtcbmV4cG9ydHMuZ2V0Qm9vbGVhbkNvZGVjID0gZ2V0Qm9vbGVhbkNvZGVjO1xuZXhwb3J0cy5nZXRCb29sZWFuRGVjb2RlciA9IGdldEJvb2xlYW5EZWNvZGVyO1xuZXhwb3J0cy5nZXRCb29sZWFuRW5jb2RlciA9IGdldEJvb2xlYW5FbmNvZGVyO1xuZXhwb3J0cy5nZXRCeXRlc0NvZGVjID0gZ2V0Qnl0ZXNDb2RlYztcbmV4cG9ydHMuZ2V0Qnl0ZXNEZWNvZGVyID0gZ2V0Qnl0ZXNEZWNvZGVyO1xuZXhwb3J0cy5nZXRCeXRlc0VuY29kZXIgPSBnZXRCeXRlc0VuY29kZXI7XG5leHBvcnRzLmdldENvbnN0YW50Q29kZWMgPSBnZXRDb25zdGFudENvZGVjO1xuZXhwb3J0cy5nZXRDb25zdGFudERlY29kZXIgPSBnZXRDb25zdGFudERlY29kZXI7XG5leHBvcnRzLmdldENvbnN0YW50RW5jb2RlciA9IGdldENvbnN0YW50RW5jb2RlcjtcbmV4cG9ydHMuZ2V0RGF0YUVudW1Db2RlYyA9IGdldERhdGFFbnVtQ29kZWM7XG5leHBvcnRzLmdldERhdGFFbnVtRGVjb2RlciA9IGdldERhdGFFbnVtRGVjb2RlcjtcbmV4cG9ydHMuZ2V0RGF0YUVudW1FbmNvZGVyID0gZ2V0RGF0YUVudW1FbmNvZGVyO1xuZXhwb3J0cy5nZXREaXNjcmltaW5hdGVkVW5pb25Db2RlYyA9IGdldERpc2NyaW1pbmF0ZWRVbmlvbkNvZGVjO1xuZXhwb3J0cy5nZXREaXNjcmltaW5hdGVkVW5pb25EZWNvZGVyID0gZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2RlcjtcbmV4cG9ydHMuZ2V0RGlzY3JpbWluYXRlZFVuaW9uRW5jb2RlciA9IGdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXI7XG5leHBvcnRzLmdldEVudW1Db2RlYyA9IGdldEVudW1Db2RlYztcbmV4cG9ydHMuZ2V0RW51bURlY29kZXIgPSBnZXRFbnVtRGVjb2RlcjtcbmV4cG9ydHMuZ2V0RW51bUVuY29kZXIgPSBnZXRFbnVtRW5jb2RlcjtcbmV4cG9ydHMuZ2V0SGlkZGVuUHJlZml4Q29kZWMgPSBnZXRIaWRkZW5QcmVmaXhDb2RlYztcbmV4cG9ydHMuZ2V0SGlkZGVuUHJlZml4RGVjb2RlciA9IGdldEhpZGRlblByZWZpeERlY29kZXI7XG5leHBvcnRzLmdldEhpZGRlblByZWZpeEVuY29kZXIgPSBnZXRIaWRkZW5QcmVmaXhFbmNvZGVyO1xuZXhwb3J0cy5nZXRIaWRkZW5TdWZmaXhDb2RlYyA9IGdldEhpZGRlblN1ZmZpeENvZGVjO1xuZXhwb3J0cy5nZXRIaWRkZW5TdWZmaXhEZWNvZGVyID0gZ2V0SGlkZGVuU3VmZml4RGVjb2RlcjtcbmV4cG9ydHMuZ2V0SGlkZGVuU3VmZml4RW5jb2RlciA9IGdldEhpZGRlblN1ZmZpeEVuY29kZXI7XG5leHBvcnRzLmdldE1hcENvZGVjID0gZ2V0TWFwQ29kZWM7XG5leHBvcnRzLmdldE1hcERlY29kZXIgPSBnZXRNYXBEZWNvZGVyO1xuZXhwb3J0cy5nZXRNYXBFbmNvZGVyID0gZ2V0TWFwRW5jb2RlcjtcbmV4cG9ydHMuZ2V0TnVsbGFibGVDb2RlYyA9IGdldE51bGxhYmxlQ29kZWM7XG5leHBvcnRzLmdldE51bGxhYmxlRGVjb2RlciA9IGdldE51bGxhYmxlRGVjb2RlcjtcbmV4cG9ydHMuZ2V0TnVsbGFibGVFbmNvZGVyID0gZ2V0TnVsbGFibGVFbmNvZGVyO1xuZXhwb3J0cy5nZXRTY2FsYXJFbnVtQ29kZWMgPSBnZXRTY2FsYXJFbnVtQ29kZWM7XG5leHBvcnRzLmdldFNjYWxhckVudW1EZWNvZGVyID0gZ2V0U2NhbGFyRW51bURlY29kZXI7XG5leHBvcnRzLmdldFNjYWxhckVudW1FbmNvZGVyID0gZ2V0U2NhbGFyRW51bUVuY29kZXI7XG5leHBvcnRzLmdldFNldENvZGVjID0gZ2V0U2V0Q29kZWM7XG5leHBvcnRzLmdldFNldERlY29kZXIgPSBnZXRTZXREZWNvZGVyO1xuZXhwb3J0cy5nZXRTZXRFbmNvZGVyID0gZ2V0U2V0RW5jb2RlcjtcbmV4cG9ydHMuZ2V0U3RydWN0Q29kZWMgPSBnZXRTdHJ1Y3RDb2RlYztcbmV4cG9ydHMuZ2V0U3RydWN0RGVjb2RlciA9IGdldFN0cnVjdERlY29kZXI7XG5leHBvcnRzLmdldFN0cnVjdEVuY29kZXIgPSBnZXRTdHJ1Y3RFbmNvZGVyO1xuZXhwb3J0cy5nZXRUdXBsZUNvZGVjID0gZ2V0VHVwbGVDb2RlYztcbmV4cG9ydHMuZ2V0VHVwbGVEZWNvZGVyID0gZ2V0VHVwbGVEZWNvZGVyO1xuZXhwb3J0cy5nZXRUdXBsZUVuY29kZXIgPSBnZXRUdXBsZUVuY29kZXI7XG5leHBvcnRzLmdldFVuaW9uQ29kZWMgPSBnZXRVbmlvbkNvZGVjO1xuZXhwb3J0cy5nZXRVbmlvbkRlY29kZXIgPSBnZXRVbmlvbkRlY29kZXI7XG5leHBvcnRzLmdldFVuaW9uRW5jb2RlciA9IGdldFVuaW9uRW5jb2RlcjtcbmV4cG9ydHMuZ2V0VW5pdENvZGVjID0gZ2V0VW5pdENvZGVjO1xuZXhwb3J0cy5nZXRVbml0RGVjb2RlciA9IGdldFVuaXREZWNvZGVyO1xuZXhwb3J0cy5nZXRVbml0RW5jb2RlciA9IGdldFVuaXRFbmNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5janMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmNqcy5tYXAiXSwibmFtZXMiOlsiY29kZWNzQ29yZSIsInJlcXVpcmUiLCJjb2RlY3NOdW1iZXJzIiwiZXJyb3JzIiwiYXNzZXJ0VmFsaWROdW1iZXJPZkl0ZW1zRm9yQ29kZWMiLCJjb2RlY0Rlc2NyaXB0aW9uIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyIsIm1heENvZGVjU2l6ZXMiLCJzaXplcyIsInJlZHVjZSIsImFsbCIsInNpemUiLCJNYXRoIiwibWF4Iiwic3VtQ29kZWNTaXplcyIsImdldEZpeGVkU2l6ZSIsImNvZGVjIiwiaXNGaXhlZFNpemUiLCJmaXhlZFNpemUiLCJnZXRNYXhTaXplIiwibWF4U2l6ZSIsImdldEFycmF5RW5jb2RlciIsIml0ZW0iLCJjb25maWciLCJnZXRVMzJFbmNvZGVyIiwiY29tcHV0ZUFycmF5TGlrZUNvZGVjU2l6ZSIsImNyZWF0ZUVuY29kZXIiLCJnZXRTaXplRnJvbVZhbHVlIiwiYXJyYXkiLCJwcmVmaXhTaXplIiwiZ2V0RW5jb2RlZFNpemUiLCJsZW5ndGgiLCJ2YWx1ZSIsIndyaXRlIiwiYnl0ZXMiLCJvZmZzZXQiLCJmb3JFYWNoIiwiZ2V0QXJyYXlEZWNvZGVyIiwiZ2V0VTMyRGVjb2RlciIsIml0ZW1TaXplIiwiY3JlYXRlRGVjb2RlciIsInJlYWQiLCJzbGljZSIsIm5ld09mZnNldDIiLCJwdXNoIiwicmVzb2x2ZWRTaXplIiwibmV3T2Zmc2V0IiwiaSIsImdldEFycmF5Q29kZWMiLCJjb21iaW5lQ29kZWMiLCJnZXRCaXRBcnJheUVuY29kZXIiLCJwYXJzZWRDb25maWciLCJiYWNrd2FyZCIsImJ5dGVzVG9BZGQiLCJieXRlIiwiaiIsImZlYXR1cmUiLCJOdW1iZXIiLCJ1bnNoaWZ0Iiwic2V0IiwiZ2V0Qml0QXJyYXlEZWNvZGVyIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImJvb2xlYW5zIiwicmV2ZXJzZSIsIkJvb2xlYW4iLCJnZXRCaXRBcnJheUNvZGVjIiwiZ2V0Qm9vbGVhbkVuY29kZXIiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwiZ2V0VThFbmNvZGVyIiwiZ2V0Qm9vbGVhbkRlY29kZXIiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwiZ2V0VThEZWNvZGVyIiwiZ2V0Qm9vbGVhbkNvZGVjIiwiZ2V0Qnl0ZXNFbmNvZGVyIiwiZ2V0Qnl0ZXNEZWNvZGVyIiwiZ2V0Qnl0ZXNDb2RlYyIsImdldEJhc2UxNkRlY29kZXIiLCJzdHIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZ2V0Q29uc3RhbnRFbmNvZGVyIiwiY29uc3RhbnQiLCJfIiwiZ2V0Q29uc3RhbnREZWNvZGVyIiwiYmFzZTE2IiwiY29udGFpbnNCeXRlcyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UIiwiZGF0YSIsImhleENvbnN0YW50IiwiZGVjb2RlIiwiaGV4RGF0YSIsImdldENvbnN0YW50Q29kZWMiLCJnZXRUdXBsZUVuY29kZXIiLCJpdGVtcyIsIm1hcCIsImluZGV4Iiwib25lIiwiZ2V0VHVwbGVEZWNvZGVyIiwidmFsdWVzIiwibmV3VmFsdWUiLCJnZXRUdXBsZUNvZGVjIiwiZ2V0VW5pb25FbmNvZGVyIiwidmFyaWFudHMiLCJnZXRJbmRleEZyb21WYWx1ZSIsImdldFVuaW9uRml4ZWRTaXplIiwidmFyaWFudCIsImFzc2VydFZhbGlkVmFyaWFudEluZGV4IiwiZ2V0VW5pb25NYXhTaXplIiwiZ2V0VW5pb25EZWNvZGVyIiwiZ2V0SW5kZXhGcm9tQnl0ZXMiLCJnZXRVbmlvbkNvZGVjIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFIiwibWF4UmFuZ2UiLCJtaW5SYW5nZSIsInZhcmlhbnRTaXplIiwic2FtZVNpemVkVmFyaWFudHMiLCJldmVyeSIsImdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXIiLCJkaXNjcmltaW5hdG9yUHJvcGVydHkiLCJkaXNjcmltaW5hdG9yIiwicHJlZml4IiwiZ2V0VmFyaWFudERpc2NyaW1pbmF0b3IiLCJnZXREaXNjcmltaW5hdGVkVW5pb25EZWNvZGVyIiwiZ2V0RGlzY3JpbWluYXRlZFVuaW9uQ29kZWMiLCJkaXNjcmltaW5hdG9yVmFsdWUiLCJmaW5kSW5kZXgiLCJrZXkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQiLCJnZXREYXRhRW51bUVuY29kZXIiLCJnZXREYXRhRW51bURlY29kZXIiLCJnZXREYXRhRW51bUNvZGVjIiwiZ2V0RW51bVN0YXRzIiwiY29uc3RydWN0b3IiLCJudW1lcmljYWxWYWx1ZXMiLCJTZXQiLCJPYmplY3QiLCJmaWx0ZXIiLCJ2Iiwic29ydCIsImVudW1SZWNvcmQiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJlbnVtS2V5cyIsImtleXMiLCJlbnVtVmFsdWVzIiwic3RyaW5nVmFsdWVzIiwiZ2V0RW51bUluZGV4RnJvbVZhcmlhbnQiLCJ2YWx1ZUluZGV4IiwiZmluZExhc3RJbmRleCIsImdldEVudW1JbmRleEZyb21EaXNjcmltaW5hdG9yIiwidXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyIsInByZWRpY2F0ZSIsImwiLCJmb3JtYXROdW1lcmljYWxWYWx1ZXMiLCJyYW5nZSIsInJhbmdlcyIsImpvaW4iLCJnZXRFbnVtRW5jb2RlciIsInNvbWUiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UIiwiZm9ybWF0dGVkTnVtZXJpY2FsVmFsdWVzIiwiZ2V0RW51bURlY29kZXIiLCJ2YWxpZERpc2NyaW1pbmF0b3JzIiwiQXJyYXkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSIsImZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnMiLCJnZXRFbnVtQ29kZWMiLCJnZXRTY2FsYXJFbnVtRW5jb2RlciIsImdldFNjYWxhckVudW1EZWNvZGVyIiwiZ2V0U2NhbGFyRW51bUNvZGVjIiwiZ2V0SGlkZGVuUHJlZml4RW5jb2RlciIsImVuY29kZXIiLCJwcmVmaXhlZEVuY29kZXJzIiwiZ2V0SGlkZGVuUHJlZml4RGVjb2RlciIsImRlY29kZXIiLCJwcmVmaXhlZERlY29kZXJzIiwidHVwbGUiLCJnZXRIaWRkZW5QcmVmaXhDb2RlYyIsInByZWZpeGVkQ29kZWNzIiwiZ2V0SGlkZGVuU3VmZml4RW5jb2RlciIsInN1ZmZpeGVkRW5jb2RlcnMiLCJnZXRIaWRkZW5TdWZmaXhEZWNvZGVyIiwic3VmZml4ZWREZWNvZGVycyIsImdldEhpZGRlblN1ZmZpeENvZGVjIiwic3VmZml4ZWRDb2RlY3MiLCJnZXRNYXBFbmNvZGVyIiwiZ2V0TWFwRGVjb2RlciIsIk1hcCIsImdldE1hcENvZGVjIiwiZ2V0VW5pdEVuY29kZXIiLCJfdmFsdWUiLCJfYnl0ZXMiLCJnZXRVbml0RGVjb2RlciIsImdldFVuaXRDb2RlYyIsImdldE51bGxhYmxlRW5jb2RlciIsIl9ib29sZWFuIiwibm9uZVZhbHVlIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJmaXhFbmNvZGVyU2l6ZSIsImdldE51bGxhYmxlRGVjb2RlciIsImZpeERlY29kZXJTaXplIiwiemVyb1ZhbHVlIiwiVWludDhBcnJheSIsImZpbGwiLCJnZXROdWxsYWJsZUNvZGVjIiwiZ2V0U2V0RW5jb2RlciIsImdldFNldERlY29kZXIiLCJnZXRTZXRDb2RlYyIsImdldFN0cnVjdEVuY29kZXIiLCJmaWVsZHMiLCJmaWVsZENvZGVjcyIsInN0cnVjdCIsImdldFN0cnVjdERlY29kZXIiLCJnZXRTdHJ1Y3RDb2RlYyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-data-structures@2.0.0-rc.1_typescript@5.8.3/node_modules/@solana/codecs-data-structures/dist/index.node.cjs\n");

/***/ })

};
;