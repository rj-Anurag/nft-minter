"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject+contracts@5.8.0";
exports.ids = ["vendor-chunks/@ethersproject+contracts@5.8.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"contracts/5.8.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrY29udHJhY3RzQDUuOC4wL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtjb250cmFjdHNANS44LjAvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL192ZXJzaW9uLmpzPzQyMDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImNvbnRyYWN0cy81LjguMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abi@5.8.0/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abi@5.8.0/node_modules/@ethersproject/abi/lib.esm/interface.js\");\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-provider@5.8.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-signer@5.8.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/.pnpm/@ethersproject+transactions@5.8.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    from: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const name = yield nameOrPromise;\n        if (typeof name !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(name);\n        } catch (error) {}\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index)=>{\n                return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v)=>resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function*() {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check)=>__awaiter(this, void 0, void 0, function*() {\n                        if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(check.signer) !== check.override) {\n                            logger.throwError(\"Contract with a Signer cannot override from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"overrides.from\"\n                            });\n                        }\n                        return check.override;\n                    }));\n            } else {\n                overrides.from = contract.signer.getAddress();\n            }\n        } else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n        //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(overrides) || {}\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__.accessListify)(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(data);\n            for(let i = 0; i < bytes.length; i++){\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key)=>overrides[key] != null);\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l)=>JSON.stringify(l)).join(\",\")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function(...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations)=>{\n        return wait(confirmations).then((receipt)=>{\n            receipt.events = receipt.logs.map((log)=>{\n                let event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e) {}\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics)=>{\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = ()=>{\n                    return contract.provider;\n                };\n                event.getBlock = ()=>{\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = ()=>{\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = ()=>{\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n                const overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({\n            listener: listener,\n            once: once\n        });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item)=>{\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i)=>i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item)=>{\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(()=>{\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !item.once;\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {}\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [\n            event\n        ];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor(){\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics){\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [\n                topic\n            ];\n        }\n        super(getEventTag(filter), filter);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics)=>{\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = (0,_ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__.checkResultErrors)(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface){\n        super(\"*\", {\n            address: address\n        });\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics)=>{\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        } catch (error) {\n        // No matching event\n        }\n    }\n}\nclass BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider){\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider.provider || null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signerOrProvider);\n        } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"callStatic\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"estimateGas\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"populateTransaction\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature)=>{\n                const event = this.interface.events[eventSignature];\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, eventSignature, (...args)=>{\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name)=>{\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_runningEvents\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", addressOrName);\n        if (this.provider) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", Promise.resolve((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e)=>{});\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature)=>{\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name)=>{\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, name, this[signature]);\n                }\n            } catch (e) {}\n            if (this.functions[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(()=>{\n                    return this;\n                });\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code)=>{\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction(fallback)\"\n            });\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(overrides || {});\n        [\n            \"from\",\n            \"to\"\n        ].forEach(function(key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(()=>{\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof signerOrProvider === \"string\") {\n            signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new this.constructor(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof eventName === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof topic !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) {}\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n        event.removeListener = ()=>{\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = ()=>{\n            return this.provider.getBlock(log.blockHash);\n        };\n        event.getTransaction = ()=>{\n            return this.provider.getTransaction(log.transactionHash);\n        };\n        event.getTransactionReceipt = ()=>{\n            return this.provider.getTransactionReceipt(log.transactionHash);\n        };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"once\"\n            });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no harm in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log)=>{\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(runningEvent.filter);\n        if (typeof fromBlockOrBlockhash === \"string\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        } else {\n            filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;\n            filter.toBlock = toBlock != null ? toBlock : \"latest\";\n        }\n        return this.provider.getLogs(filter).then((logs)=>{\n            return logs.map((log)=>this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = runningEvent.run(args) > 0;\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key)=>{\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for(let tag in this._runningEvents){\n                this._runningEvents[tag].listeners().forEach((listener)=>{\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for(const tag in this._runningEvents){\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nclass Contract extends BaseContract {\n}\nclass ContractFactory {\n    constructor(contractInterface, bytecode, signer){\n        let bytecodeHex = null;\n        if (typeof bytecode === \"string\") {\n            bytecodeHex = bytecode;\n        } else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytes)(bytecode)) {\n            bytecodeHex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytecode);\n        } else if (bytecode && typeof bytecode.object === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"bytecode\", bytecodeHex);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n            for(const key in tx){\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\n            \"data\",\n            \"from\",\n            \"to\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        if (tx.value) {\n            const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContractAddress\")(tx);\n            const contract = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return this.constructor.getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new this.constructor(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.MISSING_ARGUMENT, {\n                argument: \"compilerOutput\"\n            });\n        }\n        if (typeof compilerOutput === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrY29udHJhY3RzQDUuOC4wL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQzJFO0FBQ2Y7QUFDUTtBQUNJO0FBQ25CO0FBQ2tDO0FBQ3lCO0FBQ3BEO0FBQ2I7QUFDVjtBQUNyQyxNQUFNNkIsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BOzs7QUFHakMsK0JBQStCO0FBQy9CLE1BQU1FLHlCQUF5QjtJQUMzQkMsU0FBUztJQUFNQyxNQUFNO0lBQU1DLE1BQU07SUFBTUMsVUFBVTtJQUFNQyxVQUFVO0lBQU1DLE9BQU87SUFBTUMsSUFBSTtJQUFNM0MsT0FBTztJQUNyRzRDLE1BQU07SUFBTUMsWUFBWTtJQUN4QkMsY0FBYztJQUFNQyxzQkFBc0I7SUFDMUNDLFlBQVk7SUFDWkMsaUJBQWlCO0FBQ3JCO0FBQ0EsU0FBU0MsWUFBWUMsUUFBUSxFQUFFQyxhQUFhO0lBQ3hDLE9BQU8xRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE1BQU0yRCxPQUFPLE1BQU1EO1FBQ25CLElBQUksT0FBUUMsU0FBVSxVQUFVO1lBQzVCbEIsT0FBT21CLGtCQUFrQixDQUFDLCtCQUErQixRQUFRRDtRQUNyRTtRQUNBLG1FQUFtRTtRQUNuRSxJQUFJO1lBQ0EsT0FBT2xDLGtFQUFVQSxDQUFDa0M7UUFDdEIsRUFDQSxPQUFPRSxPQUFPLENBQUU7UUFDaEIsSUFBSSxDQUFDSixVQUFVO1lBQ1hoQixPQUFPcUIsVUFBVSxDQUFDLHVEQUF1RHZCLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtnQkFDMUdDLFdBQVc7WUFDZjtRQUNKO1FBQ0EsTUFBTUMsVUFBVSxNQUFNVCxTQUFTRCxXQUFXLENBQUNHO1FBQzNDLElBQUlPLFdBQVcsTUFBTTtZQUNqQnpCLE9BQU9tQixrQkFBa0IsQ0FBQyxtREFBbUQsUUFBUUQ7UUFDekY7UUFDQSxPQUFPTztJQUNYO0FBQ0o7QUFDQSwrRkFBK0Y7QUFDL0YsU0FBU0MsaUJBQWlCVixRQUFRLEVBQUVuRCxLQUFLLEVBQUU4RCxTQUFTO0lBQ2hELE9BQU9wRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLElBQUlxRSxNQUFNQyxPQUFPLENBQUNGLFlBQVk7WUFDMUIsT0FBTyxNQUFNNUQsUUFBUStELEdBQUcsQ0FBQ0gsVUFBVUksR0FBRyxDQUFDLENBQUNKLFdBQVdLO2dCQUMvQyxPQUFPTixpQkFBaUJWLFVBQVcsTUFBT2EsT0FBTyxDQUFDaEUsU0FBVUEsS0FBSyxDQUFDbUUsTUFBTSxHQUFHbkUsS0FBSyxDQUFDOEQsVUFBVVQsSUFBSSxDQUFDLEVBQUdTO1lBQ3ZHO1FBQ0o7UUFDQSxJQUFJQSxVQUFVbEIsSUFBSSxLQUFLLFdBQVc7WUFDOUIsT0FBTyxNQUFNTSxZQUFZQyxVQUFVbkQ7UUFDdkM7UUFDQSxJQUFJOEQsVUFBVWxCLElBQUksS0FBSyxTQUFTO1lBQzVCLE9BQU8sTUFBTWlCLGlCQUFpQlYsVUFBVW5ELE9BQU84RCxVQUFVTSxVQUFVO1FBQ3ZFO1FBQ0EsSUFBSU4sVUFBVU8sUUFBUSxLQUFLLFNBQVM7WUFDaEMsSUFBSSxDQUFDTixNQUFNQyxPQUFPLENBQUNoRSxRQUFRO2dCQUN2QixPQUFPRSxRQUFRQyxNQUFNLENBQUNnQyxPQUFPbUMsU0FBUyxDQUFDLDJCQUEyQnJDLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDYyxnQkFBZ0IsRUFBRTtvQkFDOUZDLFVBQVU7b0JBQ1Z4RTtnQkFDSjtZQUNKO1lBQ0EsT0FBTyxNQUFNRSxRQUFRK0QsR0FBRyxDQUFDakUsTUFBTWtFLEdBQUcsQ0FBQyxDQUFDTyxJQUFNWixpQkFBaUJWLFVBQVVzQixHQUFHWCxVQUFVWSxhQUFhO1FBQ25HO1FBQ0EsT0FBTzFFO0lBQ1g7QUFDSjtBQUNBLFNBQVMyRSxvQkFBb0JDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxJQUFJO0lBQ2pELE9BQU9wRixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLGlEQUFpRDtRQUNqRCxJQUFJcUYsWUFBWSxDQUFDO1FBQ2pCLElBQUlELEtBQUtFLE1BQU0sS0FBS0gsU0FBU0ksTUFBTSxDQUFDRCxNQUFNLEdBQUcsS0FBSyxPQUFRRixJQUFJLENBQUNBLEtBQUtFLE1BQU0sR0FBRyxFQUFFLEtBQU0sVUFBVTtZQUMzRkQsWUFBWWhELHNFQUFXQSxDQUFDK0MsS0FBS0ksR0FBRztRQUNwQztRQUNBLHdDQUF3QztRQUN4Qy9DLE9BQU9nRCxrQkFBa0IsQ0FBQ0wsS0FBS0UsTUFBTSxFQUFFSCxTQUFTSSxNQUFNLENBQUNELE1BQU0sRUFBRTtRQUMvRCw0Q0FBNEM7UUFDNUMsSUFBSUosU0FBU1EsTUFBTSxFQUFFO1lBQ2pCLElBQUlMLFVBQVV4QyxJQUFJLEVBQUU7Z0JBQ2hCLG9FQUFvRTtnQkFDcEUsMERBQTBEO2dCQUMxRHdDLFVBQVV4QyxJQUFJLEdBQUdULDRFQUFpQkEsQ0FBQztvQkFDL0J1RCxVQUFVbkMsWUFBWTBCLFNBQVNRLE1BQU0sRUFBRUwsVUFBVXhDLElBQUk7b0JBQ3JENkMsUUFBUVIsU0FBU1EsTUFBTSxDQUFDakUsVUFBVTtnQkFDdEMsR0FBR1IsSUFBSSxDQUFDLENBQUMyRSxRQUFVNUYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzt3QkFDL0MsSUFBSXlCLGtFQUFVQSxDQUFDbUUsTUFBTUYsTUFBTSxNQUFNRSxNQUFNRCxRQUFRLEVBQUU7NEJBQzdDbEQsT0FBT3FCLFVBQVUsQ0FBQywrQ0FBK0N2Qix5REFBTUEsQ0FBQ3dCLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7Z0NBQ2xHQyxXQUFXOzRCQUNmO3dCQUNKO3dCQUNBLE9BQU8yQixNQUFNRCxRQUFRO29CQUN6QjtZQUNKLE9BQ0s7Z0JBQ0ROLFVBQVV4QyxJQUFJLEdBQUdxQyxTQUFTUSxNQUFNLENBQUNqRSxVQUFVO1lBQy9DO1FBQ0osT0FDSyxJQUFJNEQsVUFBVXhDLElBQUksRUFBRTtZQUNyQndDLFVBQVV4QyxJQUFJLEdBQUdXLFlBQVkwQixTQUFTVyxRQUFRLEVBQUVSLFVBQVV4QyxJQUFJO1FBQzlELFVBQVU7UUFDVix5REFBeUQ7UUFDekQsdUNBQXVDO1FBQ3ZDLCtCQUErQjtRQUNuQztRQUNBLGlGQUFpRjtRQUNqRixNQUFNaUQsV0FBVyxNQUFNMUQsNEVBQWlCQSxDQUFDO1lBQ3JDZ0QsTUFBTWpCLGlCQUFpQmUsU0FBU1EsTUFBTSxJQUFJUixTQUFTVyxRQUFRLEVBQUVULE1BQU1ELFNBQVNJLE1BQU07WUFDbEZyQixTQUFTZ0IsU0FBU2EsZUFBZTtZQUNqQ1YsV0FBWWpELDRFQUFpQkEsQ0FBQ2lELGNBQWMsQ0FBQztRQUNqRDtRQUNBLDRCQUE0QjtRQUM1QixNQUFNekMsT0FBT3NDLFNBQVNjLFNBQVMsQ0FBQ0Msa0JBQWtCLENBQUNkLFVBQVVXLFNBQVNWLElBQUk7UUFDMUUsTUFBTWMsS0FBSztZQUNQdEQsTUFBTUE7WUFDTkssSUFBSTZDLFNBQVM1QixPQUFPO1FBQ3hCO1FBQ0EscUJBQXFCO1FBQ3JCLE1BQU1pQyxLQUFLTCxTQUFTVCxTQUFTO1FBQzdCLDRCQUE0QjtRQUM1QixJQUFJYyxHQUFHbkQsS0FBSyxJQUFJLE1BQU07WUFDbEJrRCxHQUFHbEQsS0FBSyxHQUFHckIsK0RBQVNBLENBQUNrQixJQUFJLENBQUNzRCxHQUFHbkQsS0FBSyxFQUFFb0QsUUFBUTtRQUNoRDtRQUNBLElBQUlELEdBQUdyRCxRQUFRLElBQUksTUFBTTtZQUNyQm9ELEdBQUdwRCxRQUFRLEdBQUduQiwrREFBU0EsQ0FBQ2tCLElBQUksQ0FBQ3NELEdBQUdyRCxRQUFRO1FBQzVDO1FBQ0EsSUFBSXFELEdBQUdwRCxRQUFRLElBQUksTUFBTTtZQUNyQm1ELEdBQUduRCxRQUFRLEdBQUdwQiwrREFBU0EsQ0FBQ2tCLElBQUksQ0FBQ3NELEdBQUdwRCxRQUFRO1FBQzVDO1FBQ0EsSUFBSW9ELEdBQUcvQyxZQUFZLElBQUksTUFBTTtZQUN6QjhDLEdBQUc5QyxZQUFZLEdBQUd6QiwrREFBU0EsQ0FBQ2tCLElBQUksQ0FBQ3NELEdBQUcvQyxZQUFZO1FBQ3BEO1FBQ0EsSUFBSStDLEdBQUc5QyxvQkFBb0IsSUFBSSxNQUFNO1lBQ2pDNkMsR0FBRzdDLG9CQUFvQixHQUFHMUIsK0RBQVNBLENBQUNrQixJQUFJLENBQUNzRCxHQUFHOUMsb0JBQW9CO1FBQ3BFO1FBQ0EsSUFBSThDLEdBQUd0RCxJQUFJLElBQUksTUFBTTtZQUNqQnFELEdBQUdyRCxJQUFJLEdBQUdzRCxHQUFHdEQsSUFBSTtRQUNyQjtRQUNBLElBQUlzRCxHQUFHakQsSUFBSSxJQUFJLE1BQU07WUFDakJnRCxHQUFHaEQsSUFBSSxHQUFHaUQsR0FBR2pELElBQUk7UUFDckI7UUFDQSxJQUFJaUQsR0FBR2hELFVBQVUsSUFBSSxNQUFNO1lBQ3ZCK0MsR0FBRy9DLFVBQVUsR0FBR2IsMEVBQWFBLENBQUM2RCxHQUFHaEQsVUFBVTtRQUMvQztRQUNBLCtFQUErRTtRQUMvRSxJQUFJK0MsR0FBR3BELFFBQVEsSUFBSSxRQUFRcUMsU0FBU2tCLEdBQUcsSUFBSSxNQUFNO1lBQzdDLHNEQUFzRDtZQUN0RCwrRUFBK0U7WUFDL0UsOEVBQThFO1lBQzlFLDhFQUE4RTtZQUM5RSx3Q0FBd0M7WUFDeEMsSUFBSUMsWUFBWTtZQUNoQixNQUFNQyxRQUFRM0UsOERBQVFBLENBQUNnQjtZQUN2QixJQUFLLElBQUk0RCxJQUFJLEdBQUdBLElBQUlELE1BQU1qQixNQUFNLEVBQUVrQixJQUFLO2dCQUNuQ0YsYUFBYTtnQkFDYixJQUFJQyxLQUFLLENBQUNDLEVBQUUsRUFBRTtvQkFDVkYsYUFBYTtnQkFDakI7WUFDSjtZQUNBSixHQUFHcEQsUUFBUSxHQUFHbkIsK0RBQVNBLENBQUNrQixJQUFJLENBQUNzQyxTQUFTa0IsR0FBRyxFQUFFSSxHQUFHLENBQUNIO1FBQ25EO1FBQ0EsNEJBQTRCO1FBQzVCLElBQUlILEdBQUc3RixLQUFLLEVBQUU7WUFDVixNQUFNb0csVUFBVS9FLCtEQUFTQSxDQUFDa0IsSUFBSSxDQUFDc0QsR0FBRzdGLEtBQUs7WUFDdkMsSUFBSSxDQUFDb0csUUFBUUMsTUFBTSxNQUFNLENBQUN4QixTQUFTeUIsT0FBTyxFQUFFO2dCQUN4Q25FLE9BQU9xQixVQUFVLENBQUMsNENBQTRDdkIseURBQU1BLENBQUN3QixNQUFNLENBQUNDLHFCQUFxQixFQUFFO29CQUMvRkMsV0FBVztvQkFDWDNELE9BQU8rRSxVQUFVL0UsS0FBSztnQkFDMUI7WUFDSjtZQUNBNEYsR0FBRzVGLEtBQUssR0FBR29HO1FBQ2Y7UUFDQSxJQUFJUCxHQUFHN0MsVUFBVSxFQUFFO1lBQ2Y0QyxHQUFHNUMsVUFBVSxHQUFHakIsc0VBQVdBLENBQUM4RCxHQUFHN0MsVUFBVTtRQUM3QztRQUNBLElBQUk2QyxHQUFHNUMsZUFBZSxFQUFFO1lBQ3BCMkMsR0FBRzNDLGVBQWUsR0FBRyxDQUFDLENBQUM0QyxHQUFHNUMsZUFBZTtRQUM3QztRQUNBLHVCQUF1QjtRQUN2QixPQUFPOEIsVUFBVXJDLEtBQUs7UUFDdEIsT0FBT3FDLFVBQVV2QyxRQUFRO1FBQ3pCLE9BQU91QyxVQUFVdEMsUUFBUTtRQUN6QixPQUFPc0MsVUFBVXhDLElBQUk7UUFDckIsT0FBT3dDLFVBQVUvRSxLQUFLO1FBQ3RCLE9BQU8rRSxVQUFVbkMsSUFBSTtRQUNyQixPQUFPbUMsVUFBVWxDLFVBQVU7UUFDM0IsT0FBT2tDLFVBQVVqQyxZQUFZO1FBQzdCLE9BQU9pQyxVQUFVaEMsb0JBQW9CO1FBQ3JDLE9BQU9nQyxVQUFVL0IsVUFBVTtRQUMzQixPQUFPK0IsVUFBVTlCLGVBQWU7UUFDaEMsK0RBQStEO1FBQy9ELG9DQUFvQztRQUNwQyxNQUFNc0QsWUFBWUMsT0FBT0MsSUFBSSxDQUFDMUIsV0FBVzJCLE1BQU0sQ0FBQyxDQUFDQyxNQUFTNUIsU0FBUyxDQUFDNEIsSUFBSSxJQUFJO1FBQzVFLElBQUlKLFVBQVV2QixNQUFNLEVBQUU7WUFDbEI3QyxPQUFPcUIsVUFBVSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUrQyxVQUFVckMsR0FBRyxDQUFDLENBQUMwQyxJQUFNQyxLQUFLQyxTQUFTLENBQUNGLElBQUlHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTlFLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtnQkFDM0hDLFdBQVc7Z0JBQ1hvQixXQUFXd0I7WUFDZjtRQUNKO1FBQ0EsT0FBT1g7SUFDWDtBQUNKO0FBQ0EsU0FBU29CLGNBQWNwQyxRQUFRLEVBQUVDLFFBQVE7SUFDckMsT0FBTyxTQUFVLEdBQUdDLElBQUk7UUFDcEIsT0FBT0gsb0JBQW9CQyxVQUFVQyxVQUFVQztJQUNuRDtBQUNKO0FBQ0EsU0FBU21DLGNBQWNyQyxRQUFRLEVBQUVDLFFBQVE7SUFDckMsTUFBTXFDLG1CQUFvQnRDLFNBQVNRLE1BQU0sSUFBSVIsU0FBU1csUUFBUTtJQUM5RCxPQUFPLFNBQVUsR0FBR1QsSUFBSTtRQUNwQixPQUFPcEYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJLENBQUN3SCxrQkFBa0I7Z0JBQ25CL0UsT0FBT3FCLFVBQVUsQ0FBQyx5Q0FBeUN2Qix5REFBTUEsQ0FBQ3dCLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7b0JBQzVGQyxXQUFXO2dCQUNmO1lBQ0o7WUFDQSxNQUFNaUMsS0FBSyxNQUFNakIsb0JBQW9CQyxVQUFVQyxVQUFVQztZQUN6RCxPQUFPLE1BQU1vQyxpQkFBaUJDLFdBQVcsQ0FBQ3ZCO1FBQzlDO0lBQ0o7QUFDSjtBQUNBLFNBQVN3QixnQkFBZ0J4QyxRQUFRLEVBQUVnQixFQUFFO0lBQ2pDLE1BQU15QixPQUFPekIsR0FBR3lCLElBQUksQ0FBQ0MsSUFBSSxDQUFDMUI7SUFDMUJBLEdBQUd5QixJQUFJLEdBQUcsQ0FBQ0U7UUFDUCxPQUFPRixLQUFLRSxlQUFlNUcsSUFBSSxDQUFDLENBQUM2RztZQUM3QkEsUUFBUUMsTUFBTSxHQUFHRCxRQUFRRSxJQUFJLENBQUN4RCxHQUFHLENBQUMsQ0FBQ3lEO2dCQUMvQixJQUFJQyxRQUFRaEcsbUVBQVFBLENBQUMrRjtnQkFDckIsSUFBSUUsU0FBUztnQkFDYixJQUFJO29CQUNBQSxTQUFTakQsU0FBU2MsU0FBUyxDQUFDb0MsUUFBUSxDQUFDSDtnQkFDekMsRUFDQSxPQUFPcEgsR0FBRyxDQUFFO2dCQUNaLGdEQUFnRDtnQkFDaEQsSUFBSXNILFFBQVE7b0JBQ1JELE1BQU05QyxJQUFJLEdBQUcrQyxPQUFPL0MsSUFBSTtvQkFDeEI4QyxNQUFNRyxNQUFNLEdBQUcsQ0FBQ3pGLE1BQU0wRjt3QkFDbEIsT0FBT3BELFNBQVNjLFNBQVMsQ0FBQ3VDLGNBQWMsQ0FBQ0osT0FBT0ssYUFBYSxFQUFFNUYsTUFBTTBGO29CQUN6RTtvQkFDQUosTUFBTUEsS0FBSyxHQUFHQyxPQUFPeEUsSUFBSTtvQkFDekJ1RSxNQUFNTyxjQUFjLEdBQUdOLE9BQU9PLFNBQVM7Z0JBQzNDO2dCQUNBLG9CQUFvQjtnQkFDcEJSLE1BQU1TLGNBQWMsR0FBRztvQkFBUSxPQUFPekQsU0FBU1csUUFBUTtnQkFBRTtnQkFDekRxQyxNQUFNVSxRQUFRLEdBQUc7b0JBQ2IsT0FBTzFELFNBQVNXLFFBQVEsQ0FBQytDLFFBQVEsQ0FBQ2QsUUFBUWUsU0FBUztnQkFDdkQ7Z0JBQ0FYLE1BQU1ZLGNBQWMsR0FBRztvQkFDbkIsT0FBTzVELFNBQVNXLFFBQVEsQ0FBQ2lELGNBQWMsQ0FBQ2hCLFFBQVFpQixlQUFlO2dCQUNuRTtnQkFDQWIsTUFBTWMscUJBQXFCLEdBQUc7b0JBQzFCLE9BQU94SSxRQUFRRCxPQUFPLENBQUN1SDtnQkFDM0I7Z0JBQ0EsT0FBT0k7WUFDWDtZQUNBLE9BQU9KO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsU0FBU21CLFVBQVUvRCxRQUFRLEVBQUVDLFFBQVEsRUFBRStELGNBQWM7SUFDakQsTUFBTTFCLG1CQUFvQnRDLFNBQVNRLE1BQU0sSUFBSVIsU0FBU1csUUFBUTtJQUM5RCxPQUFPLFNBQVUsR0FBR1QsSUFBSTtRQUNwQixPQUFPcEYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyw2Q0FBNkM7WUFDN0MsSUFBSW1KLFdBQVdDO1lBQ2YsSUFBSWhFLEtBQUtFLE1BQU0sS0FBS0gsU0FBU0ksTUFBTSxDQUFDRCxNQUFNLEdBQUcsS0FBSyxPQUFRRixJQUFJLENBQUNBLEtBQUtFLE1BQU0sR0FBRyxFQUFFLEtBQU0sVUFBVTtnQkFDM0YsTUFBTUQsWUFBWWhELHNFQUFXQSxDQUFDK0MsS0FBS0ksR0FBRztnQkFDdEMsSUFBSUgsVUFBVThELFFBQVEsSUFBSSxNQUFNO29CQUM1QkEsV0FBVyxNQUFNOUQsVUFBVThELFFBQVE7Z0JBQ3ZDO2dCQUNBLE9BQU85RCxVQUFVOEQsUUFBUTtnQkFDekIvRCxLQUFLaUUsSUFBSSxDQUFDaEU7WUFDZDtZQUNBLDREQUE0RDtZQUM1RCxJQUFJSCxTQUFTb0UsaUJBQWlCLElBQUksTUFBTTtnQkFDcEMsTUFBTXBFLFNBQVNxRSxTQUFTLENBQUNKO1lBQzdCO1lBQ0EsaUNBQWlDO1lBQ2pDLE1BQU1qRCxLQUFLLE1BQU1qQixvQkFBb0JDLFVBQVVDLFVBQVVDO1lBQ3pELE1BQU1yRSxTQUFTLE1BQU15RyxpQkFBaUJnQyxJQUFJLENBQUN0RCxJQUFJaUQ7WUFDL0MsSUFBSTtnQkFDQSxJQUFJN0ksUUFBUTRFLFNBQVNjLFNBQVMsQ0FBQ3lELG9CQUFvQixDQUFDdEUsVUFBVXBFO2dCQUM5RCxJQUFJbUksa0JBQWtCL0QsU0FBU3VFLE9BQU8sQ0FBQ3BFLE1BQU0sS0FBSyxHQUFHO29CQUNqRGhGLFFBQVFBLEtBQUssQ0FBQyxFQUFFO2dCQUNwQjtnQkFDQSxPQUFPQTtZQUNYLEVBQ0EsT0FBT3VELE9BQU87Z0JBQ1YsSUFBSUEsTUFBTThGLElBQUksS0FBS3BILHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDNkYsY0FBYyxFQUFFO29CQUM3Qy9GLE1BQU1LLE9BQU8sR0FBR2dCLFNBQVNoQixPQUFPO29CQUNoQ0wsTUFBTXVCLElBQUksR0FBR0E7b0JBQ2J2QixNQUFNZ0csV0FBVyxHQUFHM0Q7Z0JBQ3hCO2dCQUNBLE1BQU1yQztZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU2lHLFVBQVU1RSxRQUFRLEVBQUVDLFFBQVE7SUFDakMsT0FBTyxTQUFVLEdBQUdDLElBQUk7UUFDcEIsT0FBT3BGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSSxDQUFDa0YsU0FBU1EsTUFBTSxFQUFFO2dCQUNsQmpELE9BQU9xQixVQUFVLENBQUMsMkNBQTJDdkIseURBQU1BLENBQUN3QixNQUFNLENBQUNDLHFCQUFxQixFQUFFO29CQUM5RkMsV0FBVztnQkFDZjtZQUNKO1lBQ0EsNERBQTREO1lBQzVELElBQUlpQixTQUFTb0UsaUJBQWlCLElBQUksTUFBTTtnQkFDcEMsTUFBTXBFLFNBQVNxRSxTQUFTO1lBQzVCO1lBQ0EsTUFBTVEsWUFBWSxNQUFNOUUsb0JBQW9CQyxVQUFVQyxVQUFVQztZQUNoRSxNQUFNYyxLQUFLLE1BQU1oQixTQUFTUSxNQUFNLENBQUNzRSxlQUFlLENBQUNEO1lBQ2pELHdEQUF3RDtZQUN4RHJDLGdCQUFnQnhDLFVBQVVnQjtZQUMxQixPQUFPQTtRQUNYO0lBQ0o7QUFDSjtBQUNBLFNBQVMrRCxhQUFhL0UsUUFBUSxFQUFFQyxRQUFRLEVBQUUrRCxjQUFjO0lBQ3BELElBQUkvRCxTQUFTK0UsUUFBUSxFQUFFO1FBQ25CLE9BQU9qQixVQUFVL0QsVUFBVUMsVUFBVStEO0lBQ3pDO0lBQ0EsT0FBT1ksVUFBVTVFLFVBQVVDO0FBQy9CO0FBQ0EsU0FBU2dGLFlBQVluRCxNQUFNO0lBQ3ZCLElBQUlBLE9BQU85QyxPQUFPLElBQUs4QyxDQUFBQSxPQUFPc0IsTUFBTSxJQUFJLFFBQVF0QixPQUFPc0IsTUFBTSxDQUFDaEQsTUFBTSxLQUFLLElBQUk7UUFDekUsT0FBTztJQUNYO0lBQ0EsT0FBTyxDQUFDMEIsT0FBTzlDLE9BQU8sSUFBSSxHQUFFLElBQUssTUFBTzhDLENBQUFBLE9BQU9zQixNQUFNLEdBQUd0QixPQUFPc0IsTUFBTSxDQUFDOUQsR0FBRyxDQUFDLENBQUM0RjtRQUN2RSxJQUFJL0YsTUFBTUMsT0FBTyxDQUFDOEYsUUFBUTtZQUN0QixPQUFPQSxNQUFNL0MsSUFBSSxDQUFDO1FBQ3RCO1FBQ0EsT0FBTytDO0lBQ1gsR0FBRy9DLElBQUksQ0FBQyxPQUFPLEVBQUM7QUFDcEI7QUFDQSxNQUFNZ0Q7SUFDRkMsWUFBWUMsR0FBRyxFQUFFdkQsTUFBTSxDQUFFO1FBQ3JCL0UseUVBQWNBLENBQUMsSUFBSSxFQUFFLE9BQU9zSTtRQUM1QnRJLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVK0U7UUFDL0IsSUFBSSxDQUFDd0QsVUFBVSxHQUFHLEVBQUU7SUFDeEI7SUFDQUMsWUFBWUMsUUFBUSxFQUFFQyxJQUFJLEVBQUU7UUFDeEIsSUFBSSxDQUFDSCxVQUFVLENBQUNuQixJQUFJLENBQUM7WUFBRXFCLFVBQVVBO1lBQVVDLE1BQU1BO1FBQUs7SUFDMUQ7SUFDQWhDLGVBQWUrQixRQUFRLEVBQUU7UUFDckIsSUFBSTFKLE9BQU87UUFDWCxJQUFJLENBQUN3SixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUN4RCxNQUFNLENBQUMsQ0FBQzREO1lBQ3RDLElBQUk1SixRQUFRNEosS0FBS0YsUUFBUSxLQUFLQSxVQUFVO2dCQUNwQyxPQUFPO1lBQ1g7WUFDQTFKLE9BQU87WUFDUCxPQUFPO1FBQ1g7SUFDSjtJQUNBNkoscUJBQXFCO1FBQ2pCLElBQUksQ0FBQ0wsVUFBVSxHQUFHLEVBQUU7SUFDeEI7SUFDQU0sWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDTixVQUFVLENBQUNoRyxHQUFHLENBQUMsQ0FBQ2dDLElBQU1BLEVBQUVrRSxRQUFRO0lBQ2hEO0lBQ0FLLGdCQUFnQjtRQUNaLE9BQU8sSUFBSSxDQUFDUCxVQUFVLENBQUNsRixNQUFNO0lBQ2pDO0lBQ0EwRixJQUFJNUYsSUFBSSxFQUFFO1FBQ04sTUFBTTJGLGdCQUFnQixJQUFJLENBQUNBLGFBQWE7UUFDeEMsSUFBSSxDQUFDUCxVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUN4RCxNQUFNLENBQUMsQ0FBQzREO1lBQ3RDLE1BQU1LLFdBQVc3RixLQUFLOEYsS0FBSztZQUMzQiwyQ0FBMkM7WUFDM0NDLFdBQVc7Z0JBQ1BQLEtBQUtGLFFBQVEsQ0FBQ3hKLEtBQUssQ0FBQyxJQUFJLEVBQUUrSjtZQUM5QixHQUFHO1lBQ0gsaUNBQWlDO1lBQ2pDLE9BQU8sQ0FBRUwsS0FBS0QsSUFBSTtRQUN0QjtRQUNBLE9BQU9JO0lBQ1g7SUFDQUssYUFBYWxELEtBQUssRUFBRSxDQUNwQjtJQUNBLG9EQUFvRDtJQUNwRG1ELFFBQVFuRCxLQUFLLEVBQUU7UUFDWCxPQUFPO1lBQUNBO1NBQU07SUFDbEI7QUFDSjtBQUNBLE1BQU1vRCwwQkFBMEJqQjtJQUM1QkMsYUFBYztRQUNWLEtBQUssQ0FBQyxTQUFTO0lBQ25CO0FBQ0o7QUFDQSxxRUFBcUU7QUFDckUsdUVBQXVFO0FBQ3ZFLG1DQUFtQztBQUNuQyxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQ2pFLE1BQU1pQiw2QkFBNkJsQjtJQUMvQkMsWUFBWXBHLE9BQU8sRUFBRXNILGlCQUFpQixFQUFFckcsUUFBUSxFQUFFbUQsTUFBTSxDQUFFO1FBQ3RELE1BQU10QixTQUFTO1lBQ1g5QyxTQUFTQTtRQUNiO1FBQ0EsSUFBSWtHLFFBQVFvQixrQkFBa0JDLGFBQWEsQ0FBQ3RHO1FBQzVDLElBQUltRCxRQUFRO1lBQ1IsSUFBSThCLFVBQVU5QixNQUFNLENBQUMsRUFBRSxFQUFFO2dCQUNyQjdGLE9BQU9tQixrQkFBa0IsQ0FBQyxrQkFBa0IsVUFBVTBFO1lBQzFEO1lBQ0F0QixPQUFPc0IsTUFBTSxHQUFHQSxPQUFPNEMsS0FBSztRQUNoQyxPQUNLO1lBQ0RsRSxPQUFPc0IsTUFBTSxHQUFHO2dCQUFDOEI7YUFBTTtRQUMzQjtRQUNBLEtBQUssQ0FBQ0QsWUFBWW5ELFNBQVNBO1FBQzNCL0UseUVBQWNBLENBQUMsSUFBSSxFQUFFLFdBQVdpQztRQUNoQ2pDLHlFQUFjQSxDQUFDLElBQUksRUFBRSxhQUFhdUo7UUFDbEN2Six5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWWtEO0lBQ3JDO0lBQ0FpRyxhQUFhbEQsS0FBSyxFQUFFO1FBQ2hCLEtBQUssQ0FBQ2tELGFBQWFsRDtRQUNuQkEsTUFBTUEsS0FBSyxHQUFHLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ3hCLElBQUk7UUFDaEN1RSxNQUFNTyxjQUFjLEdBQUcsSUFBSSxDQUFDdEQsUUFBUSxDQUFDdUcsTUFBTTtRQUMzQ3hELE1BQU1HLE1BQU0sR0FBRyxDQUFDekYsTUFBTTBGO1lBQ2xCLE9BQU8sSUFBSSxDQUFDdEMsU0FBUyxDQUFDdUMsY0FBYyxDQUFDLElBQUksQ0FBQ3BELFFBQVEsRUFBRXZDLE1BQU0wRjtRQUM5RDtRQUNBLElBQUk7WUFDQUosTUFBTTlDLElBQUksR0FBRyxJQUFJLENBQUNZLFNBQVMsQ0FBQ3VDLGNBQWMsQ0FBQyxJQUFJLENBQUNwRCxRQUFRLEVBQUUrQyxNQUFNdEYsSUFBSSxFQUFFc0YsTUFBTUksTUFBTTtRQUN0RixFQUNBLE9BQU96RSxPQUFPO1lBQ1ZxRSxNQUFNOUMsSUFBSSxHQUFHO1lBQ2I4QyxNQUFNeUQsV0FBVyxHQUFHOUg7UUFDeEI7SUFDSjtJQUNBd0gsUUFBUW5ELEtBQUssRUFBRTtRQUNYLE1BQU1uRSxTQUFTNUMscUVBQWlCQSxDQUFDK0csTUFBTTlDLElBQUk7UUFDM0MsSUFBSXJCLE9BQU91QixNQUFNLEVBQUU7WUFDZixNQUFNdkIsTUFBTSxDQUFDLEVBQUUsQ0FBQ0YsS0FBSztRQUN6QjtRQUNBLE1BQU11QixPQUFPLENBQUM4QyxNQUFNOUMsSUFBSSxJQUFJLEVBQUUsRUFBRThGLEtBQUs7UUFDckM5RixLQUFLaUUsSUFBSSxDQUFDbkI7UUFDVixPQUFPOUM7SUFDWDtBQUNKO0FBQ0EsNkNBQTZDO0FBQzdDLGlEQUFpRDtBQUNqRCxzREFBc0Q7QUFDdEQsMkRBQTJEO0FBQzNELGtEQUFrRDtBQUNsRCxNQUFNd0csNkJBQTZCdkI7SUFDL0JDLFlBQVlwRyxPQUFPLEVBQUVzSCxpQkFBaUIsQ0FBRTtRQUNwQyxLQUFLLENBQUMsS0FBSztZQUFFdEgsU0FBU0E7UUFBUTtRQUM5QmpDLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXaUM7UUFDaENqQyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsYUFBYXVKO0lBQ3RDO0lBQ0FKLGFBQWFsRCxLQUFLLEVBQUU7UUFDaEIsS0FBSyxDQUFDa0QsYUFBYWxEO1FBQ25CLElBQUk7WUFDQSxNQUFNQyxTQUFTLElBQUksQ0FBQ25DLFNBQVMsQ0FBQ29DLFFBQVEsQ0FBQ0Y7WUFDdkNBLE1BQU1BLEtBQUssR0FBR0MsT0FBT3hFLElBQUk7WUFDekJ1RSxNQUFNTyxjQUFjLEdBQUdOLE9BQU9PLFNBQVM7WUFDdkNSLE1BQU1HLE1BQU0sR0FBRyxDQUFDekYsTUFBTTBGO2dCQUNsQixPQUFPLElBQUksQ0FBQ3RDLFNBQVMsQ0FBQ3VDLGNBQWMsQ0FBQ0osT0FBT0ssYUFBYSxFQUFFNUYsTUFBTTBGO1lBQ3JFO1lBQ0FKLE1BQU05QyxJQUFJLEdBQUcrQyxPQUFPL0MsSUFBSTtRQUM1QixFQUNBLE9BQU92QixPQUFPO1FBQ1Ysb0JBQW9CO1FBQ3hCO0lBQ0o7QUFDSjtBQUNPLE1BQU1nSTtJQUNUdkIsWUFBWXdCLGFBQWEsRUFBRU4saUJBQWlCLEVBQUVoRSxnQkFBZ0IsQ0FBRTtRQUM1RCxpRkFBaUY7UUFDakYsZ0NBQWdDO1FBQ2hDdkYseUVBQWNBLENBQUMsSUFBSSxFQUFFLGFBQWFFLG9FQUFTQSxDQUFDLFlBQVksZ0JBQWdCcUo7UUFDeEUsSUFBSWhFLG9CQUFvQixNQUFNO1lBQzFCdkYseUVBQWNBLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDakNBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVO1FBQ25DLE9BQ0ssSUFBSVYsa0VBQU1BLENBQUN3SyxRQUFRLENBQUN2RSxtQkFBbUI7WUFDeEN2Rix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWXVGLGlCQUFpQjNCLFFBQVEsSUFBSTtZQUM5RDVELHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVdUY7UUFDbkMsT0FDSyxJQUFJbEcsc0VBQVFBLENBQUMwSyxVQUFVLENBQUN4RSxtQkFBbUI7WUFDNUN2Rix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWXVGO1lBQ2pDdkYseUVBQWNBLENBQUMsSUFBSSxFQUFFLFVBQVU7UUFDbkMsT0FDSztZQUNEUSxPQUFPbUIsa0JBQWtCLENBQUMsOEJBQThCLG9CQUFvQjREO1FBQ2hGO1FBQ0F2Rix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDO1FBQ3BDQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDO1FBQ3JDQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDO1FBQ25DQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLENBQUM7UUFDN0NBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUM7UUFDakM7WUFDSSxNQUFNZ0ssZ0JBQWdCLENBQUM7WUFDdkJuRixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLENBQUMrQixNQUFNLEVBQUVtRSxPQUFPLENBQUMsQ0FBQ3pEO2dCQUN4QyxNQUFNUCxRQUFRLElBQUksQ0FBQ2xDLFNBQVMsQ0FBQytCLE1BQU0sQ0FBQ1UsZUFBZTtnQkFDbkR4Ryx5RUFBY0EsQ0FBQyxJQUFJLENBQUNrSyxPQUFPLEVBQUUxRCxnQkFBZ0IsQ0FBQyxHQUFHckQ7b0JBQzdDLE9BQU87d0JBQ0hsQixTQUFTLElBQUksQ0FBQ0EsT0FBTzt3QkFDckJvRSxRQUFRLElBQUksQ0FBQ3RDLFNBQVMsQ0FBQ29HLGtCQUFrQixDQUFDbEUsT0FBTzlDO29CQUNyRDtnQkFDSjtnQkFDQSxJQUFJLENBQUM2RyxhQUFhLENBQUMvRCxNQUFNdkUsSUFBSSxDQUFDLEVBQUU7b0JBQzVCc0ksYUFBYSxDQUFDL0QsTUFBTXZFLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ2xDO2dCQUNBc0ksYUFBYSxDQUFDL0QsTUFBTXZFLElBQUksQ0FBQyxDQUFDMEYsSUFBSSxDQUFDWjtZQUNuQztZQUNBM0IsT0FBT0MsSUFBSSxDQUFDa0YsZUFBZUMsT0FBTyxDQUFDLENBQUN2STtnQkFDaEMsTUFBTXdJLFVBQVVGLGFBQWEsQ0FBQ3RJLEtBQUs7Z0JBQ25DLElBQUl3SSxRQUFRN0csTUFBTSxLQUFLLEdBQUc7b0JBQ3RCckQseUVBQWNBLENBQUMsSUFBSSxDQUFDa0ssT0FBTyxFQUFFeEksTUFBTSxJQUFJLENBQUN3SSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxFQUFFLENBQUM7Z0JBQy9ELE9BQ0s7b0JBQ0QxSixPQUFPNEosSUFBSSxDQUFDLENBQUMsd0JBQXdCLEVBQUUxSSxLQUFLLEVBQUUsRUFBRXdJLFFBQVE5RSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3pFO1lBQ0o7UUFDSjtRQUNBcEYseUVBQWNBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDO1FBQ3hDQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLENBQUM7UUFDdkMsSUFBSTZKLGlCQUFpQixNQUFNO1lBQ3ZCckosT0FBT21CLGtCQUFrQixDQUFDLHdDQUF3QyxpQkFBaUJrSTtRQUN2RjtRQUNBN0oseUVBQWNBLENBQUMsSUFBSSxFQUFFLFdBQVc2SjtRQUNoQyxJQUFJLElBQUksQ0FBQ2pHLFFBQVEsRUFBRTtZQUNmNUQseUVBQWNBLENBQUMsSUFBSSxFQUFFLG1CQUFtQnVCLFlBQVksSUFBSSxDQUFDcUMsUUFBUSxFQUFFaUc7UUFDdkUsT0FDSztZQUNELElBQUk7Z0JBQ0E3Six5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsbUJBQW1CekIsUUFBUUQsT0FBTyxDQUFDa0Isa0VBQVVBLENBQUNxSztZQUN2RSxFQUNBLE9BQU9qSSxPQUFPO2dCQUNWLDhDQUE4QztnQkFDOUNwQixPQUFPcUIsVUFBVSxDQUFDLDREQUE0RHZCLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtvQkFDL0dDLFdBQVc7Z0JBQ2Y7WUFDSjtRQUNKO1FBQ0Esd0RBQXdEO1FBQ3hELElBQUksQ0FBQzhCLGVBQWUsQ0FBQ3VHLEtBQUssQ0FBQyxDQUFDekwsS0FBUTtRQUNwQyxNQUFNMEwsY0FBYyxDQUFDO1FBQ3JCLE1BQU1DLG1CQUFtQixDQUFDO1FBQzFCMUYsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ2YsU0FBUyxDQUFDeUcsU0FBUyxFQUFFUCxPQUFPLENBQUMsQ0FBQ3hEO1lBQzNDLE1BQU12RCxXQUFXLElBQUksQ0FBQ2EsU0FBUyxDQUFDeUcsU0FBUyxDQUFDL0QsVUFBVTtZQUNwRCxvRUFBb0U7WUFDcEUsbURBQW1EO1lBQ25ELElBQUk4RCxnQkFBZ0IsQ0FBQzlELFVBQVUsRUFBRTtnQkFDN0JqRyxPQUFPNEosSUFBSSxDQUFDLENBQUMsd0JBQXdCLEVBQUVsRixLQUFLQyxTQUFTLENBQUNzQixXQUFXLENBQUM7Z0JBQ2xFO1lBQ0o7WUFDQThELGdCQUFnQixDQUFDOUQsVUFBVSxHQUFHO1lBQzlCLGtFQUFrRTtZQUNsRSxnQkFBZ0I7WUFDaEI7Z0JBQ0ksTUFBTS9FLE9BQU93QixTQUFTeEIsSUFBSTtnQkFDMUIsSUFBSSxDQUFDNEksV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFNUksS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDMUI0SSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUU1SSxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2hDO2dCQUNBNEksV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFNUksS0FBSyxDQUFDLENBQUMsQ0FBQzBGLElBQUksQ0FBQ1g7WUFDakM7WUFDQSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxJQUFJLE1BQU07Z0JBQ3pCekcseUVBQWNBLENBQUMsSUFBSSxFQUFFeUcsV0FBV3VCLGFBQWEsSUFBSSxFQUFFOUUsVUFBVTtZQUNqRTtZQUNBLCtEQUErRDtZQUMvRCxpRUFBaUU7WUFDakUsa0NBQWtDO1lBQ2xDLElBQUksSUFBSSxDQUFDc0gsU0FBUyxDQUFDL0QsVUFBVSxJQUFJLE1BQU07Z0JBQ25DekcseUVBQWNBLENBQUMsSUFBSSxDQUFDd0ssU0FBUyxFQUFFL0QsV0FBV3VCLGFBQWEsSUFBSSxFQUFFOUUsVUFBVTtZQUMzRTtZQUNBLElBQUksSUFBSSxDQUFDdUgsVUFBVSxDQUFDaEUsVUFBVSxJQUFJLE1BQU07Z0JBQ3BDekcseUVBQWNBLENBQUMsSUFBSSxDQUFDeUssVUFBVSxFQUFFaEUsV0FBV08sVUFBVSxJQUFJLEVBQUU5RCxVQUFVO1lBQ3pFO1lBQ0EsSUFBSSxJQUFJLENBQUNGLG1CQUFtQixDQUFDeUQsVUFBVSxJQUFJLE1BQU07Z0JBQzdDekcseUVBQWNBLENBQUMsSUFBSSxDQUFDZ0QsbUJBQW1CLEVBQUV5RCxXQUFXcEIsY0FBYyxJQUFJLEVBQUVuQztZQUM1RTtZQUNBLElBQUksSUFBSSxDQUFDc0MsV0FBVyxDQUFDaUIsVUFBVSxJQUFJLE1BQU07Z0JBQ3JDekcseUVBQWNBLENBQUMsSUFBSSxDQUFDd0YsV0FBVyxFQUFFaUIsV0FBV25CLGNBQWMsSUFBSSxFQUFFcEM7WUFDcEU7UUFDSjtRQUNBMkIsT0FBT0MsSUFBSSxDQUFDd0YsYUFBYUwsT0FBTyxDQUFDLENBQUN2STtZQUM5QixvREFBb0Q7WUFDcEQsTUFBTWdKLGFBQWFKLFdBQVcsQ0FBQzVJLEtBQUs7WUFDcEMsSUFBSWdKLFdBQVdySCxNQUFNLEdBQUcsR0FBRztnQkFDdkI7WUFDSjtZQUNBLDBEQUEwRDtZQUMxRDNCLE9BQU9BLEtBQUtpSixTQUFTLENBQUM7WUFDdEIsTUFBTWxFLFlBQVlpRSxVQUFVLENBQUMsRUFBRTtZQUMvQixtRUFBbUU7WUFDbkUsSUFBSTtnQkFDQSxJQUFJLElBQUksQ0FBQ2hKLEtBQUssSUFBSSxNQUFNO29CQUNwQjFCLHlFQUFjQSxDQUFDLElBQUksRUFBRTBCLE1BQU0sSUFBSSxDQUFDK0UsVUFBVTtnQkFDOUM7WUFDSixFQUNBLE9BQU83SCxHQUFHLENBQUU7WUFDWixJQUFJLElBQUksQ0FBQzRMLFNBQVMsQ0FBQzlJLEtBQUssSUFBSSxNQUFNO2dCQUM5QjFCLHlFQUFjQSxDQUFDLElBQUksQ0FBQ3dLLFNBQVMsRUFBRTlJLE1BQU0sSUFBSSxDQUFDOEksU0FBUyxDQUFDL0QsVUFBVTtZQUNsRTtZQUNBLElBQUksSUFBSSxDQUFDZ0UsVUFBVSxDQUFDL0ksS0FBSyxJQUFJLE1BQU07Z0JBQy9CMUIseUVBQWNBLENBQUMsSUFBSSxDQUFDeUssVUFBVSxFQUFFL0ksTUFBTSxJQUFJLENBQUMrSSxVQUFVLENBQUNoRSxVQUFVO1lBQ3BFO1lBQ0EsSUFBSSxJQUFJLENBQUN6RCxtQkFBbUIsQ0FBQ3RCLEtBQUssSUFBSSxNQUFNO2dCQUN4QzFCLHlFQUFjQSxDQUFDLElBQUksQ0FBQ2dELG1CQUFtQixFQUFFdEIsTUFBTSxJQUFJLENBQUNzQixtQkFBbUIsQ0FBQ3lELFVBQVU7WUFDdEY7WUFDQSxJQUFJLElBQUksQ0FBQ2pCLFdBQVcsQ0FBQzlELEtBQUssSUFBSSxNQUFNO2dCQUNoQzFCLHlFQUFjQSxDQUFDLElBQUksQ0FBQ3dGLFdBQVcsRUFBRTlELE1BQU0sSUFBSSxDQUFDOEQsV0FBVyxDQUFDaUIsVUFBVTtZQUN0RTtRQUNKO0lBQ0o7SUFDQSxPQUFPaEgsbUJBQW1CbUksV0FBVyxFQUFFO1FBQ25DLE9BQU9uSSwwRUFBa0JBLENBQUNtSTtJQUM5QjtJQUNBLE9BQU9nRCxhQUFhckIsaUJBQWlCLEVBQUU7UUFDbkMsSUFBSW5LLDBEQUFTQSxDQUFDeUwsV0FBVyxDQUFDdEIsb0JBQW9CO1lBQzFDLE9BQU9BO1FBQ1g7UUFDQSxPQUFPLElBQUluSywwREFBU0EsQ0FBQ21LO0lBQ3pCO0lBQ0Esd0JBQXdCO0lBQ3hCdUIsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDeEQsU0FBUztJQUN6QjtJQUNBQSxVQUFVSixRQUFRLEVBQUU7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQzZELGdCQUFnQixFQUFFO1lBQ3hCLHVFQUF1RTtZQUN2RSxJQUFJLElBQUksQ0FBQzFELGlCQUFpQixFQUFFO2dCQUN4QixJQUFJLENBQUMwRCxnQkFBZ0IsR0FBRyxJQUFJLENBQUMxRCxpQkFBaUIsQ0FBQzNCLElBQUksR0FBRzFHLElBQUksQ0FBQztvQkFDdkQsT0FBTyxJQUFJO2dCQUNmO1lBQ0osT0FDSztnQkFDRCwrREFBK0Q7Z0JBQy9ELHFDQUFxQztnQkFDckMsOENBQThDO2dCQUM5QyxJQUFJLENBQUMrTCxnQkFBZ0IsR0FBRyxJQUFJLENBQUNuSCxRQUFRLENBQUNvSCxPQUFPLENBQUMsSUFBSSxDQUFDL0ksT0FBTyxFQUFFaUYsVUFBVWxJLElBQUksQ0FBQyxDQUFDMEk7b0JBQ3hFLElBQUlBLFNBQVMsTUFBTTt3QkFDZmxILE9BQU9xQixVQUFVLENBQUMseUJBQXlCdkIseURBQU1BLENBQUN3QixNQUFNLENBQUNDLHFCQUFxQixFQUFFOzRCQUM1RWtKLGlCQUFpQixJQUFJLENBQUNoSixPQUFPOzRCQUM3QkQsV0FBVzt3QkFDZjtvQkFDSjtvQkFDQSxPQUFPLElBQUk7Z0JBQ2Y7WUFDSjtRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUMrSSxnQkFBZ0I7SUFDaEM7SUFDQSxTQUFTO0lBQ1QsdUVBQXVFO0lBQ3ZFLFNBQVM7SUFDVCxnRUFBZ0U7SUFDaEVHLFNBQVM5SCxTQUFTLEVBQUU7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ0ssTUFBTSxFQUFFO1lBQ2RqRCxPQUFPcUIsVUFBVSxDQUFDLDJDQUEyQ3ZCLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtnQkFBRUMsV0FBVztZQUE0QjtRQUMvSTtRQUNBLE1BQU1pQyxLQUFLN0Qsc0VBQVdBLENBQUNnRCxhQUFhLENBQUM7UUFDckM7WUFBQztZQUFRO1NBQUssQ0FBQzZHLE9BQU8sQ0FBQyxTQUFVakYsR0FBRztZQUNoQyxJQUFJZixFQUFFLENBQUNlLElBQUksSUFBSSxNQUFNO2dCQUNqQjtZQUNKO1lBQ0F4RSxPQUFPcUIsVUFBVSxDQUFDLHFCQUFxQm1ELEtBQUsxRSx5REFBTUEsQ0FBQ3dCLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7Z0JBQUVDLFdBQVdnRDtZQUFJO1FBQ3RHO1FBQ0FmLEdBQUdqRCxFQUFFLEdBQUcsSUFBSSxDQUFDOEMsZUFBZTtRQUM1QixPQUFPLElBQUksQ0FBQ2dILFFBQVEsR0FBRzlMLElBQUksQ0FBQztZQUN4QixPQUFPLElBQUksQ0FBQ3lFLE1BQU0sQ0FBQ3NFLGVBQWUsQ0FBQzlEO1FBQ3ZDO0lBQ0o7SUFDQSw4Q0FBOEM7SUFDOUNrSCxRQUFRNUYsZ0JBQWdCLEVBQUU7UUFDdEIsSUFBSSxPQUFRQSxxQkFBc0IsVUFBVTtZQUN4Q0EsbUJBQW1CLElBQUloRyxzRUFBVUEsQ0FBQ2dHLGtCQUFrQixJQUFJLENBQUMzQixRQUFRO1FBQ3JFO1FBQ0EsTUFBTVgsV0FBVyxJQUFLLElBQUksQ0FBQ29GLFdBQVcsQ0FBRSxJQUFJLENBQUNwRyxPQUFPLEVBQUUsSUFBSSxDQUFDOEIsU0FBUyxFQUFFd0I7UUFDdEUsSUFBSSxJQUFJLENBQUM4QixpQkFBaUIsRUFBRTtZQUN4QnJILHlFQUFjQSxDQUFDaUQsVUFBVSxxQkFBcUIsSUFBSSxDQUFDb0UsaUJBQWlCO1FBQ3hFO1FBQ0EsT0FBT3BFO0lBQ1g7SUFDQSw4REFBOEQ7SUFDOURtSSxPQUFPdkIsYUFBYSxFQUFFO1FBQ2xCLE9BQU8sSUFBSyxJQUFJLENBQUN4QixXQUFXLENBQUV3QixlQUFlLElBQUksQ0FBQzlGLFNBQVMsRUFBRSxJQUFJLENBQUNOLE1BQU0sSUFBSSxJQUFJLENBQUNHLFFBQVE7SUFDN0Y7SUFDQSxPQUFPeUgsVUFBVWhOLEtBQUssRUFBRTtRQUNwQixPQUFPYyx3REFBT0EsQ0FBQ2tNLFNBQVMsQ0FBQ2hOO0lBQzdCO0lBQ0FpTix1QkFBdUJDLFlBQVksRUFBRTtRQUNqQyxtRUFBbUU7UUFDbkUsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0QsYUFBYWpELEdBQUcsQ0FBQyxFQUFFO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDa0QsY0FBYyxDQUFDRCxhQUFhakQsR0FBRyxDQUFDO1FBQ2hEO1FBQ0EsT0FBT2lEO0lBQ1g7SUFDQUUsaUJBQWlCQyxTQUFTLEVBQUU7UUFDeEIsSUFBSSxPQUFRQSxjQUFlLFVBQVU7WUFDakMsMEVBQTBFO1lBQzFFLDJEQUEyRDtZQUMzRCxJQUFJQSxjQUFjLFNBQVM7Z0JBQ3ZCLE9BQU8sSUFBSSxDQUFDSixzQkFBc0IsQ0FBQyxJQUFJakM7WUFDM0M7WUFDQSwwQ0FBMEM7WUFDMUMsSUFBSXFDLGNBQWMsU0FBUztnQkFDdkIsT0FBTyxJQUFJLENBQUNKLHNCQUFzQixDQUFDLElBQUlsRCxhQUFhLFNBQVM7WUFDakU7WUFDQSx1QkFBdUI7WUFDdkIsSUFBSXNELGNBQWMsS0FBSztnQkFDbkIsT0FBTyxJQUFJLENBQUNKLHNCQUFzQixDQUFDLElBQUkzQixxQkFBcUIsSUFBSSxDQUFDMUgsT0FBTyxFQUFFLElBQUksQ0FBQzhCLFNBQVM7WUFDNUY7WUFDQSw2REFBNkQ7WUFDN0QsTUFBTWIsV0FBVyxJQUFJLENBQUNhLFNBQVMsQ0FBQzRILFFBQVEsQ0FBQ0Q7WUFDekMsT0FBTyxJQUFJLENBQUNKLHNCQUFzQixDQUFDLElBQUloQyxxQkFBcUIsSUFBSSxDQUFDckgsT0FBTyxFQUFFLElBQUksQ0FBQzhCLFNBQVMsRUFBRWI7UUFDOUY7UUFDQSxpQ0FBaUM7UUFDakMsSUFBSXdJLFVBQVVyRixNQUFNLElBQUlxRixVQUFVckYsTUFBTSxDQUFDaEQsTUFBTSxHQUFHLEdBQUc7WUFDakQsNkRBQTZEO1lBQzdELElBQUk7Z0JBQ0EsTUFBTThFLFFBQVF1RCxVQUFVckYsTUFBTSxDQUFDLEVBQUU7Z0JBQ2pDLElBQUksT0FBUThCLFVBQVcsVUFBVTtvQkFDN0IsTUFBTSxJQUFJeUQsTUFBTSxrQkFBa0IseUNBQXlDO2dCQUMvRTtnQkFDQSxNQUFNMUksV0FBVyxJQUFJLENBQUNhLFNBQVMsQ0FBQzRILFFBQVEsQ0FBQ3hEO2dCQUN6QyxPQUFPLElBQUksQ0FBQ21ELHNCQUFzQixDQUFDLElBQUloQyxxQkFBcUIsSUFBSSxDQUFDckgsT0FBTyxFQUFFLElBQUksQ0FBQzhCLFNBQVMsRUFBRWIsVUFBVXdJLFVBQVVyRixNQUFNO1lBQ3hILEVBQ0EsT0FBT3pFLE9BQU8sQ0FBRTtZQUNoQixrQ0FBa0M7WUFDbEMsTUFBTW1ELFNBQVM7Z0JBQ1g5QyxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJvRSxRQUFRcUYsVUFBVXJGLE1BQU07WUFDNUI7WUFDQSxPQUFPLElBQUksQ0FBQ2lGLHNCQUFzQixDQUFDLElBQUlsRCxhQUFhRixZQUFZbkQsU0FBU0E7UUFDN0U7UUFDQSxPQUFPLElBQUksQ0FBQ3VHLHNCQUFzQixDQUFDLElBQUkzQixxQkFBcUIsSUFBSSxDQUFDMUgsT0FBTyxFQUFFLElBQUksQ0FBQzhCLFNBQVM7SUFDNUY7SUFDQThILG9CQUFvQk4sWUFBWSxFQUFFO1FBQzlCLElBQUlBLGFBQWF6QyxhQUFhLE9BQU8sR0FBRztZQUNwQyxPQUFPLElBQUksQ0FBQzBDLGNBQWMsQ0FBQ0QsYUFBYWpELEdBQUcsQ0FBQztZQUM1QywwQ0FBMEM7WUFDMUMsTUFBTXdELE9BQU8sSUFBSSxDQUFDQyxhQUFhLENBQUNSLGFBQWFqRCxHQUFHLENBQUM7WUFDakQsSUFBSXdELFFBQVFQLGFBQWF4RyxNQUFNLEVBQUU7Z0JBQzdCLElBQUksQ0FBQ25CLFFBQVEsQ0FBQ29JLEdBQUcsQ0FBQ1QsYUFBYXhHLE1BQU0sRUFBRStHO2dCQUN2QyxPQUFPLElBQUksQ0FBQ0MsYUFBYSxDQUFDUixhQUFhakQsR0FBRyxDQUFDO1lBQy9DO1FBQ0o7SUFDSjtJQUNBLHFEQUFxRDtJQUNyRCxpQ0FBaUM7SUFDakMyRCxXQUFXVixZQUFZLEVBQUV2RixHQUFHLEVBQUV5QyxRQUFRLEVBQUU7UUFDcEMsTUFBTXhDLFFBQVFoRyxtRUFBUUEsQ0FBQytGO1FBQ3ZCQyxNQUFNUyxjQUFjLEdBQUc7WUFDbkIsSUFBSSxDQUFDK0IsVUFBVTtnQkFDWDtZQUNKO1lBQ0E4QyxhQUFhN0UsY0FBYyxDQUFDK0I7WUFDNUIsSUFBSSxDQUFDb0QsbUJBQW1CLENBQUNOO1FBQzdCO1FBQ0F0RixNQUFNVSxRQUFRLEdBQUc7WUFBUSxPQUFPLElBQUksQ0FBQy9DLFFBQVEsQ0FBQytDLFFBQVEsQ0FBQ1gsSUFBSVksU0FBUztRQUFHO1FBQ3ZFWCxNQUFNWSxjQUFjLEdBQUc7WUFBUSxPQUFPLElBQUksQ0FBQ2pELFFBQVEsQ0FBQ2lELGNBQWMsQ0FBQ2IsSUFBSWMsZUFBZTtRQUFHO1FBQ3pGYixNQUFNYyxxQkFBcUIsR0FBRztZQUFRLE9BQU8sSUFBSSxDQUFDbkQsUUFBUSxDQUFDbUQscUJBQXFCLENBQUNmLElBQUljLGVBQWU7UUFBRztRQUN2RywrREFBK0Q7UUFDL0R5RSxhQUFhcEMsWUFBWSxDQUFDbEQ7UUFDMUIsT0FBT0E7SUFDWDtJQUNBaUcsa0JBQWtCWCxZQUFZLEVBQUU5QyxRQUFRLEVBQUVDLElBQUksRUFBRTtRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDOUUsUUFBUSxFQUFFO1lBQ2hCcEQsT0FBT3FCLFVBQVUsQ0FBQyx5REFBeUR2Qix5REFBTUEsQ0FBQ3dCLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7Z0JBQUVDLFdBQVc7WUFBTztRQUN4STtRQUNBdUosYUFBYS9DLFdBQVcsQ0FBQ0MsVUFBVUM7UUFDbkMsNkZBQTZGO1FBQzdGLElBQUksQ0FBQzhDLGNBQWMsQ0FBQ0QsYUFBYWpELEdBQUcsQ0FBQyxHQUFHaUQ7UUFDeEMsb0RBQW9EO1FBQ3BELElBQUksQ0FBQyxJQUFJLENBQUNRLGFBQWEsQ0FBQ1IsYUFBYWpELEdBQUcsQ0FBQyxFQUFFO1lBQ3ZDLE1BQU02RCxjQUFjLENBQUNuRztnQkFDakIsSUFBSUMsUUFBUSxJQUFJLENBQUNnRyxVQUFVLENBQUNWLGNBQWN2RixLQUFLeUM7Z0JBQy9DLHdEQUF3RDtnQkFDeEQsSUFBSXhDLE1BQU15RCxXQUFXLElBQUksTUFBTTtvQkFDM0IsSUFBSTt3QkFDQSxNQUFNdkcsT0FBT29JLGFBQWFuQyxPQUFPLENBQUNuRDt3QkFDbEMsSUFBSSxDQUFDNkYsSUFBSSxDQUFDUCxhQUFheEcsTUFBTSxLQUFLNUI7b0JBQ3RDLEVBQ0EsT0FBT3ZCLE9BQU87d0JBQ1ZxRSxNQUFNeUQsV0FBVyxHQUFHOUgsTUFBTUEsS0FBSztvQkFDbkM7Z0JBQ0o7Z0JBQ0EsK0NBQStDO2dCQUMvQyxJQUFJMkosYUFBYXhHLE1BQU0sSUFBSSxNQUFNO29CQUM3QixJQUFJLENBQUMrRyxJQUFJLENBQUMsU0FBUzdGO2dCQUN2QjtnQkFDQSxxQ0FBcUM7Z0JBQ3JDLElBQUlBLE1BQU15RCxXQUFXLElBQUksTUFBTTtvQkFDM0IsSUFBSSxDQUFDb0MsSUFBSSxDQUFDLFNBQVM3RixNQUFNeUQsV0FBVyxFQUFFekQ7Z0JBQzFDO1lBQ0o7WUFDQSxJQUFJLENBQUM4RixhQUFhLENBQUNSLGFBQWFqRCxHQUFHLENBQUMsR0FBRzZEO1lBQ3ZDLG9EQUFvRDtZQUNwRCxJQUFJWixhQUFheEcsTUFBTSxJQUFJLE1BQU07Z0JBQzdCLElBQUksQ0FBQ25CLFFBQVEsQ0FBQ3dJLEVBQUUsQ0FBQ2IsYUFBYXhHLE1BQU0sRUFBRW9IO1lBQzFDO1FBQ0o7SUFDSjtJQUNBRSxZQUFZcEcsS0FBSyxFQUFFcUcsb0JBQW9CLEVBQUVDLE9BQU8sRUFBRTtRQUM5QyxNQUFNaEIsZUFBZSxJQUFJLENBQUNFLGdCQUFnQixDQUFDeEY7UUFDM0MsTUFBTWxCLFNBQVMzRSxzRUFBV0EsQ0FBQ21MLGFBQWF4RyxNQUFNO1FBQzlDLElBQUksT0FBUXVILHlCQUEwQixZQUFZdk0saUVBQVdBLENBQUN1TSxzQkFBc0IsS0FBSztZQUNyRixJQUFJQyxXQUFXLE1BQU07Z0JBQ2pCL0wsT0FBT21CLGtCQUFrQixDQUFDLHlDQUF5QyxXQUFXNEs7WUFDbEY7WUFDQXhILE9BQU82QixTQUFTLEdBQUcwRjtRQUN2QixPQUNLO1lBQ0R2SCxPQUFPeUgsU0FBUyxHQUFJLHdCQUF5QixPQUFRRix1QkFBdUI7WUFDNUV2SCxPQUFPd0gsT0FBTyxHQUFJLFdBQVksT0FBUUEsVUFBVTtRQUNwRDtRQUNBLE9BQU8sSUFBSSxDQUFDM0ksUUFBUSxDQUFDNkksT0FBTyxDQUFDMUgsUUFBUS9GLElBQUksQ0FBQyxDQUFDK0c7WUFDdkMsT0FBT0EsS0FBS3hELEdBQUcsQ0FBQyxDQUFDeUQsTUFBUSxJQUFJLENBQUNpRyxVQUFVLENBQUNWLGNBQWN2RixLQUFLO1FBQ2hFO0lBQ0o7SUFDQW9HLEdBQUduRyxLQUFLLEVBQUV3QyxRQUFRLEVBQUU7UUFDaEIsSUFBSSxDQUFDeUQsaUJBQWlCLENBQUMsSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ3hGLFFBQVF3QyxVQUFVO1FBQy9ELE9BQU8sSUFBSTtJQUNmO0lBQ0FDLEtBQUt6QyxLQUFLLEVBQUV3QyxRQUFRLEVBQUU7UUFDbEIsSUFBSSxDQUFDeUQsaUJBQWlCLENBQUMsSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ3hGLFFBQVF3QyxVQUFVO1FBQy9ELE9BQU8sSUFBSTtJQUNmO0lBQ0FxRCxLQUFLSixTQUFTLEVBQUUsR0FBR3ZJLElBQUksRUFBRTtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDUyxRQUFRLEVBQUU7WUFDaEIsT0FBTztRQUNYO1FBQ0EsTUFBTTJILGVBQWUsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ0M7UUFDM0MsTUFBTTVNLFNBQVV5TSxhQUFheEMsR0FBRyxDQUFDNUYsUUFBUTtRQUN6QyxrRUFBa0U7UUFDbEUsSUFBSSxDQUFDMEksbUJBQW1CLENBQUNOO1FBQ3pCLE9BQU96TTtJQUNYO0lBQ0FnSyxjQUFjNEMsU0FBUyxFQUFFO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUM5SCxRQUFRLEVBQUU7WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSThILGFBQWEsTUFBTTtZQUNuQixPQUFPN0csT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQzBHLGNBQWMsRUFBRWtCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPM0g7Z0JBQ25ELE9BQU8ySCxRQUFRLElBQUksQ0FBQ25CLGNBQWMsQ0FBQ3hHLElBQUksQ0FBQzhELGFBQWE7WUFDekQsR0FBRztRQUNQO1FBQ0EsT0FBTyxJQUFJLENBQUMyQyxnQkFBZ0IsQ0FBQ0MsV0FBVzVDLGFBQWE7SUFDekQ7SUFDQUQsVUFBVTZDLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDOUgsUUFBUSxFQUFFO1lBQ2hCLE9BQU8sRUFBRTtRQUNiO1FBQ0EsSUFBSThILGFBQWEsTUFBTTtZQUNuQixNQUFNNU0sU0FBUyxFQUFFO1lBQ2pCLElBQUssSUFBSXdKLE9BQU8sSUFBSSxDQUFDa0QsY0FBYyxDQUFFO2dCQUNqQyxJQUFJLENBQUNBLGNBQWMsQ0FBQ2xELElBQUksQ0FBQ08sU0FBUyxHQUFHb0IsT0FBTyxDQUFDLENBQUN4QjtvQkFDMUMzSixPQUFPc0ksSUFBSSxDQUFDcUI7Z0JBQ2hCO1lBQ0o7WUFDQSxPQUFPM0o7UUFDWDtRQUNBLE9BQU8sSUFBSSxDQUFDMk0sZ0JBQWdCLENBQUNDLFdBQVc3QyxTQUFTO0lBQ3JEO0lBQ0FELG1CQUFtQjhDLFNBQVMsRUFBRTtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDOUgsUUFBUSxFQUFFO1lBQ2hCLE9BQU8sSUFBSTtRQUNmO1FBQ0EsSUFBSThILGFBQWEsTUFBTTtZQUNuQixJQUFLLE1BQU1wRCxPQUFPLElBQUksQ0FBQ2tELGNBQWMsQ0FBRTtnQkFDbkMsTUFBTUQsZUFBZSxJQUFJLENBQUNDLGNBQWMsQ0FBQ2xELElBQUk7Z0JBQzdDaUQsYUFBYTNDLGtCQUFrQjtnQkFDL0IsSUFBSSxDQUFDaUQsbUJBQW1CLENBQUNOO1lBQzdCO1lBQ0EsT0FBTyxJQUFJO1FBQ2Y7UUFDQSx1QkFBdUI7UUFDdkIsTUFBTUEsZUFBZSxJQUFJLENBQUNFLGdCQUFnQixDQUFDQztRQUMzQ0gsYUFBYTNDLGtCQUFrQjtRQUMvQixJQUFJLENBQUNpRCxtQkFBbUIsQ0FBQ047UUFDekIsT0FBTyxJQUFJO0lBQ2Y7SUFDQVMsSUFBSU4sU0FBUyxFQUFFakQsUUFBUSxFQUFFO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUM3RSxRQUFRLEVBQUU7WUFDaEIsT0FBTyxJQUFJO1FBQ2Y7UUFDQSxNQUFNMkgsZUFBZSxJQUFJLENBQUNFLGdCQUFnQixDQUFDQztRQUMzQ0gsYUFBYTdFLGNBQWMsQ0FBQytCO1FBQzVCLElBQUksQ0FBQ29ELG1CQUFtQixDQUFDTjtRQUN6QixPQUFPLElBQUk7SUFDZjtJQUNBN0UsZUFBZWdGLFNBQVMsRUFBRWpELFFBQVEsRUFBRTtRQUNoQyxPQUFPLElBQUksQ0FBQ3VELEdBQUcsQ0FBQ04sV0FBV2pEO0lBQy9CO0FBQ0o7QUFDTyxNQUFNbUUsaUJBQWlCaEQ7QUFDOUI7QUFDTyxNQUFNaUQ7SUFDVHhFLFlBQVlrQixpQkFBaUIsRUFBRXVELFFBQVEsRUFBRXJKLE1BQU0sQ0FBRTtRQUM3QyxJQUFJc0osY0FBYztRQUNsQixJQUFJLE9BQVFELGFBQWMsVUFBVTtZQUNoQ0MsY0FBY0Q7UUFDbEIsT0FDSyxJQUFJaE4sNkRBQU9BLENBQUNnTixXQUFXO1lBQ3hCQyxjQUFjbE4sNkRBQU9BLENBQUNpTjtRQUMxQixPQUNLLElBQUlBLFlBQVksT0FBUUEsU0FBU0UsTUFBTSxLQUFNLFVBQVU7WUFDeEQsdURBQXVEO1lBQ3ZERCxjQUFjRCxTQUFTRSxNQUFNO1FBQ2pDLE9BQ0s7WUFDRCxzQ0FBc0M7WUFDdENELGNBQWM7UUFDbEI7UUFDQSw4QkFBOEI7UUFDOUIsSUFBSUEsWUFBWXBDLFNBQVMsQ0FBQyxHQUFHLE9BQU8sTUFBTTtZQUN0Q29DLGNBQWMsT0FBT0E7UUFDekI7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDaE4saUVBQVdBLENBQUNnTixnQkFBaUJBLFlBQVkxSixNQUFNLEdBQUcsR0FBSTtZQUN2RDdDLE9BQU9tQixrQkFBa0IsQ0FBQyxvQkFBb0IsWUFBWW1MO1FBQzlEO1FBQ0EsNkNBQTZDO1FBQzdDLElBQUlySixVQUFVLENBQUNuRSxrRUFBTUEsQ0FBQ3dLLFFBQVEsQ0FBQ3JHLFNBQVM7WUFDcENqRCxPQUFPbUIsa0JBQWtCLENBQUMsa0JBQWtCLFVBQVU4QjtRQUMxRDtRQUNBekQseUVBQWNBLENBQUMsSUFBSSxFQUFFLFlBQVkrTTtRQUNqQy9NLHlFQUFjQSxDQUFDLElBQUksRUFBRSxhQUFhRSxvRUFBU0EsQ0FBQyxZQUFZLGdCQUFnQnFKO1FBQ3hFdkoseUVBQWNBLENBQUMsSUFBSSxFQUFFLFVBQVV5RCxVQUFVO0lBQzdDO0lBQ0EsZ0RBQWdEO0lBQ2hEd0oscUJBQXFCLEdBQUc5SixJQUFJLEVBQUU7UUFDMUIsSUFBSWMsS0FBSyxDQUFDO1FBQ1YsbUVBQW1FO1FBQ25FLElBQUlkLEtBQUtFLE1BQU0sS0FBSyxJQUFJLENBQUNVLFNBQVMsQ0FBQ21KLE1BQU0sQ0FBQzVKLE1BQU0sQ0FBQ0QsTUFBTSxHQUFHLEtBQUssT0FBUUYsSUFBSSxDQUFDQSxLQUFLRSxNQUFNLEdBQUcsRUFBRSxLQUFNLFVBQVU7WUFDeEdZLEtBQUs3RCxzRUFBV0EsQ0FBQytDLEtBQUtJLEdBQUc7WUFDekIsSUFBSyxNQUFNeUIsT0FBT2YsR0FBSTtnQkFDbEIsSUFBSSxDQUFDeEQsc0JBQXNCLENBQUN1RSxJQUFJLEVBQUU7b0JBQzlCLE1BQU0sSUFBSTRHLE1BQU0sa0NBQWtDNUc7Z0JBQ3REO1lBQ0o7UUFDSjtRQUNBLGtFQUFrRTtRQUNsRTtZQUFDO1lBQVE7WUFBUTtTQUFLLENBQUNpRixPQUFPLENBQUMsQ0FBQ2pGO1lBQzVCLElBQUlmLEVBQUUsQ0FBQ2UsSUFBSSxJQUFJLE1BQU07Z0JBQ2pCO1lBQ0o7WUFDQXhFLE9BQU9xQixVQUFVLENBQUMscUJBQXFCbUQsS0FBSzFFLHlEQUFNQSxDQUFDd0IsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtnQkFBRUMsV0FBV2dEO1lBQUk7UUFDdEc7UUFDQSxJQUFJZixHQUFHNUYsS0FBSyxFQUFFO1lBQ1YsTUFBTUEsUUFBUXFCLCtEQUFTQSxDQUFDa0IsSUFBSSxDQUFDcUQsR0FBRzVGLEtBQUs7WUFDckMsSUFBSSxDQUFDQSxNQUFNcUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDWCxTQUFTLENBQUNtSixNQUFNLENBQUN2SSxPQUFPLEVBQUU7Z0JBQ25EbkUsT0FBT3FCLFVBQVUsQ0FBQyxpREFBaUR2Qix5REFBTUEsQ0FBQ3dCLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7b0JBQ3BHQyxXQUFXO29CQUNYM0QsT0FBTzRGLEdBQUc1RixLQUFLO2dCQUNuQjtZQUNKO1FBQ0o7UUFDQSx1REFBdUQ7UUFDdkRtQyxPQUFPZ0Qsa0JBQWtCLENBQUNMLEtBQUtFLE1BQU0sRUFBRSxJQUFJLENBQUNVLFNBQVMsQ0FBQ21KLE1BQU0sQ0FBQzVKLE1BQU0sQ0FBQ0QsTUFBTSxFQUFFO1FBQzVFLG1FQUFtRTtRQUNuRVksR0FBR3RELElBQUksR0FBR2QsNkRBQU9BLENBQUNELDREQUFNQSxDQUFDO1lBQ3JCLElBQUksQ0FBQ2tOLFFBQVE7WUFDYixJQUFJLENBQUMvSSxTQUFTLENBQUNvSixZQUFZLENBQUNoSztTQUMvQjtRQUNELE9BQU9jO0lBQ1g7SUFDQWlKLE9BQU8sR0FBRy9KLElBQUksRUFBRTtRQUNaLE9BQU9wRixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlxRixZQUFZLENBQUM7WUFDakIsNERBQTREO1lBQzVELElBQUlELEtBQUtFLE1BQU0sS0FBSyxJQUFJLENBQUNVLFNBQVMsQ0FBQ21KLE1BQU0sQ0FBQzVKLE1BQU0sQ0FBQ0QsTUFBTSxHQUFHLEdBQUc7Z0JBQ3pERCxZQUFZRCxLQUFLSSxHQUFHO1lBQ3hCO1lBQ0EsdURBQXVEO1lBQ3ZEL0MsT0FBT2dELGtCQUFrQixDQUFDTCxLQUFLRSxNQUFNLEVBQUUsSUFBSSxDQUFDVSxTQUFTLENBQUNtSixNQUFNLENBQUM1SixNQUFNLENBQUNELE1BQU0sRUFBRTtZQUM1RSxrREFBa0Q7WUFDbEQsTUFBTStKLFNBQVMsTUFBTWxMLGlCQUFpQixJQUFJLENBQUN1QixNQUFNLEVBQUVOLE1BQU0sSUFBSSxDQUFDWSxTQUFTLENBQUNtSixNQUFNLENBQUM1SixNQUFNO1lBQ3JGOEosT0FBT2hHLElBQUksQ0FBQ2hFO1lBQ1osMkRBQTJEO1lBQzNELE1BQU1pSyxhQUFhLElBQUksQ0FBQ0osb0JBQW9CLElBQUlHO1lBQ2hELGtDQUFrQztZQUNsQyxNQUFNbkosS0FBSyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDc0UsZUFBZSxDQUFDc0Y7WUFDN0MsTUFBTXBMLFVBQVUvQixvRUFBU0EsQ0FBQyxJQUFJLENBQUNtSSxXQUFXLEVBQUUsc0JBQXNCcEU7WUFDbEUsTUFBTWhCLFdBQVcvQyxvRUFBU0EsQ0FBQyxJQUFJLENBQUNtSSxXQUFXLEVBQUUsZUFBZXBHLFNBQVMsSUFBSSxDQUFDOEIsU0FBUyxFQUFFLElBQUksQ0FBQ04sTUFBTTtZQUNoRywwQ0FBMEM7WUFDMUNnQyxnQkFBZ0J4QyxVQUFVZ0I7WUFDMUJqRSx5RUFBY0EsQ0FBQ2lELFVBQVUscUJBQXFCZ0I7WUFDOUMsT0FBT2hCO1FBQ1g7SUFDSjtJQUNBbUksT0FBT25KLE9BQU8sRUFBRTtRQUNaLE9BQU8sSUFBSyxDQUFDb0csV0FBVyxDQUFFaUYsV0FBVyxDQUFDckwsU0FBUyxJQUFJLENBQUM4QixTQUFTLEVBQUUsSUFBSSxDQUFDTixNQUFNO0lBQzlFO0lBQ0EwSCxRQUFRMUgsTUFBTSxFQUFFO1FBQ1osT0FBTyxJQUFLLElBQUksQ0FBQzRFLFdBQVcsQ0FBRSxJQUFJLENBQUN0RSxTQUFTLEVBQUUsSUFBSSxDQUFDK0ksUUFBUSxFQUFFcko7SUFDakU7SUFDQSxPQUFPOEosYUFBYUMsY0FBYyxFQUFFL0osTUFBTSxFQUFFO1FBQ3hDLElBQUkrSixrQkFBa0IsTUFBTTtZQUN4QmhOLE9BQU9xQixVQUFVLENBQUMsMkJBQTJCdkIseURBQU1BLENBQUN3QixNQUFNLENBQUMyTCxnQkFBZ0IsRUFBRTtnQkFBRTVLLFVBQVU7WUFBaUI7UUFDOUc7UUFDQSxJQUFJLE9BQVEySyxtQkFBb0IsVUFBVTtZQUN0Q0EsaUJBQWlCdEksS0FBS3dJLEtBQUssQ0FBQ0Y7UUFDaEM7UUFDQSxNQUFNRyxNQUFNSCxlQUFlRyxHQUFHO1FBQzlCLElBQUliLFdBQVc7UUFDZixJQUFJVSxlQUFlVixRQUFRLEVBQUU7WUFDekJBLFdBQVdVLGVBQWVWLFFBQVE7UUFDdEMsT0FDSyxJQUFJVSxlQUFlSSxHQUFHLElBQUlKLGVBQWVJLEdBQUcsQ0FBQ2QsUUFBUSxFQUFFO1lBQ3hEQSxXQUFXVSxlQUFlSSxHQUFHLENBQUNkLFFBQVE7UUFDMUM7UUFDQSxPQUFPLElBQUksSUFBSSxDQUFDYSxLQUFLYixVQUFVcko7SUFDbkM7SUFDQSxPQUFPbUgsYUFBYXJCLGlCQUFpQixFQUFFO1FBQ25DLE9BQU9xRCxTQUFTaEMsWUFBWSxDQUFDckI7SUFDakM7SUFDQSxPQUFPOUosbUJBQW1Cd0UsRUFBRSxFQUFFO1FBQzFCLE9BQU94RSwwRUFBa0JBLENBQUN3RTtJQUM5QjtJQUNBLE9BQU9xSixZQUFZckwsT0FBTyxFQUFFc0gsaUJBQWlCLEVBQUU5RixNQUFNLEVBQUU7UUFDbkQsT0FBTyxJQUFJbUosU0FBUzNLLFNBQVNzSCxtQkFBbUI5RjtJQUNwRDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtjb250cmFjdHNANS44LjAvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL2luZGV4LmpzPzRhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJpXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU2lnbmVyLCBWb2lkU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZGVlcENvcHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsXG4gICAgY3VzdG9tRGF0YTogdHJ1ZSxcbiAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWVcbn07XG5mdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlciwgbmFtZU9yUHJvbWlzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB5aWVsZCBuYW1lT3JQcm9taXNlO1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBqdXN0IHVzZSBpdCAoYWZ0ZXIgYWRkaW5nIGNoZWNrc3VtKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJhIHByb3ZpZGVyIG9yIHNpZ25lciBpcyBuZWVkZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXNcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHJlc29sdmVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicmVzb2x2ZXIgb3IgYWRkciBpcyBub3QgY29uZmlndXJlZCBmb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH0pO1xufVxuLy8gUmVjdXJzaXZlbHkgcmVwbGFjZXMgRU5TIG5hbWVzIHdpdGggcHJvbWlzZXMgdG8gcmVzb2x2ZSB0aGUgbmFtZSBhbmQgcmVzb2x2ZXMgYWxsIHByb3BlcnRpZXNcbmZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwocGFyYW1UeXBlLm1hcCgocGFyYW1UeXBlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCAoKEFycmF5LmlzQXJyYXkodmFsdWUpKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlW3BhcmFtVHlwZS5uYW1lXSksIHBhcmFtVHlwZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVOYW1lKHJlc29sdmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2YWx1ZSwgcGFyYW1UeXBlLmNvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbVR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dnZXIubWFrZUVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdiwgcGFyYW1UeXBlLmFycmF5Q2hpbGRyZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBJZiBhbiBleHRyYSBhcmd1bWVudCBpcyBnaXZlbiwgaXQgaXMgb3ZlcnJpZGVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyYW1ldGVyIGNvdW50IG1hdGNoZXNcbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJwYXNzZWQgdG8gY29udHJhY3RcIik7XG4gICAgICAgIC8vIFBvcHVsYXRlIFwiZnJvbVwiIG92ZXJyaWRlIChhbGxvdyBwcm9taXNlcylcbiAgICAgICAgaWYgKGNvbnRyYWN0LnNpZ25lcikge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGggYSBTaWduZXIgYXJlIGZyb20gdGhlIFNpZ25lcidzIGZyYW1lLW9mLXJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgYWxsb3cgb3ZlcnJpZGluZyBcImZyb21cIiBpZiBpdCBtYXRjaGVzIHRoZSBzaWduZXJcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGU6IHJlc29sdmVOYW1lKGNvbnRyYWN0LnNpZ25lciwgb3ZlcnJpZGVzLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgICAgICB9KS50aGVuKChjaGVjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhjaGVjay5zaWduZXIpICE9PSBjaGVjay5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDb250cmFjdCB3aXRoIGEgU2lnbmVyIGNhbm5vdCBvdmVycmlkZSBmcm9tXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy5mcm9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5vdmVycmlkZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZU5hbWUoY29udHJhY3QucHJvdmlkZXIsIG92ZXJyaWRlcy5mcm9tKTtcbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRob3V0IGEgc2lnbmVyIGNhbiBvdmVycmlkZSBcImZyb21cIiwgYW5kIGlmXG4gICAgICAgICAgICAvLyB1bnNwZWNpZmllZCB0aGUgemVybyBhZGRyZXNzIGlzIHVzZWRcbiAgICAgICAgICAgIC8vb3ZlcnJpZGVzLmZyb20gPSBBZGRyZXNzWmVybztcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgZGVwZW5kZW5jaWVzIHRvIGJlIHJlc29sdmVkIChwcmVmZXIgdGhlIHNpZ25lciBvdmVyIHRoZSBwcm92aWRlcilcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBhcmdzOiByZXNvbHZlQWRkcmVzc2VzKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlciwgYXJncywgZnJhZ21lbnQuaW5wdXRzKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0LnJlc29sdmVkQWRkcmVzcyxcbiAgICAgICAgICAgIG92ZXJyaWRlczogKHJlc29sdmVQcm9wZXJ0aWVzKG92ZXJyaWRlcykgfHwge30pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgQUJJIGNvZGVkIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZC5hcmdzKTtcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgdG86IHJlc29sdmVkLmFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzb2x2ZWQgT3ZlcnJpZGVzXG4gICAgICAgIGNvbnN0IHJvID0gcmVzb2x2ZWQub3ZlcnJpZGVzO1xuICAgICAgICAvLyBQb3B1bGF0ZSBzaW1wbGUgb3ZlcnJpZGVzXG4gICAgICAgIGlmIChyby5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5ub25jZSA9IEJpZ051bWJlci5mcm9tKHJvLm5vbmNlKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKHJvLmdhc0xpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBCaWdOdW1iZXIuZnJvbShyby5nYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heEZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbShyby5tYXhGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gcm8uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8udHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50eXBlID0gcm8udHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyby5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gXCJnYXNMaW1pdFwiIG92ZXJyaWRlLCBidXQgdGhlIEFCSSBzcGVjaWZpZXMgYSBkZWZhdWx0LCB1c2UgaXRcbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwgJiYgZnJhZ21lbnQuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgY29zdCBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgaXMgYmFzZWQgb24gdGhlIHllbGxvdyBwYXBlciBhcyBvZiBQZXRlcnNidXJnOyB0aGlzIGlzIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gd2UgbWF5IHdpc2ggdG8gcGFyYW1ldGVyaXplIGluIHY2IGFzIHBhcnQgb2YgdGhlIE5ldHdvcmsgb2JqZWN0LiBTaW5jZSB0aGlzXG4gICAgICAgICAgICAvLyBpcyBhbHdheXMgYSBub24tbmlsIHRvIGFkZHJlc3MsIHdlIGNhbiBpZ25vcmUgR19jcmVhdGUsIGJ1dCBtYXkgd2lzaCB0byBhZGRcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbG9naWMgdG8gdGhlIENvbnRyYWN0RmFjdG9yeS5cbiAgICAgICAgICAgIGxldCBpbnRyaW5zaWMgPSAyMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpYyArPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKGludHJpbnNpYyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgXCJ2YWx1ZVwiIG92ZXJyaWRlXG4gICAgICAgIGlmIChyby52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgcm9WYWx1ZSA9IEJpZ051bWJlci5mcm9tKHJvLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcm9WYWx1ZS5pc1plcm8oKSAmJiAhZnJhZ21lbnQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZXMudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4LnZhbHVlID0gcm9WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uY3VzdG9tRGF0YSkge1xuICAgICAgICAgICAgdHguY3VzdG9tRGF0YSA9IHNoYWxsb3dDb3B5KHJvLmN1c3RvbURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jY2lwUmVhZEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHR4LmNjaXBSZWFkRW5hYmxlZCA9ICEhcm8uY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb3ZlcnJpZGVzXG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubm9uY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzUHJpY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZnJvbTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy50eXBlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmFjY2Vzc0xpc3Q7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmN1c3RvbURhdGE7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIHN0cmF5IG92ZXJyaWRlcywgd2hpY2ggbWF5IGluZGljYXRlIGFcbiAgICAgICAgLy8gdHlwbyBvciB1c2luZyBhbiB1bnN1cHBvcnRlZCBrZXkuXG4gICAgICAgIGNvbnN0IGxlZnRvdmVycyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKChrZXkpID0+IChvdmVycmlkZXNba2V5XSAhPSBudWxsKSk7XG4gICAgICAgIGlmIChsZWZ0b3ZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgY2Fubm90IG92ZXJyaWRlICR7bGVmdG92ZXJzLm1hcCgobCkgPT4gSlNPTi5zdHJpbmdpZnkobCkpLmpvaW4oXCIsXCIpfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlc1wiLFxuICAgICAgICAgICAgICAgIG92ZXJyaWRlczogbGVmdG92ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIGNvbnN0IHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXN0aW1hdGUgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIHNpZ25lclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgc2lnbmVyT3JQcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KSB7XG4gICAgY29uc3Qgd2FpdCA9IHR4LndhaXQuYmluZCh0eCk7XG4gICAgdHgud2FpdCA9IChjb25maXJtYXRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiB3YWl0KGNvbmZpcm1hdGlvbnMpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzID0gcmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZGVlcENvcHkobG9nKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIGV2ZW50IGxvZzsgaW5jbHVkZSBpdFxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZC5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7IHJldHVybiBjb250cmFjdC5wcm92aWRlcjsgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRCbG9jayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgXCJibG9ja1RhZ1wiIG92ZXJyaWRlIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBibG9ja1RhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0geWllbGQgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvdmVycmlkZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRyYWN0IHdhcyBqdXN0IGRlcGxveWVkLCB3YWl0IHVudGlsIGl0IGlzIG1pbmVkXG4gICAgICAgICAgICBpZiAoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIGEgbm9kZSBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2lnbmVyT3JQcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VTaW1wbGUgJiYgZnJhZ21lbnQub3V0cHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkcmVzcyA9IGNvbnRyYWN0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udHJhY3Qgd2FzIGp1c3QgZGVwbG95ZWQsIHdhaXQgdW50aWwgaXQgaXMgbWluZWRcbiAgICAgICAgICAgIGlmIChjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY29udHJhY3QuX2RlcGxveWVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eFJlcXVlc3QgPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIGNvbnRyYWN0LnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIFR3ZWFrIHRoZSB0eC53YWl0IHNvIHRoZSByZWNlaXB0IGhhcyBleHRyYSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KTtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAmJiAoZmlsdGVyLnRvcGljcyA9PSBudWxsIHx8IGZpbHRlci50b3BpY3MubGVuZ3RoID09PSAwKSkge1xuICAgICAgICByZXR1cm4gXCIqXCI7XG4gICAgfVxuICAgIHJldHVybiAoZmlsdGVyLmFkZHJlc3MgfHwgXCIqXCIpICsgXCJAXCIgKyAoZmlsdGVyLnRvcGljcyA/IGZpbHRlci50b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3BpYy5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWM7XG4gICAgfSkuam9pbihcIjpcIikgOiBcIlwiKTtcbn1cbmNsYXNzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBmaWx0ZXIpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJcIiwgZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IGxpc3RlbmVyLCBvbmNlOiBvbmNlIH0pO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBpdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubWFwKChpKSA9PiBpLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuICAgIHJ1bihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSB0aGlzLmxpc3RlbmVyQ291bnQoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJnc0NvcHkgPSBhcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayBpbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3NDb3B5KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgLy8gUmVzY2hlZHVsZSBpdCBpZiBpdCBub3QgXCJvbmNlXCJcbiAgICAgICAgICAgIHJldHVybiAhKGl0ZW0ub25jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFuIGVtaXRcbiAgICBnZXRFbWl0KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBbZXZlbnRdO1xuICAgIH1cbn1cbmNsYXNzIEVycm9yUnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcnJvclwiLCBudWxsKTtcbiAgICB9XG59XG4vLyBAVE9ETyBGcmFnbWVudCBzaG91bGQgaW5oZXJpdCBXaWxkY2FyZD8gYW5kIGp1c3Qgb3ZlcnJpZGUgZ2V0RW1pdD9cbi8vICAgICAgIG9yIGhhdmUgYSBjb21tb24gYWJzdHJhY3Qgc3VwZXIgY2xhc3MsIHdpdGggZW5vdWdoIGNvbnN0cnVjdG9yXG4vLyAgICAgICBvcHRpb25zIHRvIGNvbmZpZ3VyZSBib3RoLlxuLy8gQSBGcmFnbWVudCBFdmVudCB3aWxsIHBvcHVsYXRlIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IFdpbGRjYXJkXG4vLyB3aWxsLCBhbmQgYWRkaXRpb25hbGx5IGRlcmVmZXJlbmNlIHRoZSBhcmd1bWVudHMgd2hlbiBlbWl0dGluZ1xuY2xhc3MgRnJhZ21lbnRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBmcmFnbWVudCwgdG9waWNzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRvcGljID0gY29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7XG4gICAgICAgIGlmICh0b3BpY3MpIHtcbiAgICAgICAgICAgIGlmICh0b3BpYyAhPT0gdG9waWNzWzBdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsIFwidG9waWNzXCIsIHRvcGljcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gW3RvcGljXTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihnZXRFdmVudFRhZyhmaWx0ZXIpLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICBldmVudC5ldmVudCA9IHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBldmVudC5kYXRhLCBldmVudC50b3BpY3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IG51bGw7XG4gICAgICAgICAgICBldmVudC5kZWNvZGVFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVtaXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnMoZXZlbnQuYXJncyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF0uZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IChldmVudC5hcmdzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG59XG4vLyBBIFdpbGRjYXJkIEV2ZW50IHdpbGwgYXR0ZW1wdCB0byBwb3B1bGF0ZTpcbi8vICAtIGV2ZW50ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IG5hbWVcbi8vICAtIGV2ZW50U2lnbmF0dXJlICAgVGhlIGZ1bGwgc2lnbmF0dXJlIG9mIHRoZSBldmVudFxuLy8gIC0gZGVjb2RlICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGRlY29kZSBkYXRhIGFuZCB0b3BpY3Ncbi8vICAtIGFyZ3MgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBhbmQgdG9waWNzXG5jbGFzcyBXaWxkY2FyZFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UpIHtcbiAgICAgICAgc3VwZXIoXCIqXCIsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5pbnRlcmZhY2UucGFyc2VMb2coZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWQubmFtZTtcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcbiAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZXZlbnRcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NPck5hbWUsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNYXliZSBzdGlsbCBjaGVjayB0aGUgYWRkcmVzc09yTmFtZSBsb29rcyBsaWtlIGEgdmFsaWQgYWRkcmVzcyBvciBuYW1lP1xuICAgICAgICAvL2FkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtcbiAgICAgICAgaWYgKHNpZ25lck9yUHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBudWxsKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFNpZ25lci5pc1NpZ25lcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyLnByb3ZpZGVyIHx8IG51bGwpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUHJvdmlkZXIuaXNQcm92aWRlcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsIFwic2lnbmVyT3JQcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNhbGxTdGF0aWNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVzdGltYXRlR2FzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlcnNcIiwge30pO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVGaWx0ZXJzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5ldmVudHMpLmZvckVhY2goKGV2ZW50U2lnbmF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmludGVyZmFjZS5ldmVudHNbZXZlbnRTaWduYXR1cmVdO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgZXZlbnRTaWduYXR1cmUsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3M6IHRoaXMuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhldmVudCwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdLnB1c2goZXZlbnRTaWduYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVGaWx0ZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IHVuaXF1ZUZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgbmFtZSwgdGhpcy5maWx0ZXJzW2ZpbHRlcnNbMF1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiAke25hbWV9ICgke2ZpbHRlcnMuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9ydW5uaW5nRXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd3JhcHBlZEVtaXRzXCIsIHt9KTtcbiAgICAgICAgaWYgKGFkZHJlc3NPck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29udHJhY3QgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcImFkZHJlc3NPck5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZU5hbWUodGhpcy5wcm92aWRlciwgYWRkcmVzc09yTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCBQcm9taXNlLnJlc29sdmUoZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCBhIHByb3ZpZGVyLCB3ZSBjYW5ub3QgdXNlIEVOUyBuYW1lc1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgaXMgcmVxdWlyZWQgdG8gdXNlIEVOUyBuYW1lIGFzIGNvbnRyYWN0IGFkZHJlc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBDb250cmFjdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhbGxvdyBiYWQgRU5TIG5hbWVzIHRvIHByZXZlbnQgVW5oYW5kbGVkIEV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy5yZXNvbHZlZEFkZHJlc3MuY2F0Y2goKGUpID0+IHsgfSk7XG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKChzaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgdW5pcXVlOyBpZiBub3QgdGhlIEFCSSBnZW5lcmF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gbm90IGJlZW4gY2xlYW5lZCBvciBtYXkgYmUgaW5jb3JyZWN0bHkgZ2VuZXJhdGVkXG4gICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBBQkkgZW50cnkgZm9yICR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYW1iaWd1b3VzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXS5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNvbGxhcHNlIHNpbXBsZSBjYWxscyBvbiB0aGlzIGJ1Y2tldCwgd2hpY2ggYWxsb3dzXG4gICAgICAgICAgICAvLyBmcmFtZXdvcmtzIHRvIHNhZmVseSB1c2UgdGhpcyB3aXRob3V0IGludHJvc3BlY3Rpb24gYXMgd2VsbCBhc1xuICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIGJ1aWxkQ2FsbCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZSh0aGlzLCBmcmFnbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5lc3RpbWF0ZUdhcywgc2lnbmF0dXJlLCBidWlsZEVzdGltYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gQW1iaWd1b3VzIG5hbWVzIHRvIG5vdCBnZXQgYXR0YWNoZWQgYXMgYmFyZSBuYW1lc1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHVuaXF1ZU5hbWVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbGVhZGluZyBcIiVcIiB1c2VkIGZvciBwcm90b3R5cGUgcHJvdGVjdGlvblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgIC8vIElmIG92ZXJ3cml0aW5nIGEgbWVtYmVyIHByb3BlcnR5IHRoYXQgaXMgbnVsbCwgc3dhbGxvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBuYW1lLCB0aGlzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIG5hbWUsIHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBuYW1lLCB0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIG5hbWUsIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVzdGltYXRlR2FzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBuYW1lLCB0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW50ZXJmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFsbG93IHRpbWVvdXQ/XG4gICAgZGVwbG95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZCgpO1xuICAgIH1cbiAgICBfZGVwbG95ZWQoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUganVzdCBkZXBsb3llZCwgd2Uga25vdyB0aGUgdHJhbnNhY3Rpb24gd2Ugc2hvdWxkIG9jY3VyIGluXG4gICAgICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBPbmNlIHdlIGFsbG93IGEgdGltZW91dCB0byBiZSBwYXNzZWQgaW4sIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoYXQgbWFueSBibG9ja3MgZm9yIGdldENvZGVcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcywgYmxvY2tUYWcpLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gQFRPRE86XG4gICAgLy8gZXN0aW1hdGVGYWxsYmFjayhvdmVycmlkZXM/OiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZURlcGxveShieXRlY29kZTogc3RyaW5nLCAuLi5hcmdzKTogUHJvbWlzZTxCaWdOdW1iZXI+XG4gICAgZmFsbGJhY2sob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBzaGFsbG93Q29weShvdmVycmlkZXMgfHwge30pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHgudG8gPSB0aGlzLnJlc29sdmVkQWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVjb25uZWN0IHRvIGEgZGlmZmVyZW50IHNpZ25lciBvciBwcm92aWRlclxuICAgIGNvbm5lY3Qoc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChzaWduZXJPclByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2lnbmVyT3JQcm92aWRlciA9IG5ldyBWb2lkU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG4gICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3RcbiAgICBhdHRhY2goYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKTtcbiAgICB9XG4gICAgX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoaXMgZXZlbnQgcnVubmluZzsgd2UgY2FuIHJlLXVzZSBpdFxuICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcbiAgICB9XG4gICAgX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBcImVycm9yXCIgZXZlbnRzIChpZiB5b3VyIGNvbnRyYWN0IGhhcyBhbiBlcnJvciBldmVudCwgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIGJ5cGFzcyB0aGlzIHNwZWNpYWwgZXZlbnQga2V5d29yZClcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoXCJldmVudFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IEZyYWdtZW50ICh0aHJvd3MgaWYgYW1iaWd1b3VzL3Vua25vd24gZXZlbnQpXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgdG9waWNzIHRvIGZpbHRlciBieS4uLlxuICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElzIGl0IGEga25vd24gdG9waWNoYXNoPyAodGhyb3dzIGlmIG5vIG1hdGNoaW5nIHRvcGljaGFzaClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9waWMgPSBldmVudE5hbWUudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRvcGljXCIpOyAvLyBAVE9ETzogTWF5IGhhcHBlbiBmb3IgYW5vbnltb3VzIGV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KHRvcGljKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBldmVudE5hbWUudG9waWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICB9XG4gICAgX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvbGxlciBmb3IgdGhpcywgcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBlbWl0ID0gdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgaWYgKGVtaXQgJiYgcnVubmluZ0V2ZW50LmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsIGVtaXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBncmFjZWZ1bGx5IHJlY292ZXJcbiAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcbiAgICBfd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBldmVudCA9IGRlZXBDb3B5KGxvZyk7XG4gICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSAoKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGxvZy5ibG9ja0hhc2gpOyB9O1xuICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24obG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdyBpZiB0aGUgdG9waWNzIGFuZCBkYXRhIG1pc21hdGNoIHRoZSBzaWduYXR1cmVcbiAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIm9uY2VcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICAvLyBUcmFjayB0aGlzIHJ1bm5pbmcgZXZlbnQgYW5kIGl0cyBsaXN0ZW5lcnMgKG1heSBhbHJlYWR5IGJlIHRoZXJlOyBidXQgbm8gaGFybSBpbiB1cGRhdGluZylcbiAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBwb2xsaW5nIHRoZSBwcm92aWRlciwgc3RhcnQgcG9sbGluZ1xuICAgICAgICBpZiAoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVtaXQgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChydW5uaW5nRXZlbnQuZmlsdGVyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVtaXQgXCJldmVudFwiIGZvciBmcmFnbWVudC1iYXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbWl0IFwiZXJyb3JcIiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudC5kZWNvZGVFcnJvciwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10gPSB3cmFwcGVkRW1pdDtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlciwgd3JhcHBlZEVtaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBzaGFsbG93Q29weShydW5uaW5nRXZlbnQuZmlsdGVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmIGlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gZnJvbUJsb2NrT3JCbG9ja2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gKChmcm9tQmxvY2tPckJsb2NraGFzaCAhPSBudWxsKSA/IGZyb21CbG9ja09yQmxvY2toYXNoIDogMCk7XG4gICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKChsb2cpID0+IHRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChydW5uaW5nRXZlbnQucnVuKGFyZ3MpID4gMCk7XG4gICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3J1bm5pbmdFdmVudHMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIHRoaXMuX3J1bm5pbmdFdmVudHNba2V5XS5saXN0ZW5lckNvdW50KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXS5saXN0ZW5lcnMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbn1cbmV4cG9ydCBjbGFzcyBDb250cmFjdEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0SW50ZXJmYWNlLCBieXRlY29kZSwgc2lnbmVyKSB7XG4gICAgICAgIGxldCBieXRlY29kZUhleCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0J5dGVzKGJ5dGVjb2RlKSkge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBoZXhsaWZ5KGJ5dGVjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlY29kZSAmJiB0eXBlb2YgKGJ5dGVjb2RlLm9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Jhc2ggaW4gdGhlIG5leHQgdmVyaWZpY2F0aW9uIHN0ZXBcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGl0IGlzIDB4IHByZWZpeGVkXG4gICAgICAgIGlmIChieXRlY29kZUhleC5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbmFsIHJlc3VsdCBpcyB2YWxpZCBieXRlY29kZVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJ5dGVjb2RlSGV4KSB8fCAoYnl0ZWNvZGVIZXgubGVuZ3RoICUgMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzaWduZXIsIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuICAgICAgICBpZiAoc2lnbmVyICYmICFTaWduZXIuaXNTaWduZXIoc2lnbmVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBGdXR1cmU7IHJlbmFtZSB0byBwb3B1bGF0ZVRyYW5zYWN0aW9uP1xuICAgIGdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHR4ID0ge307XG4gICAgICAgIC8vIElmIHdlIGhhdmUgMSBhZGRpdGlvbmFsIGFyZ3VtZW50LCB3ZSBhbGxvdyB0cmFuc2FjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IHRoZXNlIHRvIGJlIG92ZXJyaWRkZW4gaW4gYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR4LnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHR4LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaXNaZXJvKCkgJiYgIXRoaXMuaW50ZXJmYWNlLmRlcGxveS5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBjb25zdHJ1Y3RvciBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy52YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkYXRhIHRvIHRoZSBieXRlY29kZSArIHRoZSBlbmNvZGVkIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICB0eC5kYXRhID0gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBFTlMgbmFtZXMgYW5kIHByb21pc2VzIGluIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVBZGRyZXNzZXModGhpcy5zaWduZXIsIGFyZ3MsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAod2l0aCBvcHRpb25hbCBvdmVycmlkZXMpXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbiguLi5wYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIpKHR4KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kaWZpZWQgd2FpdCB0aGF0IHdyYXBzIGV2ZW50c1xuICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0eCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2goYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IpLmdldENvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG4gICAgfVxuICAgIGNvbm5lY3Qoc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNvbGlkaXR5KGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcImNvbXBpbGVyT3V0cHV0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb21waWxlck91dHB1dCA9IEpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IGNvbXBpbGVyT3V0cHV0LmFiaTtcbiAgICAgICAgbGV0IGJ5dGVjb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyT3V0cHV0LmV2bSAmJiBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHR4KSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJjaGVja1Jlc3VsdEVycm9ycyIsIkluZGV4ZWQiLCJJbnRlcmZhY2UiLCJQcm92aWRlciIsIlNpZ25lciIsIlZvaWRTaWduZXIiLCJnZXRBZGRyZXNzIiwiZ2V0Q29udHJhY3RBZGRyZXNzIiwiQmlnTnVtYmVyIiwiYXJyYXlpZnkiLCJjb25jYXQiLCJoZXhsaWZ5IiwiaXNCeXRlcyIsImlzSGV4U3RyaW5nIiwiZGVmaW5lUmVhZE9ubHkiLCJkZWVwQ29weSIsImdldFN0YXRpYyIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhbGxvd0NvcHkiLCJhY2Nlc3NMaXN0aWZ5IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImFsbG93ZWRUcmFuc2FjdGlvbktleXMiLCJjaGFpbklkIiwiZGF0YSIsImZyb20iLCJnYXNMaW1pdCIsImdhc1ByaWNlIiwibm9uY2UiLCJ0byIsInR5cGUiLCJhY2Nlc3NMaXN0IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJjdXN0b21EYXRhIiwiY2NpcFJlYWRFbmFibGVkIiwicmVzb2x2ZU5hbWUiLCJyZXNvbHZlciIsIm5hbWVPclByb21pc2UiLCJuYW1lIiwidGhyb3dBcmd1bWVudEVycm9yIiwiZXJyb3IiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwiYWRkcmVzcyIsInJlc29sdmVBZGRyZXNzZXMiLCJwYXJhbVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJhbGwiLCJtYXAiLCJpbmRleCIsImNvbXBvbmVudHMiLCJiYXNlVHlwZSIsIm1ha2VFcnJvciIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsInYiLCJhcnJheUNoaWxkcmVuIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsImNvbnRyYWN0IiwiZnJhZ21lbnQiLCJhcmdzIiwib3ZlcnJpZGVzIiwibGVuZ3RoIiwiaW5wdXRzIiwicG9wIiwiY2hlY2tBcmd1bWVudENvdW50Iiwic2lnbmVyIiwib3ZlcnJpZGUiLCJjaGVjayIsInByb3ZpZGVyIiwicmVzb2x2ZWQiLCJyZXNvbHZlZEFkZHJlc3MiLCJpbnRlcmZhY2UiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0eCIsInJvIiwidG9OdW1iZXIiLCJnYXMiLCJpbnRyaW5zaWMiLCJieXRlcyIsImkiLCJhZGQiLCJyb1ZhbHVlIiwiaXNaZXJvIiwicGF5YWJsZSIsImxlZnRvdmVycyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJsIiwiSlNPTiIsInN0cmluZ2lmeSIsImpvaW4iLCJidWlsZFBvcHVsYXRlIiwiYnVpbGRFc3RpbWF0ZSIsInNpZ25lck9yUHJvdmlkZXIiLCJlc3RpbWF0ZUdhcyIsImFkZENvbnRyYWN0V2FpdCIsIndhaXQiLCJiaW5kIiwiY29uZmlybWF0aW9ucyIsInJlY2VpcHQiLCJldmVudHMiLCJsb2dzIiwibG9nIiwiZXZlbnQiLCJwYXJzZWQiLCJwYXJzZUxvZyIsImRlY29kZSIsInRvcGljcyIsImRlY29kZUV2ZW50TG9nIiwiZXZlbnRGcmFnbWVudCIsImV2ZW50U2lnbmF0dXJlIiwic2lnbmF0dXJlIiwicmVtb3ZlTGlzdGVuZXIiLCJnZXRCbG9jayIsImJsb2NrSGFzaCIsImdldFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25IYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiYnVpbGRDYWxsIiwiY29sbGFwc2VTaW1wbGUiLCJibG9ja1RhZyIsInVuZGVmaW5lZCIsInB1c2giLCJkZXBsb3lUcmFuc2FjdGlvbiIsIl9kZXBsb3llZCIsImNhbGwiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsIm91dHB1dHMiLCJjb2RlIiwiQ0FMTF9FWENFUFRJT04iLCJ0cmFuc2FjdGlvbiIsImJ1aWxkU2VuZCIsInR4UmVxdWVzdCIsInNlbmRUcmFuc2FjdGlvbiIsImJ1aWxkRGVmYXVsdCIsImNvbnN0YW50IiwiZ2V0RXZlbnRUYWciLCJ0b3BpYyIsIlJ1bm5pbmdFdmVudCIsImNvbnN0cnVjdG9yIiwidGFnIiwiX2xpc3RlbmVycyIsImFkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJvbmNlIiwiaXRlbSIsInJlbW92ZUFsbExpc3RlbmVycyIsImxpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJydW4iLCJhcmdzQ29weSIsInNsaWNlIiwic2V0VGltZW91dCIsInByZXBhcmVFdmVudCIsImdldEVtaXQiLCJFcnJvclJ1bm5pbmdFdmVudCIsIkZyYWdtZW50UnVubmluZ0V2ZW50IiwiY29udHJhY3RJbnRlcmZhY2UiLCJnZXRFdmVudFRvcGljIiwiZm9ybWF0IiwiZGVjb2RlRXJyb3IiLCJXaWxkY2FyZFJ1bm5pbmdFdmVudCIsIkJhc2VDb250cmFjdCIsImFkZHJlc3NPck5hbWUiLCJpc1NpZ25lciIsImlzUHJvdmlkZXIiLCJ1bmlxdWVGaWx0ZXJzIiwiZm9yRWFjaCIsImZpbHRlcnMiLCJlbmNvZGVGaWx0ZXJUb3BpY3MiLCJ3YXJuIiwiY2F0Y2giLCJ1bmlxdWVOYW1lcyIsInVuaXF1ZVNpZ25hdHVyZXMiLCJmdW5jdGlvbnMiLCJjYWxsU3RhdGljIiwic2lnbmF0dXJlcyIsInN1YnN0cmluZyIsImdldEludGVyZmFjZSIsImlzSW50ZXJmYWNlIiwiZGVwbG95ZWQiLCJfZGVwbG95ZWRQcm9taXNlIiwiZ2V0Q29kZSIsImNvbnRyYWN0QWRkcmVzcyIsImZhbGxiYWNrIiwiY29ubmVjdCIsImF0dGFjaCIsImlzSW5kZXhlZCIsIl9ub3JtYWxpemVSdW5uaW5nRXZlbnQiLCJydW5uaW5nRXZlbnQiLCJfcnVubmluZ0V2ZW50cyIsIl9nZXRSdW5uaW5nRXZlbnQiLCJldmVudE5hbWUiLCJnZXRFdmVudCIsIkVycm9yIiwiX2NoZWNrUnVubmluZ0V2ZW50cyIsImVtaXQiLCJfd3JhcHBlZEVtaXRzIiwib2ZmIiwiX3dyYXBFdmVudCIsIl9hZGRFdmVudExpc3RlbmVyIiwid3JhcHBlZEVtaXQiLCJvbiIsInF1ZXJ5RmlsdGVyIiwiZnJvbUJsb2NrT3JCbG9ja2hhc2giLCJ0b0Jsb2NrIiwiZnJvbUJsb2NrIiwiZ2V0TG9ncyIsInJlZHVjZSIsImFjY3VtIiwiQ29udHJhY3QiLCJDb250cmFjdEZhY3RvcnkiLCJieXRlY29kZSIsImJ5dGVjb2RlSGV4Iiwib2JqZWN0IiwiZ2V0RGVwbG95VHJhbnNhY3Rpb24iLCJkZXBsb3kiLCJlbmNvZGVEZXBsb3kiLCJwYXJhbXMiLCJ1bnNpZ25lZFR4IiwiZ2V0Q29udHJhY3QiLCJmcm9tU29saWRpdHkiLCJjb21waWxlck91dHB1dCIsIk1JU1NJTkdfQVJHVU1FTlQiLCJwYXJzZSIsImFiaSIsImV2bSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.8.0/node_modules/@ethersproject/contracts/lib.esm/index.js\n");

/***/ })

};
;