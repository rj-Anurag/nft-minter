"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10";
exports.ids = ["vendor-chunks/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"providers/5.8.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuOC4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS44LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL192ZXJzaW9uLmpzPzg5M2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInByb3ZpZGVycy81LjguMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProvider: () => (/* binding */ BaseProvider),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   Resolver: () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-provider@5.8.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/.pnpm/@ethersproject+base64@5.8.0/node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/./node_modules/.pnpm/@ethersproject+basex@5.8.0/node_modules/@ethersproject/basex/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/.pnpm/@ethersproject+constants@5.8.0/node_modules/@ethersproject/constants/lib.esm/hashes.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/.pnpm/@ethersproject+hash@5.8.0/node_modules/@ethersproject/hash/lib.esm/namehash.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/.pnpm/@ethersproject+networks@5.8.0/node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/.pnpm/@ethersproject+sha2@5.8.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/.pnpm/@ethersproject+strings@5.8.0/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/.pnpm/@ethersproject+web@5.8.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while(topics.length > 0 && topics[topics.length - 1] == null){\n        topics.pop();\n    }\n    return topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic)=>{\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof eventName === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    } else if (eventName && typeof eventName === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */ const PollableEvents = [\n    \"block\",\n    \"network\",\n    \"pending\",\n    \"poll\"\n];\nclass Event {\n    constructor(tag, listener, once){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"listener\", listener);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": {\n        symbol: \"btc\",\n        p2pkh: 0x00,\n        p2sh: 0x05,\n        prefix: \"bc\"\n    },\n    \"2\": {\n        symbol: \"ltc\",\n        p2pkh: 0x30,\n        p2sh: 0x32,\n        prefix: \"ltc\"\n    },\n    \"3\": {\n        symbol: \"doge\",\n        p2pkh: 0x1e,\n        p2sh: 0x16\n    },\n    \"60\": {\n        symbol: \"eth\",\n        ilk: \"eth\"\n    },\n    \"61\": {\n        symbol: \"etc\",\n        ilk: \"eth\"\n    },\n    \"700\": {\n        symbol: \"xdai\",\n        ilk: \"eth\"\n    }\n};\nfunction bytes32ify(value) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n        data,\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)\n    ]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\nfunction _parseString(result, start) {\n    try {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();\n    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(null);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"provider\", provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"name\", name);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result)=>{\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);\n            }).catch((error)=>{\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    selector,\n                    (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name),\n                    parameters || \"0x\"\n                ])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    \"0x9061b923\",\n                    encodeBytes([\n                        (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name),\n                        tx.data\n                    ])\n                ]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32 === 4) {\n                    logger.throwError(\"resolver threw error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx,\n                        data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2pkh\n                        ],\n                        \"0x\" + p2pkh[2]\n                    ]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2sh\n                        ],\n                        \"0x\" + p2sh[2]\n                    ]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const linkage = [\n                {\n                    type: \"name\",\n                    content: this.name\n                }\n            ];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for(let i = 0; i < matchers.length; i++){\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch(scheme){\n                        case \"https\":\n                            linkage.push({\n                                type: \"url\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"data\":\n                            linkage.push({\n                                type: \"data\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"ipfs\":\n                            linkage.push({\n                                type: \"ipfs\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: getIpfsLink(avatar)\n                            };\n                        case \"erc721\":\n                        case \"erc1155\":\n                            {\n                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                                const selector = scheme === \"erc721\" ? \"0xc87b56dd\" : \"0x0e89341c\";\n                                linkage.push({\n                                    type: scheme,\n                                    content: avatar\n                                });\n                                // The owner of this name\n                                const owner = this._resolvedAddress || (yield this.getAddress());\n                                const comps = (match[2] || \"\").split(\"/\");\n                                if (comps.length !== 2) {\n                                    return null;\n                                }\n                                const addr = yield this.provider.formatter.address(comps[0]);\n                                const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32);\n                                // Check that this account owns the token\n                                if (scheme === \"erc721\") {\n                                    // ownerOf(uint256 tokenId)\n                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x6352211e\",\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (owner !== tokenOwner) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"owner\",\n                                        content: tokenOwner\n                                    });\n                                } else if (scheme === \"erc1155\") {\n                                    // balanceOf(address owner, uint256 tokenId)\n                                    const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x00fdd58e\",\n                                            (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32),\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (balance.isZero()) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"balance\",\n                                        content: balance.toString()\n                                    });\n                                }\n                                // Call the token contract for the metadata URL\n                                const tx = {\n                                    to: this.provider.formatter.address(comps[0]),\n                                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                        selector,\n                                        tokenId\n                                    ])\n                                };\n                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);\n                                if (metadataUrl == null) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata-url-base\",\n                                    content: metadataUrl\n                                });\n                                // ERC-1155 allows a generic {id} in the URL\n                                if (scheme === \"erc1155\") {\n                                    metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                    linkage.push({\n                                        type: \"metadata-url-expanded\",\n                                        content: metadataUrl\n                                    });\n                                }\n                                // Transform IPFS metadata links\n                                if (metadataUrl.match(/^ipfs:/i)) {\n                                    metadataUrl = getIpfsLink(metadataUrl);\n                                }\n                                linkage.push({\n                                    type: \"metadata-url\",\n                                    content: metadataUrl\n                                });\n                                // Get the token metadata\n                                const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);\n                                if (!metadata) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata\",\n                                    content: JSON.stringify(metadata)\n                                });\n                                // Pull the image URL out\n                                let imageUrl = metadata.image;\n                                if (typeof imageUrl !== \"string\") {\n                                    return null;\n                                }\n                                if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                                } else {\n                                    // Transform IPFS link to gateway\n                                    const ipfs = imageUrl.match(matcherIpfs);\n                                    if (ipfs == null) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"url-ipfs\",\n                                        content: imageUrl\n                                    });\n                                    imageUrl = getIpfsLink(imageUrl);\n                                }\n                                linkage.push({\n                                    type: \"url\",\n                                    content: imageUrl\n                                });\n                                return {\n                                    linkage,\n                                    url: imageUrl\n                                };\n                            }\n                    }\n                }\n            } catch (error) {}\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === 32 * 2) {\n                    return \"bzz://\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === 34 * 2) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = {\n                        \"=\": \"\",\n                        \"+\": \"-\",\n                        \"/\": \"_\"\n                    };\n                    const hash = (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a)=>urlSafe[a]);\n                    return \"sia://\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                bytes32ify(64),\n                bytes32ify(keyBytes.length),\n                keyBytes\n            ]);\n            // Pad to word-size (32 bytes)\n            if (keyBytes.length % 32 !== 0) {\n                keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                    keyBytes,\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(\"0x\", 32 - key.length % 32)\n                ]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */ constructor(network){\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = {\n            block: -2\n        };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"anyNetwork\", network === \"any\");\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error)=>{});\n            // Trigger initial network setting (async)\n            this._ready().catch((error)=>{});\n        } else {\n            const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    } catch (error) {}\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    } else {\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>{\n            return this._ready().then((network)=>{\n                return network;\n            }, (error)=>{\n                // If the network isn't running yet, we will wait\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__.getNetwork)(network == null ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for(let i = 0; i < urls.length; i++){\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = url.indexOf(\"{data}\") >= 0 ? null : JSON.stringify({\n                    data,\n                    sender\n                });\n                const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({\n                    url: href,\n                    errorPassThrough: true\n                }, json, (value, response)=>{\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = result.message || \"unknown error\";\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                        url,\n                        errorMessage\n                    });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                urls,\n                errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while(this._internalBlockNumber){\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if (getTime() - result.respTime <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        break;\n                    } catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network)=>null, (error)=>error)\n            }).then(({ blockNumber, networkError })=>{\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return {\n                    blockNumber,\n                    reqTime,\n                    respTime\n                };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error)=>{\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            } catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs(this._emitted.block - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            } else {\n                // Notify all listener for each block that has passed\n                for(let i = this._emitted.block + 1; i <= blockNumber; i++){\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key)=>{\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event)=>{\n                switch(event.type){\n                    case \"tx\":\n                        {\n                            const hash = event.hash;\n                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{\n                                if (!receipt || receipt.blockNumber == null) {\n                                    return null;\n                                }\n                                this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                                this.emit(hash, receipt);\n                                return null;\n                            }).catch((error)=>{\n                                this.emit(\"error\", error);\n                            });\n                            runners.push(runner);\n                            break;\n                        }\n                    case \"filter\":\n                        {\n                            // We only allow a single getLogs to be in-flight at a time\n                            if (!event._inflight) {\n                                event._inflight = true;\n                                // This is the first filter for this event, so we want to\n                                // restrict events to events that happened no earlier than now\n                                if (event._lastBlockNumber === -2) {\n                                    event._lastBlockNumber = blockNumber - 1;\n                                }\n                                // Filter from the last *known* event; due to load-balancing\n                                // and some nodes returning updated block numbers before\n                                // indexing events, a logs result with 0 entries cannot be\n                                // trusted and we must retry a range which includes it again\n                                const filter = event.filter;\n                                filter.fromBlock = event._lastBlockNumber + 1;\n                                filter.toBlock = blockNumber;\n                                // Prevent fitler ranges from growing too wild, since it is quite\n                                // likely there just haven't been any events to move the lastBlockNumber.\n                                const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                                if (minFromBlock > filter.fromBlock) {\n                                    filter.fromBlock = minFromBlock;\n                                }\n                                if (filter.fromBlock < 0) {\n                                    filter.fromBlock = 0;\n                                }\n                                const runner = this.getLogs(filter).then((logs)=>{\n                                    // Allow the next getLogs\n                                    event._inflight = false;\n                                    if (logs.length === 0) {\n                                        return;\n                                    }\n                                    logs.forEach((log)=>{\n                                        // Only when we get an event for a given block number\n                                        // can we trust the events are indexed\n                                        if (log.blockNumber > event._lastBlockNumber) {\n                                            event._lastBlockNumber = log.blockNumber;\n                                        }\n                                        // Make sure we stall requests to fetch blocks and txs\n                                        this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                        this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                        this.emit(filter, log);\n                                    });\n                                }).catch((error)=>{\n                                    this.emit(\"error\", error);\n                                    // Allow another getLogs (the range was not updated)\n                                    event._inflight = false;\n                                });\n                                runners.push(runner);\n                            }\n                            break;\n                        }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(()=>{\n                this.emit(\"didPoll\", pollId);\n            }).catch((error)=>{\n                this.emit(\"error\", error);\n            });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return logger.throwError(\"provider does not support network detection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{\n            this._setFastBlockNumber(blockNumber);\n        }, (error)=>{});\n        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return this._poller != null;\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(()=>{\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(()=>{\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof value !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if (now - this._fastQueryDate > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject)=>{\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function() {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func)=>{\n                        func();\n                    });\n                    return false;\n                };\n                const minedHandler = (receipt)=>{\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(()=>{\n                    this.removeListener(transactionHash, minedHandler);\n                });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {\n                            if (done) {\n                                return;\n                            }\n                            // Wait 1 second; this is only used in the case of a fault, so\n                            // we will trade off a little bit of latency for more consistent\n                            // results and fewer JSON-RPC calls\n                            yield stall(1000);\n                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {\n                                    if (done) {\n                                        return;\n                                    }\n                                    if (nonce <= replaceable.nonce) {\n                                        lastBlockNumber = blockNumber;\n                                    } else {\n                                        // First check if the transaction was mined\n                                        {\n                                            const mined = yield this.getTransaction(transactionHash);\n                                            if (mined && mined.blockNumber != null) {\n                                                return;\n                                            }\n                                        }\n                                        // First time scanning. We start a little earlier for some\n                                        // wiggle room here to handle the eventually consistent nature\n                                        // of blockchain (e.g. the getTransactionCount was for a\n                                        // different block)\n                                        if (scannedBlock == null) {\n                                            scannedBlock = lastBlockNumber - 3;\n                                            if (scannedBlock < replaceable.startBlock) {\n                                                scannedBlock = replaceable.startBlock;\n                                            }\n                                        }\n                                        while(scannedBlock <= blockNumber){\n                                            if (done) {\n                                                return;\n                                            }\n                                            const block = yield this.getBlockWithTransactions(scannedBlock);\n                                            for(let ti = 0; ti < block.transactions.length; ti++){\n                                                const tx = block.transactions[ti];\n                                                // Successfully mined!\n                                                if (tx.hash === transactionHash) {\n                                                    return;\n                                                }\n                                                // Matches our transaction from and nonce; its a replacement\n                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                                    if (done) {\n                                                        return;\n                                                    }\n                                                    // Get the receipt of the replacement\n                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                                    // Already resolved or rejected (prolly a timeout)\n                                                    if (alreadyDone()) {\n                                                        return;\n                                                    }\n                                                    // The reason we were replaced\n                                                    let reason = \"replaced\";\n                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                        reason = \"repriced\";\n                                                    } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                        reason = \"cancelled\";\n                                                    }\n                                                    // Explain why we were replaced\n                                                    reject(logger.makeError(\"transaction was replaced\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {\n                                                        cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                                                        reason,\n                                                        replacement: this._wrapTransaction(tx),\n                                                        hash: transactionHash,\n                                                        receipt\n                                                    }));\n                                                    return;\n                                                }\n                                            }\n                                            scannedBlock++;\n                                        }\n                                    }\n                                    if (done) {\n                                        return;\n                                    }\n                                    this.once(\"block\", replaceHandler);\n                                }), (error)=>{\n                                if (done) {\n                                    return;\n                                }\n                                this.once(\"block\", replaceHandler);\n                            });\n                        });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(()=>{\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof timeout === \"number\" && timeout > 0) {\n                    const timer = setTimeout(()=>{\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, {\n                            timeout: timeout\n                        }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(()=>{\n                        clearTimeout(timer);\n                    });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {\n                expectedHash: tx.hash,\n                returnedHash: hash\n            });\n        }\n        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {\n                if (confirms == null) {\n                    confirms = 1;\n                }\n                if (timeout == null) {\n                    timeout = 0;\n                }\n                // Get the details to detect replacement\n                let replacement = undefined;\n                if (confirms !== 0 && startBlock != null) {\n                    replacement = {\n                        data: tx.data,\n                        from: tx.from,\n                        nonce: tx.nonce,\n                        to: tx.to,\n                        value: tx.value,\n                        startBlock\n                    };\n                }\n                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n                if (receipt == null && confirms === 0) {\n                    return null;\n                }\n                // No longer pending, allow the polling loop to garbage collect this\n                this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                if (receipt.status === 0) {\n                    logger.throwError(\"transaction failed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transactionHash: tx.hash,\n                        transaction: tx,\n                        receipt: receipt\n                    });\n                }\n                return receipt;\n            });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", {\n                    signedTransaction: hexTx\n                });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            } catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const values = yield transaction;\n            const tx = {};\n            [\n                \"from\",\n                \"to\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);\n            });\n            [\n                \"gasLimit\",\n                \"gasPrice\",\n                \"maxFeePerGas\",\n                \"maxPriorityFeePerGas\",\n                \"value\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null);\n            });\n            [\n                \"type\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\n                \"data\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null);\n            });\n            return this.formatter.transactionRequest((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx)));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\n                \"blockHash\",\n                \"topics\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\n                \"fromBlock\",\n                \"toBlock\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result)));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    redirects: attempt,\n                    transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", {\n                transaction,\n                blockTag\n            });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4) {\n                try {\n                    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();\n                    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);\n                    for(let u = 0; u < urlsLength; u++){\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction,\n                                data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                            callbackSelector,\n                            encodeBytes([\n                                ccipResult,\n                                extraData\n                            ])\n                        ])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: {\n                        transaction,\n                        blockTag\n                    },\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            addressOrName = yield addressOrName;\n            if (typeof addressOrName !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            } else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                } catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const block = yield this.perform(\"getBlock\", params);\n                    // Block was not found\n                    if (block == null) {\n                        // For blockhashes, if we didn't say it existed, that blockhash may\n                        // not exist. If we did see it though, perhaps from a log, we know\n                        // it exists, and this node is just not caught up yet.\n                        if (params.blockHash != null) {\n                            if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                return null;\n                            }\n                        }\n                        // For block tags, if we are asking for a future block, we return null\n                        if (params.blockTag != null) {\n                            if (blockNumber > this._emitted.block) {\n                                return null;\n                            }\n                        }\n                        // Retry on the next block\n                        return undefined;\n                    }\n                    // Add transactions\n                    if (includeTransactions) {\n                        let blockNumber = null;\n                        for(let i = 0; i < block.transactions.length; i++){\n                            const tx = block.transactions[i];\n                            if (tx.blockNumber == null) {\n                                tx.confirmations = 0;\n                            } else if (tx.confirmations == null) {\n                                if (blockNumber == null) {\n                                    blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                                }\n                                // Add the confirmations using the fast block number (pessimistic)\n                                let confirmations = blockNumber - tx.blockNumber + 1;\n                                if (confirmations <= 0) {\n                                    confirmations = 1;\n                                }\n                                tx.confirmations = confirmations;\n                            }\n                        }\n                        const blockWithTxs = this.formatter.blockWithTransactions(block);\n                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));\n                        return blockWithTxs;\n                    }\n                    return this.formatter.block(block);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransaction\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    const tx = this.formatter.transactionResponse(result);\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n                    } else if (tx.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - tx.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        tx.confirmations = confirmations;\n                    }\n                    return this._wrapTransaction(tx);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransactionReceipt\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    // \"geth-etc\" returns receipts before they are ready\n                    if (result.blockHash == null) {\n                        return undefined;\n                    }\n                    const receipt = this.formatter.receipt(result);\n                    if (receipt.blockNumber == null) {\n                        receipt.confirmations = 0;\n                    } else if (receipt.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - receipt.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        receipt.confirmations = confirmations;\n                    }\n                    return receipt;\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                filter: this._getFilter(filter)\n            });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log)=>{\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            blockTag = yield blockTag;\n            if (typeof blockTag === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let currentName = name;\n            while(true){\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation,\n                    network: network.name\n                });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: \"0x0178b8bf\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2)\n                });\n                return this.formatter.callAddress(addrData);\n            } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            } catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {\n                    throw error;\n                }\n            }\n            if (typeof name !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString((yield this.call({\n                to: resolverAddr,\n                data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n            })), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let resolver = null;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString((yield this.call({\n                        to: resolverAddress,\n                        data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n                    })), 0);\n                    resolver = yield this.getResolver(name);\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            } else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: method\n        });\n    }\n    _startEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _stopEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(()=>{\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n} //# sourceMappingURL=base-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuOC4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7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Q0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjguMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vYmFzZS1wcm92aWRlci5qcz9lMzc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGb3JrRXZlbnQsIFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBIYXNoWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IGJlY2gzMiBmcm9tIFwiYmVjaDMyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBGb3JtYXR0ZXIgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFdmVudCBTZXJpYWxpemVpbmdcbmZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcbiAgICBpZiAodG9waWMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHRvcGljKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIiwgXCJ0b3BpY1wiLCB0b3BpYyk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpYy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9waWNzKHRvcGljcykge1xuICAgIC8vIFJlbW92ZSB0cmFpbGluZyBudWxsIEFORC10b3BpY3M7IHRoZXkgYXJlIHJlZHVuZGFudFxuICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoID4gMCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09IG51bGwpIHtcbiAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWNzLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHRyYWNrIHVuaXF1ZSBPUi10b3BpY3NcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZSA9IHt9O1xuICAgICAgICAgICAgdG9waWMuZm9yRWFjaCgodG9waWMpID0+IHtcbiAgICAgICAgICAgICAgICB1bmlxdWVbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZSk7XG4gICAgICAgICAgICBzb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoLyYvZykubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcyA9IHRvcGljLnNwbGl0KFwifFwiKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCh0b3BpYyA9PT0gXCJudWxsXCIpID8gbnVsbCA6IHRvcGljKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKGNvbXBzLmxlbmd0aCA9PT0gMSkgPyBjb21wc1swXSA6IGNvbXBzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGV2ZW50TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKGV2ZW50TmFtZSkgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0eDpcIiArIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoRm9ya0V2ZW50LmlzRm9ya0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnROYW1lICYmIHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6XCIgKyAoZXZlbnROYW1lLmFkZHJlc3MgfHwgXCIqXCIpICsgXCI6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lLnRvcGljcyB8fCBbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIiArIGV2ZW50TmFtZSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBPYmplY3RcbmZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUHJvdmlkZXIgT2JqZWN0XG4vKipcbiAqICBFdmVudFR5cGVcbiAqICAgLSBcImJsb2NrXCJcbiAqICAgLSBcInBvbGxcIlxuICogICAtIFwiZGlkUG9sbFwiXG4gKiAgIC0gXCJwZW5kaW5nXCJcbiAqICAgLSBcImVycm9yXCJcbiAqICAgLSBcIm5ldHdvcmtcIlxuICogICAtIGZpbHRlclxuICogICAtIHRvcGljcyBhcnJheVxuICogICAtIHRyYW5zYWN0aW9uIGhhc2hcbiAqL1xuY29uc3QgUG9sbGFibGVFdmVudHMgPSBbXCJibG9ja1wiLCBcIm5ldHdvcmtcIiwgXCJwZW5kaW5nXCIsIFwicG9sbFwiXTtcbmV4cG9ydCBjbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJvbmNlXCIsIG9uY2UpO1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwidHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHNbMV07XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIHBvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG4gICAgfVxufVxuO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuY29uc3QgY29pbkluZm9zID0ge1xuICAgIFwiMFwiOiB7IHN5bWJvbDogXCJidGNcIiwgcDJwa2g6IDB4MDAsIHAyc2g6IDB4MDUsIHByZWZpeDogXCJiY1wiIH0sXG4gICAgXCIyXCI6IHsgc3ltYm9sOiBcImx0Y1wiLCBwMnBraDogMHgzMCwgcDJzaDogMHgzMiwgcHJlZml4OiBcImx0Y1wiIH0sXG4gICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcbiAgICBcIjYwXCI6IHsgc3ltYm9sOiBcImV0aFwiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjYxXCI6IHsgc3ltYm9sOiBcImV0Y1wiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxufTtcbmZ1bmN0aW9uIGJ5dGVzMzJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xufVxuLy8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5mdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSwgaGV4RGF0YVNsaWNlKHNoYTI1NihzaGEyNTYoZGF0YSkpLCAwLCA0KV0pKTtcbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgcmV0dXJuIGhleERhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG59XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhcnJheWlmeShkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChyZXN1bHQpO1xufVxuZXhwb3J0IGNsYXNzIFJlc29sdmVyIHtcbiAgICAvLyBUaGUgcmVzb2x2ZWRBZGRyZXNzIGlzIG9ubHkgZm9yIGNyZWF0aW5nIGEgUmV2ZXJzZUxvb2t1cCByZXNvbHZlclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lLCByZXNvbHZlZEFkZHJlc3MpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIHByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVzb2x2ZWRBZGRyZXNzXCIsIHJlc29sdmVkQWRkcmVzcyk7XG4gICAgfVxuICAgIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNFaXAyNTQ0KSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0c0ludGVyZmFjZShieXRlczQgPSBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpKVxuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHgwMWZmYzlhNzkwNjFiOTIzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkuZXEoMSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgdGhlIGVycm9yOiBsaW5rIGlzIGRvd24sIGV0Yy4gTGV0IGZ1dHVyZSBhdHRlbXB0cyByZXRyeS5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRzRWlwMjU0NDtcbiAgICB9XG4gICAgX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBlLmcuIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2KVwiKVxuICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgbmFtZWhhc2godGhpcy5uYW1lKSwgKHBhcmFtZXRlcnMgfHwgXCIweFwiKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2lsZGNhcmQgc3VwcG9ydDsgdXNlIEVJUC0yNTQ0IHRvIHJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGxldCBwYXJzZUJ5dGVzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoeWllbGQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUJ5dGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpXG4gICAgICAgICAgICAgICAgdHguZGF0YSA9IGhleENvbmNhdChbXCIweDkwNjFiOTIzXCIsIGVuY29kZUJ5dGVzKFtkbnNFbmNvZGUodGhpcy5uYW1lKSwgdHguZGF0YV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpO1xuICAgICAgICAgICAgICAgIGlmICgoYXJyYXlpZnkocmVzdWx0KS5sZW5ndGggJSAzMikgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXNvbHZlciB0aHJldyBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaEJ5dGVzKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChzZWxlY3RvciwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoY29pblR5cGUsIGhleEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvaW5JbmZvID0gY29pbkluZm9zW1N0cmluZyhjb2luVHlwZSldO1xuICAgICAgICBpZiAoY29pbkluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIGNvaW4gdHlwZTogJHtjb2luVHlwZX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5JbmZvLmlsayA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoaGV4Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoaGV4Qnl0ZXMpO1xuICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4gICAgICAgIGlmIChjb2luSW5mby5wMnBraCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnBraCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg3NmE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4OGFjJC8pO1xuICAgICAgICAgICAgaWYgKHAycGtoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJwa2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJwa2hbMl0ubGVuZ3RoID09PSBsZW5ndGggKiAyICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKGNvbmNhdChbW2NvaW5JbmZvLnAycGtoXSwgKFwiMHhcIiArIHAycGtoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUDJTSDogT1BfSEFTSDE2MCA8c2NyaXB0SGFzaD4gT1BfRVFVQUxcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAyc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcDJzaCA9IGhleEJ5dGVzLm1hdGNoKC9eMHhhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODckLyk7XG4gICAgICAgICAgICBpZiAocDJzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHAyc2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJzaFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJzaF0sIChcIjB4XCIgKyBwMnNoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVjaDMyXG4gICAgICAgIGlmIChjb2luSW5mby5wcmVmaXggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXNbMV07XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQxLm1lZGlhd2lraSN3aXRuZXNzLXByb2dyYW1cbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggIT09IDIwICYmIGxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID49IDAgJiYgYnl0ZXMubGVuZ3RoID09PSAyICsgbGVuZ3RoICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyLnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlY2gzMi5lbmNvZGUoY29pbkluZm8ucHJlZml4LCB3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIEV0aGVyZXVtLCB1c2UgdGhlIHN0YW5kYXJkIGBhZGRyKGJ5dGVzMzIpYFxuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5fZmV0Y2goXCIweDNiM2I1N2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIiB8fCByZXN1bHQgPT09IEhhc2haZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLCBieXRlczMyaWZ5KGNvaW5UeXBlKSk7XG4gICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgY29pblR5cGU6IGNvaW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIGNvbnRlbnQ6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJkYXRhXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogZ2V0SXBmc0xpbmsoYXZhdGFyKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCIweGM4N2I1NmRkXCIgOiBcIjB4MGU4OTM0MWNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSAodGhpcy5fcmVzb2x2ZWRBZGRyZXNzIHx8ICh5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhjb21wc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGhleFplcm9QYWQoQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duZXJPZih1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDYzNTIyMTFlXCIsIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCBjb250ZW50OiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhbGFuY2VPZihhZGRyZXNzIG93bmVyLCB1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBCaWdOdW1iZXIuZnJvbSh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDAwZmRkNThlXCIsIGhleFplcm9QYWQob3duZXIsIDMyKSwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCBjb250ZW50OiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRva2VuSWQuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHlpZWxkIGZldGNoSnNvbihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybC1pcGZzXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGJjMWM1OGQxXCIpO1xuICAgICAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogREFHLVBCKVxuICAgICAgICAgICAgY29uc3QgaXBmcyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlMzAxMDE3MCgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXBmc1s0XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXBmczovXFwvXCIgKyBCYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwZnNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQTlMgKENJRDogMSwgVHlwZTogbGlicDJwLWtleSlcbiAgICAgICAgICAgIGNvbnN0IGlwbnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTUwMTAxNzIoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICAgICAgaWYgKGlwbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcG5zWzNdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKGlwbnNbNF0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlwbnM6L1xcL1wiICsgQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcG5zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgICAgICBjb25zdCBzd2FybSA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnp6Oi9cXC9cIiArIHN3YXJtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNreW5ldCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg5MGIyYzYwNShbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHNreW5ldCkge1xuICAgICAgICAgICAgICAgIGlmIChza3luZXRbMV0ubGVuZ3RoID09PSAoMzQgKiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVUkwgU2FmZSBiYXNlNjQ7IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsU2FmZSA9IHsgXCI9XCI6IFwiXCIsIFwiK1wiOiBcIi1cIiwgXCIvXCI6IFwiX1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBiYXNlNjRFbmNvZGUoXCIweFwiICsgc2t5bmV0WzFdKS5yZXBsYWNlKC9bPStcXC9dL2csIChhKSA9PiAodXJsU2FmZVthXSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWE6L1xcL1wiICsgaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgZW5jb2RlZCBhcyBwYXJhbWV0ZXIgdG8gZmV0Y2hCeXRlc1xuICAgICAgICAgICAgbGV0IGtleUJ5dGVzID0gdG9VdGY4Qnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtrZXlCeXRlcywgaGV4WmVyb1BhZChcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsIGhleGxpZnkoa2V5Qnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5sZXQgbmV4dFBvbGxJZCA9IDE7XG5leHBvcnQgY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICByZWFkeVxuICAgICAqXG4gICAgICogIEEgUHJvbWlzZTxOZXR3b3JrPiB0aGF0IHJlc29sdmVzIG9ubHkgb25jZSB0aGUgcHJvdmlkZXIgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuICAgICAqICBNVVNUIHNldCB0aGlzLiBTdGFuZGFyZCBuYW1lZCBuZXR3b3JrcyBoYXZlIGEga25vd24gY2hhaW5JZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gRXZlbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVkID0geyBibG9jazogLTIgfTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcudGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5KCkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga25vd25OZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZSA9IDEwO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICB9XG4gICAgX3JlYWR5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9uZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIFByb3ZpZGVyJ3MgbmV0d29yayBkZXRlY3Rpb24gKHRoaXMgTVVTVCB0aHJvdyBpZiBpdCBjYW5ub3QpXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cbiAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG4gICAgLy8gYW55IGNoYW5nZSBpcyByZWZsZWN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHkoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiAmJiBlcnJvci5ldmVudCA9PT0gXCJub05ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcbiAgICBzdGF0aWMgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKChuZXR3b3JrID09IG51bGwpID8gXCJob21lc3RlYWRcIiA6IG5ldHdvcmspO1xuICAgIH1cbiAgICBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKHJlc3VsdC5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHsgdXJsLCBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgdXJscywgZXJyb3JNZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3NcbiAgICAvLyB0aGFuIG1heEFnZSBvbGQgb3IgaGFzIGJlZW4gcmVxdWVzdGVkIHNpbmNlIHRoZSBsYXN0IHJlcXVlc3RcbiAgICBfZ2V0SW50ZXJuYWxCbG9ja051bWJlcihtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3JlYWR5KCk7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBzdGFsZSBkYXRhIHVwIHRvIG1heEFnZSBvbGRcbiAgICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHBlbmRpbmcgaW50ZXJuYWwgYmxvY2sgcmVxdWVzdHMuLi5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5cInJlbWVtYmVyXCIgd2hpY2ggZmV0Y2ggd2Ugc3RhcnRlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBpcyBub3QgdG9vIHN0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBpbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZXRUaW1lKCkgLSByZXN1bHQucmVzcFRpbWUpIDw9IG1heEFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmV0Y2ggcmVqZWN0ZWQ7IGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uLCBkcm9wIHRocm91Z2ggc28gd2UgcmVwbGFjZSBpdCB3aXRoIGEgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd29uJ3QgbWF0Y2ggdGhlIG9uZSB0aGV5IFwicmVtZW1iZXJlZFwiIGFuZCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gaW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tOdW1iZXJcIiwge30pLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogdGhpcy5nZXROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4gKG51bGwpLCAoZXJyb3IpID0+IChlcnJvcikpXG4gICAgICAgICAgICB9KS50aGVuKCh7IGJsb2NrTnVtYmVyLCBuZXR3b3JrRXJyb3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5yZW1lbWJlciB0aGlzIGJhZCBpbnRlcm5hbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKGJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cbiAgICAgICAgICAgICAgICByZXR1cm4geyBibG9ja051bWJlciwgcmVxVGltZSwgcmVzcFRpbWUgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgdW5oYW5kbGVkIGV4Y2VwdGlvbnM7IGlmIG5lZWRlZCB0aGV5IGFyZSBoYW5kbGVkIGVsc2Ugd2hlcmVcbiAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBudWxsIHRoZSBkZWFkIChyZWplY3RlZCkgZmV0Y2gsIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikuYmxvY2tOdW1iZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcG9sbElkID0gbmV4dFBvbGxJZCsrO1xuICAgICAgICAgICAgLy8gVHJhY2sgYWxsIHJ1bm5pbmcgcHJvbWlzZXMsIHNvIHdlIGNhbiB0cmlnZ2VyIGEgcG9zdC1wb2xsIG9uY2UgdGhleSBhcmUgY29tcGxldGVcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5lcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiLCBwb2xsSWQsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGUsIHRyaWdnZXIgYSBcImJsb2NrXCIgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgbmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHMgKGVtaXR0ZWQ9JHt0aGlzLl9lbWl0dGVkLmJsb2NrfSBibG9ja051bWJlciR7YmxvY2tOdW1iZXJ9KWApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tOdW1iZXI6IHRoaXMuX2VtaXR0ZWQuYmxvY2tcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgIT09IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgZXZlbnQgZG9lcyBub3QgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBnYXJiYWdlIGNvbGxlY3QgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgYmxvY2tzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBcInBlbmRpbmdcIiBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QmxvY2tOdW1iZXIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZpY3QgYW55IHRyYW5zYWN0aW9uIGhhc2hlcyBvciBibG9jayBoYXNoZXMgb3ZlciAxMiBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSBldmVudEJsb2NrTnVtYmVyID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bm5lciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGEgc2luZ2xlIGdldExvZ3MgdG8gYmUgaW4tZmxpZ2h0IGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5faW5mbGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGZpbHRlciBmb3IgdGhpcyBldmVudCwgc28gd2Ugd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RyaWN0IGV2ZW50cyB0byBldmVudHMgdGhhdCBoYXBwZW5lZCBubyBlYXJsaWVyIHRoYW4gbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBmcm9tIHRoZSBsYXN0ICprbm93biogZXZlbnQ7IGR1ZSB0byBsb2FkLWJhbGFuY2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzb21lIG5vZGVzIHJldHVybmluZyB1cGRhdGVkIGJsb2NrIG51bWJlcnMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgZXZlbnRzLCBhIGxvZ3MgcmVzdWx0IHdpdGggMCBlbnRyaWVzIGNhbm5vdCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydXN0ZWQgYW5kIHdlIG11c3QgcmV0cnkgYSByYW5nZSB3aGljaCBpbmNsdWRlcyBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGV2ZW50LmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZXZlbnQuX2xhc3RCbG9ja051bWJlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZpdGxlciByYW5nZXMgZnJvbSBncm93aW5nIHRvbyB3aWxkLCBzaW5jZSBpdCBpcyBxdWl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpa2VseSB0aGVyZSBqdXN0IGhhdmVuJ3QgYmVlbiBhbnkgZXZlbnRzIHRvIG1vdmUgdGhlIGxhc3RCbG9ja051bWJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5Gcm9tQmxvY2sgPSBmaWx0ZXIudG9CbG9jayAtIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkZyb21CbG9jayA+IGZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IG1pbkZyb21CbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5mcm9tQmxvY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzLmdldExvZ3MoZmlsdGVyKS50aGVuKChsb2dzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBuZXh0IGdldExvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdoZW4gd2UgZ2V0IGFuIGV2ZW50IGZvciBhIGdpdmVuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHdlIHRydXN0IHRoZSBldmVudHMgYXJlIGluZGV4ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tOdW1iZXIgPiBldmVudC5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGFsbCByZXF1ZXN0cyB0byBmZXRjaCBibG9ja3MgYW5kIHR4c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcImI6XCIgKyBsb2cuYmxvY2tIYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbm90aGVyIGdldExvZ3MgKHRoZSByYW5nZSB3YXMgbm90IHVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocnVubmVycykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGVkOyBkbyBub3QgdXNlIHRoaXNcbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgIC8vIGNhbiBjaGFuZ2UsIHN1Y2ggYXMgd2hlbiBjb25uZWN0ZWQgdG8gYSBKU09OLVJQQyBiYWNrZW5kXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgbmV0d29yayBkZXRlY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicHJvdmlkZXIuZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBzYW1lIG5ldHdvcms7IHRoaXMgaXNcbiAgICAgICAgICAgIC8vIG9ubHkgYW4gZXh0ZXJuYWwgY2FsbCBmb3IgYmFja2VuZHMgd2hpY2ggY2FuIGhhdmUgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgY2hhbmdlIHNwb250YW5lb3VzbHlcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG93aW5nIG5ldHdvcmsgY2hhbmdlcywgdGhpbmdzIGNhbiBnZXQgY29tcGxleCBmYXN0O1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgaWYgeW91IHVzZSBcImFueVwiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gY3VycmVudE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFsbCBpbnRlcm5hbCBibG9jayBudW1iZXIgZ3VhcmRzIGFuZCBjYWNoZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IC0yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJuZXR3b3JrXCIgZXZlbnQgTVVTVCBoYXBwZW4gYmVmb3JlIHRoaXMgbWV0aG9kIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGFueSBldmVudHMgaGF2ZSBhIGNoYW5jZSB0byB1bnJlZ2lzdGVyLCBzbyB3ZSBzdGFsbCBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50IGxvb3AgYmVmb3JlIHJldHVybmluZyBmcm9tIC90aGlzLyBjYWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgY3VycmVudE5ldHdvcmssIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9nZ2VyLm1ha2VFcnJvcihcInVuZGVybHlpbmcgbmV0d29yayBjaGFuZ2VkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBibG9ja051bWJlcigpIHtcbiAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwpID8gdGhpcy5fZmFzdEJsb2NrTnVtYmVyIDogLTE7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9vdHN0cmFwUG9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9sbGluZyB3YXMgZGlzYWJsZWQsIHNvbWV0aGluZyBtYXkgcmVxdWlyZSBhIHBva2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHN0YXJ0aW5nIHRoZSBib290c3RyYXAgcG9sbCBhbmQgaXQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEZhc3RCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcbiAgICB9XG4gICAgX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcikge1xuICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQsIHJlcGxhY2VhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIC8vIFJlY2VpcHQgaXMgYWxyZWFkeSBnb29kXG4gICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsRnVuY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbWluZWRIYW5kbGVyID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHsgdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIG1pbmVkSGFuZGxlcik7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEJsb2NrTnVtYmVyID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYW5uZWRCbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VIYW5kbGVyID0gKGJsb2NrTnVtYmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHRyYWRlIG9mZiBhIGxpdHRsZSBiaXQgb2YgbGF0ZW5jeSBmb3IgbW9yZSBjb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQocmVwbGFjZWFibGUuZnJvbSkudGhlbigobm9uY2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgbWluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluZWQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZ2dsZSByb29tIGhlcmUgdG8gaGFuZGxlIHRoZSBldmVudHVhbGx5IGNvbnNpc3RlbnQgbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJsb2NrY2hhaW4gKGUuZy4gdGhlIGdldFRyYW5zYWN0aW9uQ291bnQgd2FzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSBsYXN0QmxvY2tOdW1iZXIgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA8IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzY2FubmVkQmxvY2sgPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhzY2FubmVkQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1t0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IG1pbmVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIG91ciB0cmFuc2FjdGlvbiBmcm9tIGFuZCBub25jZTsgaXRzIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gcmVwbGFjZWFibGUuZnJvbSAmJiB0eC5ub25jZSA9PT0gcmVwbGFjZWFibGUubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZCBvciByZWplY3RlZCAocHJvbGx5IGEgdGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIExvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyLnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0R2FzUHJpY2VcIiwge30pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oKHApID0+IGhleFZhbHVlKHApKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgYW55IHN1YmNsYXNzIHdyYXBwaW5nIGEgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgIF93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBoZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIHNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0eDtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiB0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwgeyBleHBlY3RlZEhhc2g6IHR4Lmhhc2gsIHJldHVybmVkSGFzaDogaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdCA9IChjb25maXJtcywgdGltZW91dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRldGFpbHMgdG8gZGV0ZWN0IHJlcGxhY2VtZW50XG4gICAgICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgIT09IDAgJiYgc3RhcnRCbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0eC5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCAmJiBjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHBlbmRpbmcsIGFsbG93IHRoZSBwb2xsaW5nIGxvb3AgdG8gZ2FyYmFnZSBjb2xsZWN0IHRoaXNcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4odCA9PiBoZXhsaWZ5KHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIiwgeyBzaWduZWRUcmFuc2FjdGlvbjogaGV4VHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSB0eC5oYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0geWllbGQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0eCA9IHt9O1xuICAgICAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyB0aGlzLl9nZXRBZGRyZXNzKHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gQmlnTnVtYmVyLmZyb20odikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcInR5cGVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAoKHYgIT0gbnVsbCkgPyB2IDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gdGhpcy5mb3JtYXR0ZXIuYWNjZXNzTGlzdCh2YWx1ZXMuYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBoZXhsaWZ5KHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXF1ZXN0KHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZmlsdGVyID0geWllbGQgZmlsdGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID49IE1BWF9DQ0lQX1JFRElSRUNUUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0czogYXR0ZW1wdCwgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gdHJhbnNhY3Rpb24udG87XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pO1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIHJlcXVlc3QgdmlhIE9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVxuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0eFNlbmRlciAhPSBudWxsICYmIHJlc3VsdC5zdWJzdHJpbmcoMCwgMTApID09PSBcIjB4NTU2ZjE4MzBcIiAmJiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICUgMzIgPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGhleERhdGFTbGljZShyZXN1bHQsIDQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSBoZXhEYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKHNlbmRlcikuZXEodHhTZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBzZW5kZXIgZGlkIG5vdCBtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAzMiwgNjQpKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNEYXRhID0gaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjb250YWluZWQgY29ycnVwdCBVUkwgc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgY2FsbGJhY2sgc2VsZWN0b3IgaW5jbHVkZWQganVua1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja1NlbGVjdG9yID0gaGV4RGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSB5aWVsZCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNhbGxkYXRhLCB1cmxzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjaXBSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgZGlzYWJsZWQgb3IgcHJvdmlkZWQgbm8gVVJMc1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleENvbmNhdChbY2FsbGJhY2tTZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9LCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLmNjaXBSZWFkRW5hYmxlZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwocmVzb2x2ZWQudHJhbnNhY3Rpb24sIHJlc29sdmVkLmJsb2NrVGFnLCByZXNvbHZlZC5jY2lwUmVhZEVuYWJsZWQgPyAwIDogLTEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzc09yTmFtZSA9IHlpZWxkIGFkZHJlc3NPck5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JOYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IGByZXNvbHZlTmFtZSgke0pTT04uc3RyaW5naWZ5KGFkZHJlc3NPck5hbWUpfSlgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGJsb2NrSGFzaE9yQmxvY2tUYWcgPSB5aWVsZCBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgLy8gSWYgYmxvY2tUYWcgaXMgYSBudW1iZXIgKG5vdCBcImxhdGVzdFwiLCBldGMpLCB0aGlzIGlzIHRoZSBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IC0xMjg7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVRyYW5zYWN0aW9uczogISFpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrSGFzaE9yQmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5ibG9ja0hhc2ggPSBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrVGFnID0geWllbGQgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHBhcnNlSW50KHBhcmFtcy5ibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9ja2hhc2hlcywgaWYgd2UgZGlkbid0IHNheSBpdCBleGlzdGVkLCB0aGF0IGJsb2NraGFzaCBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0LiBJZiB3ZSBkaWQgc2VlIGl0IHRob3VnaCwgcGVyaGFwcyBmcm9tIGEgbG9nLCB3ZSBrbm93XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrSGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcImI6XCIgKyBwYXJhbXMuYmxvY2tIYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NrIHRhZ3MsIGlmIHdlIGFyZSBhc2tpbmcgZm9yIGEgZnV0dXJlIGJsb2NrLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IHRoaXMuX2VtaXR0ZWQuYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tXaXRoVHhzID0gdGhpcy5mb3JtYXR0ZXIuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucyA9IGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1dpdGhUeHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayk7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBmYWxzZSkpO1xuICAgIH1cbiAgICBnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIHRydWUpKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gXCJnZXRoLWV0Y1wiIHJldHVybnMgcmVjZWlwdHMgYmVmb3JlIHRoZXkgYXJlIHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExvZ3MoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRMb2dzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBsb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2cucmVtb3ZlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmFycmF5T2YodGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQodGhpcy5mb3JtYXR0ZXIpKShsb2dzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEV0aGVyUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSB5aWVsZCBibG9ja1RhZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiAmJiBibG9ja1RhZyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tUYWcgJSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKGN1cnJlbnROYW1lLCBcImdldFJlc29sdmVyXCIpO1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgISh5aWVsZCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRSZXNvbHZlcihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFwiRU5TXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJyZXNvbHZlcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJEYXRhID0geWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ldHdvcmsuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgbmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhhZGRyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBuYW1lID0geWllbGQgbmFtZTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywgbm90aGluZyB0byByZXNvbHZlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBpcyBhIGhleHN0cmluZywgdGhlIGFkZHJlc3MgaXMgYmFkIChTZWUgIzY5NClcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFkZHIgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB5aWVsZCBhZGRyZXNzO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJsb29rdXBBZGRyZXNzXCIpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyQWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyICE9IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QXZhdGFyKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzOyByZXZlcnNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJnZXRBdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSByZXNvbHZpbmcgdGhlIGF2YXRhciBhZ2FpbnN0IHRoZSBhZGRyLnJldmVyc2UgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCByZXNvbHZlckFkZHJlc3MsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBuYW1lIGFuZCBwZXJmb3JtaW5nIGZvcndhcmQgbG9va3VwOyBhbGxvd2luZyB3aWxkY2FyZHNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVOUyBuYW1lOyBmb3J3YXJkIGxvb2t1cCB3aXRoIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpKVxuICAgICAgICAgICAgLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIkZvcmtFdmVudCIsIlByb3ZpZGVyIiwiZW5jb2RlIiwiYmFzZTY0RW5jb2RlIiwiQmFzZTU4IiwiQmlnTnVtYmVyIiwiYXJyYXlpZnkiLCJjb25jYXQiLCJoZXhDb25jYXQiLCJoZXhEYXRhTGVuZ3RoIiwiaGV4RGF0YVNsaWNlIiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiSGFzaFplcm8iLCJkbnNFbmNvZGUiLCJuYW1laGFzaCIsImdldE5ldHdvcmsiLCJkZWZpbmVSZWFkT25seSIsImdldFN0YXRpYyIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhMjU2IiwidG9VdGY4Qnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJmZXRjaEpzb24iLCJwb2xsIiwiYmVjaDMyIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkZvcm1hdHRlciIsIk1BWF9DQ0lQX1JFRElSRUNUUyIsImNoZWNrVG9waWMiLCJ0b3BpYyIsInRocm93QXJndW1lbnRFcnJvciIsInRvTG93ZXJDYXNlIiwic2VyaWFsaXplVG9waWNzIiwidG9waWNzIiwic2xpY2UiLCJsZW5ndGgiLCJwb3AiLCJtYXAiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmlxdWUiLCJmb3JFYWNoIiwic29ydGVkIiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJqb2luIiwiZGVzZXJpYWxpemVUb3BpY3MiLCJkYXRhIiwic3BsaXQiLCJjb21wcyIsImdldEV2ZW50VGFnIiwiZXZlbnROYW1lIiwiaW5kZXhPZiIsImlzRm9ya0V2ZW50Iiwid2FybiIsIkVycm9yIiwiYWRkcmVzcyIsImdldFRpbWUiLCJEYXRlIiwic3RhbGwiLCJkdXJhdGlvbiIsInNldFRpbWVvdXQiLCJQb2xsYWJsZUV2ZW50cyIsIkV2ZW50IiwiY29uc3RydWN0b3IiLCJ0YWciLCJsaXN0ZW5lciIsIm9uY2UiLCJfbGFzdEJsb2NrTnVtYmVyIiwiX2luZmxpZ2h0IiwiZXZlbnQiLCJ0eXBlIiwiaGFzaCIsImZpbHRlciIsInBvbGxhYmxlIiwiY29pbkluZm9zIiwic3ltYm9sIiwicDJwa2giLCJwMnNoIiwicHJlZml4IiwiaWxrIiwiYnl0ZXMzMmlmeSIsImZyb20iLCJ0b0hleFN0cmluZyIsImJhc2U1OEVuY29kZSIsIm1hdGNoZXJJcGZzIiwiUmVnRXhwIiwibWF0Y2hlcnMiLCJfcGFyc2VTdHJpbmciLCJzdGFydCIsIl9wYXJzZUJ5dGVzIiwiZXJyb3IiLCJvZmZzZXQiLCJ0b051bWJlciIsImdldElwZnNMaW5rIiwibGluayIsIm1hdGNoIiwic3Vic3RyaW5nIiwibnVtUGFkIiwicGFkZGVkIiwiVWludDhBcnJheSIsInNldCIsImJ5dGVzUGFkIiwiTWF0aCIsImNlaWwiLCJlbmNvZGVCeXRlcyIsImRhdGFzIiwiYnl0ZUNvdW50IiwiaSIsInB1c2giLCJSZXNvbHZlciIsInByb3ZpZGVyIiwibmFtZSIsInJlc29sdmVkQWRkcmVzcyIsImZvcm1hdHRlciIsInN1cHBvcnRzV2lsZGNhcmQiLCJfc3VwcG9ydHNFaXAyNTQ0IiwiY2FsbCIsInRvIiwiZXEiLCJjYXRjaCIsImNvZGUiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsIl9mZXRjaCIsInNlbGVjdG9yIiwicGFyYW1ldGVycyIsInR4IiwiY2NpcFJlYWRFbmFibGVkIiwicGFyc2VCeXRlcyIsInRocm93RXJyb3IiLCJ0cmFuc2FjdGlvbiIsIl9mZXRjaEJ5dGVzIiwiX2dldEFkZHJlc3MiLCJjb2luVHlwZSIsImhleEJ5dGVzIiwiY29pbkluZm8iLCJTdHJpbmciLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJieXRlcyIsInBhcnNlSW50Iiwid29yZHMiLCJ0b1dvcmRzIiwidW5zaGlmdCIsImdldEFkZHJlc3MiLCJjYWxsQWRkcmVzcyIsImdldEF2YXRhciIsImxpbmthZ2UiLCJjb250ZW50IiwiYXZhdGFyIiwiZ2V0VGV4dCIsInNjaGVtZSIsInVybCIsIm93bmVyIiwiX3Jlc29sdmVkQWRkcmVzcyIsImFkZHIiLCJ0b2tlbklkIiwidG9rZW5Pd25lciIsImJhbGFuY2UiLCJpc1plcm8iLCJ0b1N0cmluZyIsIm1ldGFkYXRhVXJsIiwicmVwbGFjZSIsIm1ldGFkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImltYWdlVXJsIiwiaW1hZ2UiLCJpcGZzIiwiZ2V0Q29udGVudEhhc2giLCJpcG5zIiwic3dhcm0iLCJza3luZXQiLCJ1cmxTYWZlIiwiYSIsImtleSIsImtleUJ5dGVzIiwiZGVmYXVsdEZvcm1hdHRlciIsIm5leHRQb2xsSWQiLCJCYXNlUHJvdmlkZXIiLCJuZXR3b3JrIiwiX2V2ZW50cyIsIl9lbWl0dGVkIiwiYmxvY2siLCJkaXNhYmxlQ2NpcFJlYWQiLCJnZXRGb3JtYXR0ZXIiLCJhbnlOZXR3b3JrIiwiZGV0ZWN0TmV0d29yayIsIl9uZXR3b3JrUHJvbWlzZSIsIl9yZWFkeSIsImtub3duTmV0d29yayIsImVtaXQiLCJfbWF4SW50ZXJuYWxCbG9ja051bWJlciIsIl9tYXhGaWx0ZXJCbG9ja1JhbmdlIiwiX3BvbGxpbmdJbnRlcnZhbCIsIl9mYXN0UXVlcnlEYXRlIiwiX25ldHdvcmsiLCJVTktOT1dOX0VSUk9SIiwicmVhZHkiLCJORVRXT1JLX0VSUk9SIiwidW5kZWZpbmVkIiwiY2NpcFJlYWRGZXRjaCIsImNhbGxkYXRhIiwidXJscyIsInNlbmRlciIsImVycm9yTWVzc2FnZXMiLCJocmVmIiwianNvbiIsImVycm9yUGFzc1Rocm91Z2giLCJyZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwiU0VSVkVSX0VSUk9SIiwibSIsIl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyIiwibWF4QWdlIiwiX2ludGVybmFsQmxvY2tOdW1iZXIiLCJpbnRlcm5hbEJsb2NrTnVtYmVyIiwicmVzcFRpbWUiLCJibG9ja051bWJlciIsInJlcVRpbWUiLCJjaGVja0ludGVybmFsQmxvY2tOdW1iZXIiLCJwZXJmb3JtIiwibmV0d29ya0Vycm9yIiwiX3NldEZhc3RCbG9ja051bWJlciIsInBvbGxJZCIsInJ1bm5lcnMiLCJwb2xsaW5nSW50ZXJ2YWwiLCJhYnMiLCJtYWtlRXJyb3IiLCJwcmV2aW91c0Jsb2NrTnVtYmVyIiwiZXZlbnRCbG9ja051bWJlciIsInJ1bm5lciIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibWluRnJvbUJsb2NrIiwiZ2V0TG9ncyIsImxvZ3MiLCJsb2ciLCJibG9ja0hhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJhbGwiLCJyZXNldEV2ZW50c0Jsb2NrIiwicG9sbGluZyIsImN1cnJlbnROZXR3b3JrIiwiY2hhaW5JZCIsIl9mYXN0QmxvY2tOdW1iZXIiLCJfZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSIsImRldGVjdGVkTmV0d29yayIsIl9wb2xsZXIiLCJzZXRJbnRlcnZhbCIsIl9ib290c3RyYXBQb2xsIiwiY2xlYXJJbnRlcnZhbCIsIl9nZXRGYXN0QmxvY2tOdW1iZXIiLCJub3ciLCJnZXRCbG9ja051bWJlciIsIndhaXRGb3JUcmFuc2FjdGlvbiIsImNvbmZpcm1hdGlvbnMiLCJ0aW1lb3V0IiwiX3dhaXRGb3JUcmFuc2FjdGlvbiIsInJlcGxhY2VhYmxlIiwiY2FuY2VsRnVuY3MiLCJhbHJlYWR5RG9uZSIsImZ1bmMiLCJtaW5lZEhhbmRsZXIiLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwibGFzdEJsb2NrTnVtYmVyIiwic3RhcnRCbG9jayIsInNjYW5uZWRCbG9jayIsInJlcGxhY2VIYW5kbGVyIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsIm5vbmNlIiwibWluZWQiLCJnZXRUcmFuc2FjdGlvbiIsImdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsInRpIiwidHJhbnNhY3Rpb25zIiwicmVhc29uIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJjYW5jZWxsZWQiLCJyZXBsYWNlbWVudCIsIl93cmFwVHJhbnNhY3Rpb24iLCJ0aW1lciIsIlRJTUVPVVQiLCJ1bnJlZiIsImNsZWFyVGltZW91dCIsImdldEdhc1ByaWNlIiwibWV0aG9kIiwiZ2V0QmFsYW5jZSIsImFkZHJlc3NPck5hbWUiLCJibG9ja1RhZyIsInBhcmFtcyIsIl9nZXRCbG9ja1RhZyIsImdldENvZGUiLCJnZXRTdG9yYWdlQXQiLCJwb3NpdGlvbiIsInAiLCJleHBlY3RlZEhhc2giLCJyZXR1cm5lZEhhc2giLCJ3YWl0IiwiY29uZmlybXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsImhleFR4IiwidCIsIl9nZXRUcmFuc2FjdGlvblJlcXVlc3QiLCJ2YWx1ZXMiLCJ2IiwiYWNjZXNzTGlzdCIsInRyYW5zYWN0aW9uUmVxdWVzdCIsIl9nZXRGaWx0ZXIiLCJfY2FsbCIsImF0dGVtcHQiLCJyZWRpcmVjdHMiLCJ0eFNlbmRlciIsInNpZ25hdHVyZSIsInVybHNPZmZzZXQiLCJ1cmxzTGVuZ3RoIiwidXJsc0RhdGEiLCJ1IiwiY2FsbGJhY2tTZWxlY3RvciIsImV4dHJhRGF0YSIsImNjaXBSZXN1bHQiLCJyZXNvbHZlZCIsImVzdGltYXRlR2FzIiwicmVzb2x2ZU5hbWUiLCJfZ2V0QmxvY2siLCJibG9ja0hhc2hPckJsb2NrVGFnIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImJsb2NrV2l0aFR4cyIsImJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsIm9uY2VQb2xsIiwiZ2V0QmxvY2siLCJ0cmFuc2FjdGlvblJlc3BvbnNlIiwicmVtb3ZlZCIsImFycmF5T2YiLCJmaWx0ZXJMb2ciLCJiaW5kIiwiZ2V0RXRoZXJQcmljZSIsImdldFJlc29sdmVyIiwiY3VycmVudE5hbWUiLCJfZ2V0UmVzb2x2ZXIiLCJyZXNvbHZlciIsImVuc0FkZHJlc3MiLCJhZGRyRGF0YSIsImxvb2t1cEFkZHJlc3MiLCJub2RlIiwicmVzb2x2ZXJBZGRyIiwibmFtZU9yQWRkcmVzcyIsInJlc29sdmVyQWRkcmVzcyIsIk5PVF9JTVBMRU1FTlRFRCIsIl9zdGFydEV2ZW50IiwiX3N0b3BFdmVudCIsIl9hZGRFdmVudExpc3RlbmVyIiwiYXJncyIsInN0b3BwZWQiLCJldmVudFRhZyIsImxpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJmb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   isCommunityResourcable: () => (/* binding */ isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* binding */ isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/.pnpm/@ethersproject+constants@5.8.0/node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/.pnpm/@ethersproject+transactions@5.8.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass Formatter {\n    constructor(){\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = {};\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v)=>{\n            return this.data(v, true);\n        };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data)\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null)\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined)\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof value === \"boolean\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof value === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if (result.length % 2 !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);\n    }\n    callAddress(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {\n            return null;\n        }\n        const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));\n        return address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero ? null : address;\n    }\n    contractAddress(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof blockTag === \"number\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        } catch (error) {}\n        return null;\n    }\n    uint256(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = difficulty == null ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty);\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        } else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof chainId !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof chainId !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && result.status !== value) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", {\n                            root: result.root,\n                            status: result.status\n                        });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v)=>this.topics(v));\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for(const key in format){\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return function(value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        };\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return function(value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        };\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return function(array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n            return result;\n        };\n    }\n}\nfunction isCommunityResourcable(value) {\n    return value && typeof value.isCommunityResource === \"function\";\n}\nfunction isCommunityResource(value) {\n    return isCommunityResourcable(value) && value.isCommunityResource();\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https://docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n} //# sourceMappingURL=formatter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuOC4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDMkQ7QUFDbkI7QUFDaUQ7QUFDL0M7QUFDQztBQUMrQjtBQUN4QztBQUNWO0FBQ3JDLE1BQU1lLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUMxQixNQUFNRTtJQUNUQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDQyxpQkFBaUI7SUFDekM7SUFDQUEsb0JBQW9CO1FBQ2hCLE1BQU1ELFVBQVcsQ0FBQztRQUNsQixNQUFNRSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUN0QyxNQUFNQyxZQUFZLElBQUksQ0FBQ0EsU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMxQyxNQUFNRSxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDRixJQUFJLENBQUMsSUFBSTtRQUN4QyxNQUFNRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSSxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSixJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSyxNQUFNLElBQUksQ0FBQ0EsR0FBRyxDQUFDTCxJQUFJLENBQUMsSUFBSTtRQUM5QixNQUFNTSxTQUFTLElBQUksQ0FBQ0EsTUFBTSxDQUFDTixJQUFJLENBQUMsSUFBSTtRQUNwQyxNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDUCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNUSxhQUFhLENBQUNDO1lBQVEsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ00sR0FBRztR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QUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0FBQ2hCLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS44LjBfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcz8yNTg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBBZGRyZXNzWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIHBhcnNlIGFzIHBhcnNlVHJhbnNhY3Rpb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0gdGhpcy5nZXREZWZhdWx0Rm9ybWF0cygpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0Rm9ybWF0cygpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0cyA9ICh7fSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHN0cmljdERhdGEgPSAodikgPT4geyByZXR1cm4gdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgLy8gbXVzdCBiZSBzZXRcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB2YWx1ZTogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBjcmVhdGVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLFxuICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHQgPSB7XG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgICAgICAgICByb290OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBzdGF0dXM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9jayA9IHtcbiAgICAgICAgICAgIGhhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBoYXNoLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBtaW5lcjogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSksXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlcilcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBzaGFsbG93Q29weShmb3JtYXRzLmJsb2NrKTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBmb3JtYXRzLmZpbHRlciA9IHtcbiAgICAgICAgICAgIGZyb21CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmZpbHRlckxvZyA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dGYWxzaXNoKGRhdGEsIFwiMHhcIiksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICAgIGFjY2Vzc0xpc3QoYWNjZXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeShhY2Nlc3NMaXN0IHx8IFtdKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIG51bWJlcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20obnVtYmVyKS50b051bWJlcigpO1xuICAgIH1cbiAgICB0eXBlKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIgfHwgbnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBiaWdOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuICAgIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib29sZWFuIC0gXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGhleCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBkYXRhKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGE7IG9kZC1sZW5ndGggLSBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBhZGRyZXNzXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICBjYWxsQWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGhleERhdGFTbGljZSh2YWx1ZSwgMTIpKTtcbiAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBBZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcbiAgICB9XG4gICAgY29udHJhY3RBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJlYXJsaWVzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjogcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiIHx8IGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFZhbHVlKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGhhc2gsIG9wdGlvbmFsbHkgcmVxdWlyZXMgMHggcHJlZml4OyByZXR1cm5zIHByZWZpeGVkIGxvd2VyY2FzZSBoYXNoLlxuICAgIGhhc2godmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgocmVzdWx0KSAhPT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuICAgIGRpZmZpY3VsdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB1aW50MjU2KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodmFsdWUsIDMyKTtcbiAgICB9XG4gICAgX2Jsb2NrKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmF1dGhvciAhPSBudWxsICYmIHZhbHVlLm1pbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlLm1pbmVyID0gdmFsdWUuYXV0aG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkaWZmaWN1bHR5IG1heSBuZWVkIHRvIGNvbWUgZnJvbSBfZGlmZmljdWx0eSBpbiByZWN1cnNlZCBibG9ja3NcbiAgICAgICAgY29uc3QgZGlmZmljdWx0eSA9ICh2YWx1ZS5fZGlmZmljdWx0eSAhPSBudWxsKSA/IHZhbHVlLl9kaWZmaWN1bHR5IDogdmFsdWUuZGlmZmljdWx0eTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICByZXN1bHQuX2RpZmZpY3VsdHkgPSAoKGRpZmZpY3VsdHkgPT0gbnVsbCkgPyBudWxsIDogQmlnTnVtYmVyLmZyb20oZGlmZmljdWx0eSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBibG9jayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9jayk7XG4gICAgfVxuICAgIGJsb2NrV2l0aFRyYW5zYWN0aW9ucyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgdHJhbnNhY3Rpb25SZXF1ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvblJlc3BvbnNlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhcyAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdHJhbnNhY3Rpb24uZ2FzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAgICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5pbnB1dCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHRyYW5zYWN0aW9uLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvID09IG51bGwgJiYgdHJhbnNhY3Rpb24uY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHJhbnNhY3Rpb24udHlwZSA9PT0gMSB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAyKSAmJiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiByZXN1bHQuYmxvY2tIYXNoLnJlcGxhY2UoLzAvZywgXCJcIikgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHRMb2codmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdExvZywgdmFsdWUpO1xuICAgIH1cbiAgICByZWNlaXB0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuICAgICAgICAvLyBSU0sgaW5jb3JyZWN0bHkgaW1wbGVtZW50ZWQgRUlQLTY1OCwgc28gd2UgbXVuZ2UgdGhpbmdzIGEgYml0IGhlcmUgZm9yIGl0XG4gICAgICAgIGlmIChyZXN1bHQucm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJvb3QubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBiZSAweDAwLCAweDAsIDB4MDEgb3IgMHgxXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbShyZXN1bHQucm9vdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsICYmIChyZXN1bHQuc3RhdHVzICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbHQtcm9vdC1zdGF0dXMvc3RhdHVzIG1pc21hdGNoXCIsIFwidmFsdWVcIiwgeyByb290OiByZXN1bHQucm9vdCwgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWx0LXJvb3Qtc3RhdHVzXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJvb3QubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICAgICAgICAgIC8vIE11c3QgYmUgYSB2YWxpZCBieXRlczMyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcm9vdCBoYXNoXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJ5emFudGl1bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9waWNzKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy50b3BpY3ModikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2godmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZpbHRlckxvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGNoZWNrKGZvcm1hdCwgb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmb3JtYXRba2V5XShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja0tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gaWYgdmFsdWUgaXMgbnVsbC1pc2gsIG51bGxWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdmFsdWUgaXMgZmFsc2UtaXNoLCByZXBsYWNlVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBzdGF0aWMgYWxsb3dGYWxzaXNoKGZvcm1hdCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuICAgIHN0YXRpYyBhcnJheU9mKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmb3JtYXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcbn1cbi8vIFNob3cgdGhlIHRocm90dGxlIG1lc3NhZ2Ugb25seSBvbmNlXG5sZXQgdGhyb3R0bGVNZXNzYWdlID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5pby9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHRlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImdldENvbnRyYWN0QWRkcmVzcyIsIkJpZ051bWJlciIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhWYWx1ZSIsImhleFplcm9QYWQiLCJpc0hleFN0cmluZyIsIkFkZHJlc3NaZXJvIiwic2hhbGxvd0NvcHkiLCJhY2Nlc3NMaXN0aWZ5IiwicGFyc2UiLCJwYXJzZVRyYW5zYWN0aW9uIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkZvcm1hdHRlciIsImNvbnN0cnVjdG9yIiwiZm9ybWF0cyIsImdldERlZmF1bHRGb3JtYXRzIiwiYWRkcmVzcyIsImJpbmQiLCJiaWdOdW1iZXIiLCJibG9ja1RhZyIsImRhdGEiLCJoYXNoIiwiaGV4IiwibnVtYmVyIiwidHlwZSIsInN0cmljdERhdGEiLCJ2IiwidHJhbnNhY3Rpb24iLCJhY2Nlc3NMaXN0IiwiYWxsb3dOdWxsIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJ0cmFuc2FjdGlvbkluZGV4IiwiY29uZmlybWF0aW9ucyIsImZyb20iLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwiZ2FzTGltaXQiLCJ0byIsInZhbHVlIiwibm9uY2UiLCJyIiwidWludDI1NiIsInMiLCJjcmVhdGVzIiwicmF3IiwidHJhbnNhY3Rpb25SZXF1ZXN0IiwicmVjZWlwdExvZyIsInRyYW5zYWN0aW9uSGFzaCIsInRvcGljcyIsImFycmF5T2YiLCJsb2dJbmRleCIsInJlY2VpcHQiLCJjb250cmFjdEFkZHJlc3MiLCJyb290IiwiZ2FzVXNlZCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwic3RhdHVzIiwiYmxvY2siLCJwYXJlbnRIYXNoIiwidGltZXN0YW1wIiwiZGlmZmljdWx0eSIsIm1pbmVyIiwiZXh0cmFEYXRhIiwidHJhbnNhY3Rpb25zIiwiYmFzZUZlZVBlckdhcyIsImJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9uUmVzcG9uc2UiLCJmaWx0ZXIiLCJmcm9tQmxvY2siLCJ1bmRlZmluZWQiLCJ0b0Jsb2NrIiwiZmlsdGVyTG9nIiwicmVtb3ZlZCIsImJvb2xlYW4iLCJhbGxvd0ZhbHNpc2giLCJ0b051bWJlciIsInRvTG93ZXJDYXNlIiwiRXJyb3IiLCJzdHJpY3QiLCJzdWJzdHJpbmciLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJyZXN1bHQiLCJsZW5ndGgiLCJjYWxsQWRkcmVzcyIsImVycm9yIiwiX2Jsb2NrIiwiZm9ybWF0IiwiYXV0aG9yIiwiX2RpZmZpY3VsdHkiLCJjaGVjayIsImdhcyIsImlzWmVybyIsImlucHV0IiwiY2hhaW5JZCIsIm5ldHdvcmtJZCIsInBhcnNlSW50IiwicmVwbGFjZSIsImJ5emFudGl1bSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm9iamVjdCIsImtleSIsImNoZWNrS2V5IiwiY2hlY2tWYWx1ZSIsIm51bGxWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsImFycmF5IiwiZm9yRWFjaCIsInB1c2giLCJpc0NvbW11bml0eVJlc291cmNhYmxlIiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsInRocm90dGxlTWVzc2FnZSIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-signer@5.8.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/.pnpm/@ethersproject+hash@5.8.0/node_modules/@ethersproject/hash/lib.esm/typed-data.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/.pnpm/@ethersproject+strings@5.8.0/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/.pnpm/@ethersproject+transactions@5.8.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/.pnpm/@ethersproject+web@5.8.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst errorGas = [\n    \"call\",\n    \"estimateGas\"\n];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(\"reverted\")) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return {\n                message: value.message,\n                data\n            };\n        }\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) {}\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\",\n            transaction,\n            error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message,\n                method,\n                transaction,\n                error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === \"string\") {\n        message = error.error.message;\n    } else if (typeof error.body === \"string\") {\n        message = error.body;\n    } else if (typeof error.responseText === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            error,\n            method,\n            transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error,\n            method,\n            transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nclass JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {\n    constructor(constructorGuard, provider, addressOrIndex){\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof addressOrIndex === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", null);\n        } else if (typeof addressOrIndex === \"number\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", addressOrIndex);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", null);\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts)=>{\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n        const fromAddress = this.getAddress().then((address)=>{\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.provider.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({\n            tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender })=>{\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {\n                from: true\n            });\n            return this.provider.send(\"eth_sendTransaction\", [\n                hexTx\n            ]).then((hash)=>{\n                return hash;\n            }, (error)=>{\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                        const tx = yield this.provider.getTransaction(hash);\n                        if (tx === null) {\n                            return undefined;\n                        }\n                        return this.provider._wrapTransaction(tx, hash, blockNumber);\n                    }), {\n                    oncePoll: this.provider\n                });\n            } catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data),\n                    address.toLowerCase()\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [\n                    address.toLowerCase(),\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Populate any ENS names (in-place)\n            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, (name)=>{\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: {\n                            domain: populated.domain,\n                            types,\n                            value: populated.value\n                        }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [\n                address.toLowerCase(),\n                password,\n                null\n            ]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash)=>{\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations)=>{\n                    return this.provider.waitForTransaction(hash, confirmations);\n                }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {\n    constructor(url, network){\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    this.detectNetwork().then((network)=>{\n                        resolve(network);\n                    }, (error)=>{\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http://localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(()=>{\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            } catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                } catch (error) {}\n            }\n            if (chainId != null) {\n                const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());\n                } catch (error) {\n                    return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts)=>{\n            return accounts.map((a)=>this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch(method){\n            case \"getBlockNumber\":\n                return [\n                    \"eth_blockNumber\",\n                    []\n                ];\n            case \"getGasPrice\":\n                return [\n                    \"eth_gasPrice\",\n                    []\n                ];\n            case \"getBalance\":\n                return [\n                    \"eth_getBalance\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getTransactionCount\":\n                return [\n                    \"eth_getTransactionCount\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getCode\":\n                return [\n                    \"eth_getCode\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getStorageAt\":\n                return [\n                    \"eth_getStorageAt\",\n                    [\n                        getLowerCase(params.address),\n                        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(params.position, 32),\n                        params.blockTag\n                    ]\n                ];\n            case \"sendTransaction\":\n                return [\n                    \"eth_sendRawTransaction\",\n                    [\n                        params.signedTransaction\n                    ]\n                ];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\n                        \"eth_getBlockByNumber\",\n                        [\n                            params.blockTag,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                } else if (params.blockHash) {\n                    return [\n                        \"eth_getBlockByHash\",\n                        [\n                            params.blockHash,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\n                    \"eth_getTransactionByHash\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"getTransactionReceipt\":\n                return [\n                    \"eth_getTransactionReceipt\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"call\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_call\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            }),\n                            params.blockTag\n                        ]\n                    ];\n                }\n            case \"estimateGas\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_estimateGas\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            })\n                        ]\n                    ];\n                }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\n                    \"eth_getLogs\",\n                    [\n                        params.filter\n                    ]\n                ];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);\n                            params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n                    operation: method\n                });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            } catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [\n                    filterId\n                ]).then(function(hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [\n                            filterId\n                        ]);\n                        return;\n                    }\n                    setTimeout(function() {\n                        poll();\n                    }, 0);\n                    return null;\n                }).catch((error)=>{});\n            }\n            poll();\n            return filterId;\n        }).catch((error)=>{});\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for(const key in allowExtra){\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);\n        }\n        return result;\n    }\n} //# sourceMappingURL=json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuOC4wX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFD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UUEsQ0FBQ0YsK0RBQVNBLENBQUNnRixJQUFJLENBQUMvQyxXQUFXLENBQUNQLElBQUk7WUFDdEQsSUFBSUEsUUFBUSxZQUFZO2dCQUNwQkEsTUFBTTtZQUNWO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd4QztRQUNsQjtRQUNBO1lBQUM7WUFBUTtZQUFNO1NBQU8sQ0FBQzZMLE9BQU8sQ0FBQyxTQUFVckosR0FBRztZQUN4QyxJQUFJTyxXQUFXLENBQUNQLElBQUksSUFBSSxNQUFNO2dCQUMxQjtZQUNKO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd6Qiw2REFBT0EsQ0FBQ2dDLFdBQVcsQ0FBQ1AsSUFBSTtRQUMxQztRQUNBLElBQUlPLFlBQVl5RixVQUFVLEVBQUU7WUFDeEIvSCxNQUFNLENBQUMsYUFBYSxHQUFHa0IsMkVBQWFBLENBQUNvQixZQUFZeUYsVUFBVTtRQUMvRDtRQUNBLE9BQU8vSDtJQUNYO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjguMF9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtcHJvdmlkZXIuanM/MTA2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBfVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBjaGVja1Byb3BlcnRpZXMsIGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IGZldGNoSnNvbiwgcG9sbCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC93ZWJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEJhc2VQcm92aWRlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmNvbnN0IGVycm9yR2FzID0gW1wiY2FsbFwiLCBcImVzdGltYXRlR2FzXCJdO1xuZnVuY3Rpb24gc3BlbHVuayh2YWx1ZSwgcmVxdWlyZURhdGEpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKFwicmV2ZXJ0ZWRcIikpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGlzSGV4U3RyaW5nKHZhbHVlLmRhdGEpID8gdmFsdWUuZGF0YSA6IG51bGw7XG4gICAgICAgIGlmICghcmVxdWlyZURhdGEgfHwgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVuayh2YWx1ZVtrZXldLCByZXF1aXJlRGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVuayhKU09OLnBhcnNlKHZhbHVlKSwgcmVxdWlyZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHBhcmFtcy50cmFuc2FjdGlvbiB8fCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgLy8gVW5kbyB0aGUgXCJjb252ZW5pZW5jZVwiIHNvbWUgbm9kZXMgYXJlIGF0dGVtcHRpbmcgdG8gcHJldmVudCBiYWNrd2FyZHNcbiAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVuayhlcnJvciwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RoaW5nIGRlc2NyaXB0aXZlLi5cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJldmVydCBkYXRhIGluIGNhbGwgZXhjZXB0aW9uOyBUcmFuc2FjdGlvbiByZXZlcnRlZCB3aXRob3V0IGEgcmVhc29uIHN0cmluZ1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICBkYXRhOiBcIjB4XCIsIHRyYW5zYWN0aW9uLCBlcnJvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHNvbWV0aGluZywgd2l0aCBhIHByZWZlcmVuY2Ugb24gU0VSVkVSX0VSUk9SIGJvZHlcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IuYm9keSwgZmFsc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VuZCBcInJldmVydGVkXCIsIHRoaXMgaXMgYSBDQUxMX0VYQ0VQVElPTlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0Lm1lc3NhZ2UsIG1ldGhvZCwgdHJhbnNhY3Rpb24sIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogU2hvdWxkIHdlIHNwZWx1bmsgZm9yIG1lc3NhZ2UgdG9vP1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IgJiYgZXJyb3IuZXJyb3IgJiYgdHlwZW9mIChlcnJvci5lcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5ib2R5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5yZXNwb25zZVRleHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBnYXMgKiBwcmljZSArIHZhbHVlICsgY29zdChkYXRhKVwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdHxJbnN1ZmZpY2llbnRGdW5kcy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIm5vbmNlIHRvbyBsb3dcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZSAoaXMgKT90b28gbG93L2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZHx0cmFuc2FjdGlvbiBnYXMgcHJpY2UuKnRvbyBsb3cvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvckdhcy5pbmRleE9mKG1ldGhvZCkgPj0gMCAmJiBtZXNzYWdlLm1hdGNoKC9nYXMgcmVxdWlyZWQgZXhjZWVkcyBhbGxvd2FuY2V8YWx3YXlzIGZhaWxpbmcgdHJhbnNhY3Rpb258ZXhlY3V0aW9uIHJldmVydGVkfHJldmVydC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiB0aW1lcih0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5leHBvcnQgY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgcHJvdmlkZXIsIGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG8gbm90IGNhbGwgdGhlIEpzb25ScGNTaWduZXIgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBwcm92aWRlci5nZXRTaWduZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIGlmIChhZGRyZXNzT3JJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzT3JJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hZGRyZXNzXCIsIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pbmRleFwiLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hZGRyZXNzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLCBcImFkZHJlc3NPckluZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBhbHRlciBKU09OLVJQQyBTaWduZXIgY29ubmVjdGlvblwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdFVuY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLnByb3ZpZGVyLCB0aGlzLl9hZGRyZXNzIHx8IHRoaXMuX2luZGV4KTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FkZHJlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSkudGhlbigoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPD0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVua25vd24gYWNjb3VudCAjXCIgKyB0aGlzLl9pbmRleCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3NcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbdGhpcy5faW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZnJvbUFkZHJlc3MgPSB0aGlzLmdldEFkZHJlc3MoKS50aGVuKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGVzdGltYXRlLmZyb20gPSBmcm9tQWRkcmVzcztcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyhlc3RpbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLnRvKS50aGVuKCh0bykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZSh0byk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLCBcInR4LnRvXCIsIHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiByZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzXG4gICAgICAgIH0pLnRoZW4oKHsgdHgsIHNlbmRlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IHNlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5jb25zdHJ1Y3Rvci5oZXhsaWZ5VHJhbnNhY3Rpb24odHgsIHsgZnJvbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pLnRoZW4oKGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCB0cmFuc2FjdGlvblwiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgaGV4VHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwic2lnbmluZyB0cmFuc2FjdGlvbnMgaXMgdW5zdXBwb3J0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduVHJhbnNhY3Rpb25cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5wcm92aWRlci5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wcm92aWRlci5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzLnByb3ZpZGVyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW2hleGxpZnkoZGF0YSksIGFkZHJlc3MudG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHNpZ25pbmdcIiwgTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9sZWdhY3lTaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgaGV4bGlmeShkYXRhKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHNpZ25pbmdcIiwgTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJfbGVnYWN5U2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YTogbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSB5aWVsZCBfVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShfVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHNpZ25pbmdcIiwgTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJfc2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7IGRvbWFpbjogcG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHZhbHVlOiBwb3B1bGF0ZWQudmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bmxvY2socGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbF0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyIGV4dGVuZHMgSnNvblJwY1NpZ25lciB7XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBudWxsLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAwLFxuICAgICAgICAgICAgICAgIGZyb206IG51bGwsXG4gICAgICAgICAgICAgICAgd2FpdDogKGNvbmZpcm1hdGlvbnMpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIGNvbmZpcm1hdGlvbnMpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWVcbn07XG5leHBvcnQgY2xhc3MgSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmspIHtcbiAgICAgICAgbGV0IG5ldHdvcmtPclJlYWR5ID0gbmV0d29yaztcbiAgICAgICAgLy8gVGhlIG5ldHdvcmsgaXMgdW5rbm93biwgcXVlcnkgdGhlIEpTT04tUlBDIGZvciBpdFxuICAgICAgICBpZiAobmV0d29ya09yUmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV0d29ya09yUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oKG5ldHdvcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrT3JSZWFkeSk7XG4gICAgICAgIC8vIERlZmF1bHQgVVJMXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB1cmwgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJkZWZhdWx0VXJsXCIpKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZShzaGFsbG93Q29weSh1cmwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmV4dElkID0gNDI7XG4gICAgfVxuICAgIGdldCBfY2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExvb3BDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudExvb3BDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudExvb3BDYWNoZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRVcmwoKSB7XG4gICAgICAgIHJldHVybiBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSB0aGlzLl91bmNhY2hlZERldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgY2FjaGUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXTtcbiAgICB9XG4gICAgX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRpbWVyKDApO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IHlpZWxkIHRoaXMuc2VuZChcIm5ldF92ZXJzaW9uXCIsIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXROZXR3b3JrID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0TmV0d29ya1wiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV0d29yayhCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJpbnZhbGlkTmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJub05ldHdvcmtcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgfVxuICAgIGdldFVuY2hlY2tlZFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpLmNvbm5lY3RVbmNoZWNrZWQoKTtcbiAgICB9XG4gICAgbGlzdEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoaXMgaW4gdGhlIGZ1dHVyZSB0byBhbnkgY2FsbCwgYnV0IGZvciBub3cgdGhlc2VcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBjYWNoZSA9IChbXCJldGhfY2hhaW5JZFwiLCBcImV0aF9ibG9ja051bWJlclwiXS5pbmRleE9mKG1ldGhvZCkgPj0gMCk7XG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBmZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWNoZSB0aGUgZmV0Y2gsIGJ1dCBjbGVhciBpdCBvbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHJlcGFyZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfYmxvY2tOdW1iZXJcIiwgW11dO1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nYXNQcmljZVwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmFsYW5jZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0Q29kZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRTdG9yYWdlQXRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIGhleFplcm9QYWQocGFyYW1zLnBvc2l0aW9uLCAzMiksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsIFtwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25dXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsIFtwYXJhbXMuYmxvY2tUYWcsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLmJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlIYXNoXCIsIFtwYXJhbXMuYmxvY2tIYXNoLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLCBbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4bGlmeVRyYW5zYWN0aW9uID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfY2FsbFwiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4bGlmeVRyYW5zYWN0aW9uID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZXN0aW1hdGVHYXNcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlciAmJiBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRMb2dzXCIsIFtwYXJhbXMuZmlsdGVyXV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBMZWdhY3kgbmV0d29ya3MgZG8gbm90IGxpa2UgdGhlIHR5cGUgZmllbGQgYmVpbmcgcGFzc2VkIGFsb25nICh3aGljaFxuICAgICAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBwYXJhbXMudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBCaWdOdW1iZXIuZnJvbSh0eC50eXBlKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgbm9uLUVJUC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0geWllbGQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gc2hhbGxvd0NvcHkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHJhbnNhY3Rpb24gPSBzaGFsbG93Q29weSh0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50cmFuc2FjdGlvbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucHJlcGFyZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2VuZChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRQZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0YXJ0RXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfc3RhcnRQZW5kaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0ZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdGaWx0ZXIgPSB0aGlzLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IHBlbmRpbmdGaWx0ZXI7XG4gICAgICAgIHBlbmRpbmdGaWx0ZXIudGhlbihmdW5jdGlvbiAoZmlsdGVySWQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSkudGhlbihmdW5jdGlvbiAoaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9wZW5kaW5nRmlsdGVyICE9IHBlbmRpbmdGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXEgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhdCBzb21lIHBvaW50Li4uIEhvdz8gV2hlbj9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2VtaXR0ZWRbXCJ0OlwiICsgaGFzaC50b0xvd2VyQ2FzZSgpXSA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxID0gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcInBlbmRpbmdcIiwgdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lcigxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9wZW5kaW5nRmlsdGVyICE9IHBlbmRpbmdGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHBvbGwoKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbGwoKTtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiICYmIHRoaXMubGlzdGVuZXJDb3VudChcInBlbmRpbmdcIikgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9zdG9wRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBnYXNMaW1pdCA9PiBnYXNcbiAgICAvLyAgLSBBbGwgdmFsdWVzIGhleGxpZmllZFxuICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcbiAgICAvLyAgLSBBbGwgYWRkcmVzc2VzIGFyZSBsb3dlcmNhc2VkXG4gICAgLy8gTk9URTogVGhpcyBhbGxvd3MgYSBUcmFuc2FjdGlvblJlcXVlc3QsIGJ1dCBhbGwgdmFsdWVzIHNob3VsZCBiZSByZXNvbHZlZFxuICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuICAgIC8vIEBUT0RPOiBUaGlzIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIGFuZCBwcmVwYXJlUmVxdWVzdFxuICAgIC8vICAgICAgICB3aWxsIGJlIHRoZSBwcmVmZXJyZWQgbWV0aG9kIGZvciB0aGlzLlxuICAgIHN0YXRpYyBoZXhsaWZ5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcbiAgICAgICAgLy8gQ2hlY2sgb25seSBhbGxvd2VkIHByb3BlcnRpZXMgYXJlIGdpdmVuXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBzaGFsbG93Q29weShhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcbiAgICAgICAgaWYgKGFsbG93RXh0cmEpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93RXh0cmEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dFeHRyYVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZXhWYWx1ZShCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbltrZXldKSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1ycGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlNpZ25lciIsIkJpZ051bWJlciIsImhleGxpZnkiLCJoZXhWYWx1ZSIsImhleFplcm9QYWQiLCJpc0hleFN0cmluZyIsIl9UeXBlZERhdGFFbmNvZGVyIiwiY2hlY2tQcm9wZXJ0aWVzIiwiZGVlcENvcHkiLCJkZWZpbmVSZWFkT25seSIsImdldFN0YXRpYyIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhbGxvd0NvcHkiLCJ0b1V0ZjhCeXRlcyIsImFjY2Vzc0xpc3RpZnkiLCJmZXRjaEpzb24iLCJwb2xsIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkJhc2VQcm92aWRlciIsImVycm9yR2FzIiwic3BlbHVuayIsInJlcXVpcmVEYXRhIiwibWVzc2FnZSIsIm1hdGNoIiwiZGF0YSIsImtleSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY2hlY2tFcnJvciIsIm1ldGhvZCIsInBhcmFtcyIsInRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiQ0FMTF9FWENFUFRJT04iLCJib2R5IiwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVQiLCJyZWFzb24iLCJjb2RlIiwiU0VSVkVSX0VSUk9SIiwicmVzcG9uc2VUZXh0IiwidG9Mb3dlckNhc2UiLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJOT05DRV9FWFBJUkVEIiwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJpbmRleE9mIiwidGltZXIiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImdldFJlc3VsdCIsInBheWxvYWQiLCJFcnJvciIsImdldExvd2VyQ2FzZSIsIl9jb25zdHJ1Y3Rvckd1YXJkIiwiSnNvblJwY1NpZ25lciIsImNvbnN0cnVjdG9yIiwiY29uc3RydWN0b3JHdWFyZCIsInByb3ZpZGVyIiwiYWRkcmVzc09ySW5kZXgiLCJmb3JtYXR0ZXIiLCJhZGRyZXNzIiwidGhyb3dBcmd1bWVudEVycm9yIiwiY29ubmVjdCIsIm9wZXJhdGlvbiIsImNvbm5lY3RVbmNoZWNrZWQiLCJVbmNoZWNrZWRKc29uUnBjU2lnbmVyIiwiX2FkZHJlc3MiLCJfaW5kZXgiLCJnZXRBZGRyZXNzIiwic2VuZCIsImFjY291bnRzIiwibGVuZ3RoIiwic2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uIiwiZnJvbUFkZHJlc3MiLCJnYXNMaW1pdCIsImVzdGltYXRlIiwiZnJvbSIsImVzdGltYXRlR2FzIiwidG8iLCJyZXNvbHZlTmFtZSIsInR4Iiwic2VuZGVyIiwiaGV4VHgiLCJoZXhsaWZ5VHJhbnNhY3Rpb24iLCJoYXNoIiwiQUNUSU9OX1JFSkVDVEVEIiwiYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwic2VuZFRyYW5zYWN0aW9uIiwiYmxvY2tOdW1iZXIiLCJfZ2V0SW50ZXJuYWxCbG9ja051bWJlciIsInBvbGxpbmdJbnRlcnZhbCIsImdldFRyYW5zYWN0aW9uIiwidW5kZWZpbmVkIiwiX3dyYXBUcmFuc2FjdGlvbiIsIm9uY2VQb2xsIiwidHJhbnNhY3Rpb25IYXNoIiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlRGF0YSIsIl9sZWdhY3lTaWduTWVzc2FnZSIsIl9zaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJwb3B1bGF0ZWQiLCJyZXNvbHZlTmFtZXMiLCJuYW1lIiwic3RyaW5naWZ5IiwiZ2V0UGF5bG9hZCIsInVubG9jayIsInBhc3N3b3JkIiwibm9uY2UiLCJnYXNQcmljZSIsImNoYWluSWQiLCJjb25maXJtYXRpb25zIiwid2FpdCIsIndhaXRGb3JUcmFuc2FjdGlvbiIsImFsbG93ZWRUcmFuc2FjdGlvbktleXMiLCJ0eXBlIiwiYWNjZXNzTGlzdCIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiSnNvblJwY1Byb3ZpZGVyIiwidXJsIiwibmV0d29yayIsIm5ldHdvcmtPclJlYWR5IiwiZGV0ZWN0TmV0d29yayIsIk9iamVjdCIsImZyZWV6ZSIsIl9uZXh0SWQiLCJfY2FjaGUiLCJfZXZlbnRMb29wQ2FjaGUiLCJkZWZhdWx0VXJsIiwiX3VuY2FjaGVkRGV0ZWN0TmV0d29yayIsImdldE5ldHdvcmsiLCJ0b051bWJlciIsIk5FVFdPUktfRVJST1IiLCJldmVudCIsInNlcnZlckVycm9yIiwiZ2V0U2lnbmVyIiwiZ2V0VW5jaGVja2VkU2lnbmVyIiwibGlzdEFjY291bnRzIiwibWFwIiwiYSIsInJlcXVlc3QiLCJpZCIsImpzb25ycGMiLCJlbWl0IiwiY2FjaGUiLCJjb25uZWN0aW9uIiwicmVzcG9uc2UiLCJwcmVwYXJlUmVxdWVzdCIsImJsb2NrVGFnIiwicG9zaXRpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tIYXNoIiwiZmlsdGVyIiwicGVyZm9ybSIsImlzWmVybyIsImZlZURhdGEiLCJnZXRGZWVEYXRhIiwiYXJncyIsIk5PVF9JTVBMRU1FTlRFRCIsIl9zdGFydEV2ZW50IiwidGFnIiwiX3N0YXJ0UGVuZGluZyIsIl9wZW5kaW5nRmlsdGVyIiwic2VsZiIsInBlbmRpbmdGaWx0ZXIiLCJmaWx0ZXJJZCIsImhhc2hlcyIsInNlcSIsImZvckVhY2giLCJfZW1pdHRlZCIsImNhdGNoIiwiX3N0b3BFdmVudCIsImxpc3RlbmVyQ291bnQiLCJhbGxvd0V4dHJhIiwiYWxsb3dlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+providers@5.8.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n");

/***/ })

};
;